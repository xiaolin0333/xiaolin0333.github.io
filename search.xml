<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="https://i-blog.csdnimg.cn/direct/86ce0a77e3a242f493d740b3a7bc615e.png" alt="在这里插入图片描述"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/be6f6e0058b14d0eaced342c6160c8ac.png" alt="在这里插入图片描述"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="https://i-blog.csdnimg.cn/direct/e0c5fb89dfd84977a33ba998567a74f7.png" alt="在这里插入图片描述"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="https://i-blog.csdnimg.cn/direct/75ccadc7eac740b0a2dfec05731a4136.png" alt="在这里插入图片描述"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="https://i-blog.csdnimg.cn/direct/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="在这里插入图片描述"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/7d44413b38b94fe98df341556698d3c7.png" alt="在这里插入图片描述"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="https://i-blog.csdnimg.cn/direct/185030e49e7d43409502a8c48db5b469.png" alt="在这里插入图片描述"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="https://i-blog.csdnimg.cn/direct/1c0a9b60a73f4b40a655257f72e188b6.png" alt="在这里插入图片描述"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="https://i-blog.csdnimg.cn/direct/25c8751bd3024b3ca43d05051e22735c.png" alt="在这里插入图片描述"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="https://i-blog.csdnimg.cn/direct/c6dab1985c4b44fbacb3ac92514492b7.png" alt="在这里插入图片描述"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="https://i-blog.csdnimg.cn/direct/4d93bc3624974d43951035b7b828d5c5.png" alt="在这里插入图片描述"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="https://i-blog.csdnimg.cn/direct/1403ed11ca8f49c0907b34d62a592c96.png" alt="在这里插入图片描述"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="https://i-blog.csdnimg.cn/direct/1873509cc7b04927868a9fb188b42fd6.png" alt="在这里插入图片描述"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br><code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="https://i-blog.csdnimg.cn/direct/5be5b756eaa847b095f13d98145cab10.png" alt="在这里插入图片描述"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="https://i-blog.csdnimg.cn/direct/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="在这里插入图片描述"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
