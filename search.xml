<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>把本地搭建的hexo博客部署到自己的服务器上</title>
      <link href="/post/920afe3c.html"/>
      <url>/post/920afe3c.html</url>
      
        <content type="html"><![CDATA[<h1 id="配置远程服务器的git"><a href="#配置远程服务器的git" class="headerlink" title="配置远程服务器的git"></a>配置远程服务器的git</h1><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><ol><li>安装依赖工具包</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel</span><br></pre></td></tr></table></figure><ol start="2"><li>安装编译工具</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y gcc perl-ExtUtils-MakeMaker package</span><br></pre></td></tr></table></figure><ol start="3"><li>下载git，也可以去<a href="https://git-scm.com/downloads/linux">官网</a>下载了传到服务器上</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://www.kernel.org/pub/software/scm/git/git-2.34.0.tar.gz --no-check-certificate</span><br></pre></td></tr></table></figure><ol start="4"><li>解压文件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxf git-2.34.0.tar.gz</span><br></pre></td></tr></table></figure><ol start="5"><li>安装git：进入到git目录下，编译：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd git-2.34.0</span><br><span class="line">make all prefix=/usr/local/git</span><br></pre></td></tr></table></figure><p>安装git到&#x2F;usr&#x2F;local&#x2F;git下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make install prefix=/usr/local/git</span><br></pre></td></tr></table></figure><ol start="6"><li>配置git环境变量，将git加入PATH目录中：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=$PATH:/usr/local/git/bin&#x27; &gt;&gt; /etc/bashrc</span><br></pre></td></tr></table></figure><p>使配置生效：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/bashrc</span><br></pre></td></tr></table></figure><p>查看git版本，如果成功说明已经安装成功：<code>git --version</code></p><h2 id="创建用户并配置ssh免密登录"><a href="#创建用户并配置ssh免密登录" class="headerlink" title="创建用户并配置ssh免密登录"></a>创建用户并配置ssh免密登录</h2><ol><li>在服务器上创建用户并设置密码</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adduser xiaolin</span><br><span class="line">passwd 密码</span><br></pre></td></tr></table></figure><ol start="2"><li>为用户分配选线</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usermod xiaolin -G wheel</span><br></pre></td></tr></table></figure><ol start="3"><li>创建本地密钥：在本机cmd输入</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>去对应的路径下查看生成好的密钥<code>id_rsa.pub</code></p><ol start="4"><li>回到linux服务器，切换前面创建的xiaolin用户：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su - xiaolin</span><br></pre></td></tr></table></figure><ol start="5"><li>创建.ssh文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir .ssh</span><br><span class="line">vim .ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>把前边本机生成的密钥复制到这个文件夹里</p><h2 id="git仓库配置"><a href="#git仓库配置" class="headerlink" title="git仓库配置"></a>git仓库配置</h2><p>切换到root用户</p><ol><li>创建git目录，并修改目录的所有权和用户权限</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/git/</span><br><span class="line">chown -R xiaolin:xiaolin /home/git/</span><br><span class="line">chmod -R 755 /home/git/</span><br></pre></td></tr></table></figure><ol start="2"><li>进入目录后，建立git仓库，修改权限</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/git/</span><br><span class="line">git init --bare blog.git # 初始化git仓库</span><br><span class="line">chown xiaolin:xiaolin -R blog.git</span><br></pre></td></tr></table></figure><ol start="3"><li>新建钩子文件post-receive</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><p>把以下内容复制到post-receive文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/home/blog --git-dir=/home/git/blog.git checkout -f</span><br></pre></td></tr></table></figure><blockquote><p>将存储库&#x2F;home&#x2F;git&#x2F;blog.git强制检出并将文件放置到指定的工作树目录&#x2F;home&#x2F;blog</p></blockquote><ol start="4"><li>修改文件权限：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /home/git/blog.git/hooks/post-receive</span><br></pre></td></tr></table></figure><h1 id="配置远程服务器的nginx"><a href="#配置远程服务器的nginx" class="headerlink" title="配置远程服务器的nginx"></a>配置远程服务器的nginx</h1><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><ol><li>安装nginx</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y nginx</span><br></pre></td></tr></table></figure><ol start="2"><li>启动nginx：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start nginx.service</span><br></pre></td></tr></table></figure><p>查看nginx的状态<code>systemctl status nginx.service </code>，如果为actice，说明安装成功。</p><h2 id="修改nginx的转发配置"><a href="#修改nginx的转发配置" class="headerlink" title="修改nginx的转发配置"></a>修改nginx的转发配置</h2><p>使用nginx -t查看nginx配置文件的路径：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\95aaa7542efe40698cc7443766e57c69.png" alt="95aaa7542efe40698cc7443766e57c69.png"></p><p><img src="D:\project\kaiFa\Blog\source_posts\assets\b8f743022f8649b1b1ae5316c7585b0b.png" alt="b8f743022f8649b1b1ae5316c7585b0b.png"></p><blockquote><p>server_name：服务器的IP或域名<br>root：博客存放的路径<code>/home/git/blog.git</code></p></blockquote><h1 id="配置Blog根目录"><a href="#配置Blog根目录" class="headerlink" title="配置Blog根目录"></a>配置Blog根目录</h1><p>在hexo博客打开<code>_config.yml</code>文件</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># repository: https://github.com/xiaolin0333/xiaolin0333.github.io.git # 传到github使用</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">xiaolin@xxx.xxx.xxx.xxx:/home/git/blog.git</span> <span class="comment"># 用户名@服务器ip:git仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>在删除这两个文件：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\6b030a2a888d41faabbe9dc89bbc93fd.png" alt="6b030a2a888d41faabbe9dc89bbc93fd.png"><br>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp; hexo d</span><br></pre></td></tr></table></figure><p>即可传到服务器上啦<br><img src="D:\project\kaiFa\Blog\source_posts\assets\cf64613591474883830379140e859dd4.png" alt="cf64613591474883830379140e859dd4.png"></p>]]></content>
      
      
      <categories>
          
          <category> 博客框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Jenkins</title>
      <link href="/post/c47d8526.html"/>
      <url>/post/c47d8526.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux中安装jenkins"><a href="#Linux中安装jenkins" class="headerlink" title="Linux中安装jenkins"></a>Linux中安装jenkins</h1><ol><li>采用RPM安装包方式：<a href="https://pkg.jenkins.io/redhat-stable/">Jenkins安装包下载地址</a></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://pkg.jenkins.io/redhat-stable/jenkins-2.190.1-1.1.noarch.rpm</span><br></pre></td></tr></table></figure><ol start="2"><li>执行安装</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh jenkins-2.190.1-1.1.noarch.rpm</span><br></pre></td></tr></table></figure><ol start="3"><li>修改配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure><p>修改内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改为对应的目标用户</span><br><span class="line">$JENKINS_USER=&quot;root&quot;</span><br><span class="line"># 服务监听端口</span><br><span class="line">JENKINS_PORT=&quot;16060&quot;</span><br></pre></td></tr></table></figure><ol start="4"><li>修改目录权限：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R root:root /var/lib/jenkins</span><br><span class="line">chown -R root:root /var/cache/jenkins</span><br><span class="line">chown -R root:root /var/log/jenkins</span><br></pre></td></tr></table></figure><ol start="5"><li>重启Jenkins：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure><blockquote><p>重启时出现报错不要慌，先查看一下jenkins日志：<code>cat /var/log/jenkins/jenkins.log</code></p></blockquote><h1 id="报错1-签名验证失败"><a href="#报错1-签名验证失败" class="headerlink" title="报错1. 签名验证失败"></a>报错1. 签名验证失败</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\03f1f32ae9604de5bbc709a548aa3b7e.png" alt="03f1f32ae9604de5bbc709a548aa3b7e.png"><br>解决：通过修改 Jenkins 的启动参数来禁用签名验证，Jenkins 将跳过签名验证，从而解决证书过期或验证失败的问题。</p><ol><li>修改 Jenkins 配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure><ol start="2"><li>在 JENKINS_JAVA_OPTIONS 参数中添加以下内容：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dhudson.model.DownloadService.noSignatureCheck=true</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\4669cdac3ad94548a200daaa41ed53ae.png" alt="4669cdac3ad94548a200daaa41ed53ae.png"></p><ol start="3"><li>重启jenkins：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure><h1 id="报错2-找不到java路径"><a href="#报错2-找不到java路径" class="headerlink" title="报错2. 找不到java路径"></a>报错2. 找不到java路径</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\739a0c5ea9174fabba691145c44c7797.png" alt="739a0c5ea9174fabba691145c44c7797.png"></p><ol><li>查看当前java环境位置</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\d7cc05840e3d4e68adf9ab610aad2b53.png" alt="d7cc05840e3d4e68adf9ab610aad2b53.png"></p><ol start="2"><li>修改环境变量</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/init.d/jenkins</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\d77fa50022ef45cb9e835c3fedb0367d.png" alt="d77fa50022ef45cb9e835c3fedb0367d.png"></p><blockquote><p>这里注意要进入到<code>/bin/java</code>下</p></blockquote><ol start="3"><li>加载并重启jenkins：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start jenkins</span><br></pre></td></tr></table></figure><h1 id="进入管理后台初始化设置"><a href="#进入管理后台初始化设置" class="headerlink" title="进入管理后台初始化设置"></a>进入管理后台初始化设置</h1><p>在浏览器输入：<code>http://192.168.140.102:16060/</code>即可进入jenkins控制台，注册jenkins账号：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\47de000d702e4d62b7cc3b258aa32189.png" alt="47de000d702e4d62b7cc3b258aa32189.png"></p><blockquote><p>如果登录进去没有“系统管理”和“用户列表”的解决办法：</p><ol><li>进入jenkins目录：<code>cd /var/lib/jenkins/</code></li><li>备份config.xml文件：<code>cp config.xml config.xml.bak</code></li><li>删除这块内容<br> <img src="D:\project\kaiFa\Blog\source_posts\assets\d0a9cfbd74c844a69f02e7c156f31a6c.png" alt="d0a9cfbd74c844a69f02e7c156f31a6c.png"><br> 替换为：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">authorizationStrategy</span> <span class="attr">class</span>=<span class="string">&quot;hudson.security.FullControlOnceLoggedInAuthorizationStrategy&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">denyAnonymousReadAccess</span>&gt;</span>true<span class="tag">&lt;/<span class="name">denyAnonymousReadAccess</span>&gt;</span></span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">authorizationStrategy</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>重启jenkins：<code>systemctl restart jenkins</code></li></ol></blockquote><h2 id="jenkins插件安装"><a href="#jenkins插件安装" class="headerlink" title="jenkins插件安装"></a>jenkins插件安装</h2><p>进入“系统管理” - “插件管理”，点击“可选插件”，在搜索框中搜索插件名称，安装如下插件：</p><ol><li>Maven Integration plugin： Maven 集成管理插件。</li><li>Docker plugin： Docker集成插件。</li><li>GitLab Plugin： GitLab集成插件。</li><li>Publish Over SSH：远程文件发布插件。</li><li>SSH: 远程脚本执行插件。</li></ol><blockquote><p>注：虽然在jenkins这里安装了插件，但是仍需要在服务器里安装对应的环境（maven、docker、jdk、git）</p></blockquote><h2 id="jenkins工具配置"><a href="#jenkins工具配置" class="headerlink" title="jenkins工具配置"></a>jenkins工具配置</h2><p>在jenkins控制台安装完jenkins插件，并且在服务器里也安装了对应的环境后，需要对这些环境在jenkins中进行配置。<br>进入“系统管理” - “全局工具配置”，指定这些插件在服务器中的位置，命令：<code>whereis jdk</code>，<br><img src="D:\project\kaiFa\Blog\source_posts\assets\82d21d77cb504b3d9c262ee0adf53a94.png" alt="82d21d77cb504b3d9c262ee0adf53a94.png"><br>填入<code>JAVA_HOME</code>里。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1bf54c35fbcb4a8caeeec924ba7bd090.png" alt="1bf54c35fbcb4a8caeeec924ba7bd090.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> springcloud </tag>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找！！！！</title>
      <link href="/post/45d365e2.html"/>
      <url>/post/45d365e2.html</url>
      
        <content type="html"><![CDATA[<p>比如有个从小到大排列的数组：**[5, 7, 7, 8, 8, 10]**</p><h1 id="找到第一个≥8的数的位置"><a href="#找到第一个≥8的数的位置" class="headerlink" title="找到第一个≥8的数的位置"></a>找到第一个≥8的数的位置</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\30528de45631471daabc5f517cf8a41d.png" alt="30528de45631471daabc5f517cf8a41d.png"><br>左闭右闭：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">int</span> target = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r) &#123; <span class="comment">// [l, r]</span></span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[m] &lt; target) &#123; <span class="comment">// [m + 1, r]</span></span><br><span class="line">l = m + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123; <span class="comment">// [l, m - 1]</span></span><br><span class="line">r = m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l; <span class="comment">// r + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左闭右开：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &lt; target) &#123; <span class="comment">// [m + 1, r)</span></span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// [l, m)</span></span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l; <span class="comment">// r</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左开右开：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lower_bound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">-1</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r) &#123; <span class="comment">// (l, r)</span></span><br><span class="line">        <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &lt; target) &#123; <span class="comment">// (m, r)</span></span><br><span class="line">            l = m;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// (l, m)</span></span><br><span class="line">            r = m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r; <span class="comment">// l + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找到第一个＞8的数的位置"><a href="#找到第一个＞8的数的位置" class="headerlink" title="找到第一个＞8的数的位置"></a>找到第一个＞8的数的位置</h1><p>转化成：找到第一个 ≥ x + 1的数</p><h1 id="找到第一个＜8的数的位置"><a href="#找到第一个＜8的数的位置" class="headerlink" title="找到第一个＜8的数的位置"></a>找到第一个＜8的数的位置</h1><p>转化成：找到第一个 ≥ x 的左边那个数</p><h1 id="找到第一个-≤-8的数的位置"><a href="#找到第一个-≤-8的数的位置" class="headerlink" title="找到第一个 ≤ 8的数的位置"></a>找到第一个 ≤ 8的数的位置</h1><p>转化成：找到第一个＞x的左边那个数</p>]]></content>
      
      
      <categories>
          
          <category> 二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【搜索文章】：搜索（es）+ 搜索记录（mongodb）+ 搜索联想词</title>
      <link href="/post/84848620.html"/>
      <url>/post/84848620.html</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>用户输入关键字时，可以检索出结果，<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ee0c455b29834a0dac6a1f3bca7f5f13.png" alt="ee0c455b29834a0dac6a1f3bca7f5f13.png"><br><img src="D:\project\kaiFa\Blog\source_posts\assets\c083ab7ec07b45f29138c03c84473962.png" alt="c083ab7ec07b45f29138c03c84473962.png"><br><img src="D:\project\kaiFa\Blog\source_posts\assets\7af43012fc05432eb5b85eeba9507993.png" alt="7af43012fc05432eb5b85eeba9507993.png"></p><h1 id="ElasticSearch（搜索）"><a href="#ElasticSearch（搜索）" class="headerlink" title="ElasticSearch（搜索）"></a>ElasticSearch（搜索）</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>使用docker安装es，配置ik分词器</li><li>重新建一个search模块，用来写搜索微服务的业务代码</li><li>导入es的依赖</li><li>配置RestHighLevelClient</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;elasticsearch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticSearchConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">client</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(host);</span><br><span class="line">        System.out.println(port);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HttpHost</span>(</span><br><span class="line">                        host,</span><br><span class="line">                        port,</span><br><span class="line">                        <span class="string">&quot;http&quot;</span></span><br><span class="line">                )</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">autoconfigure:</span></span><br><span class="line">    <span class="attr">exclude:</span> <span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span></span><br><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9200</span></span><br></pre></td></tr></table></figure><ol start="5"><li>初始化索引库数据（项目上线之前需要批量导入）：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApArticleMapper apArticleMapper;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 注意：数据量的导入，如果数据量过大，需要分页导入</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">// 1. 查询所有符合条件的文章数据</span></span><br><span class="line">      List&lt;SearchArticleVo&gt; searchArticleVos = apArticleMapper.loadArticleList();</span><br><span class="line">      <span class="comment">// 2. 批量导入es索引库中</span></span><br><span class="line">      <span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>(<span class="string">&quot;app_info_article&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (SearchArticleVo searchArticleVo : searchArticleVos) &#123;</span><br><span class="line">          <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>().id(searchArticleVo.getId().toString())</span><br><span class="line">                  .source(JSON.toJSONString(searchArticleVo), XContentType.JSON);</span><br><span class="line">          bulkRequest.add(indexRequest); <span class="comment">// 批量添加数据</span></span><br><span class="line">      &#125;</span><br><span class="line">      restHighLevelClient.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="文章搜索"><a href="#文章搜索" class="headerlink" title="文章搜索"></a>文章搜索</h2><ol><li>单一条件查询：直接放入SearchSourceBuilder<br>如果查询逻辑简单，只有一个独立条件，可以直接将条件放入SearchSourceBuilder的query方法中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">sourceBuilder.query(QueryBuilders.termQuery(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;active&quot;</span>));</span><br></pre></td></tr></table></figure><ol start="2"><li>组合多个条件：必须使用BoolQueryBuilder，当需要组合多个条件（如 AND&#x2F;OR&#x2F;NOT 逻辑）时，必须显式使用 BoolQueryBuilder。</li></ol><table><thead><tr><th>类型</th><th>作用</th><th>是否影响评分</th><th>是否可缓存</th></tr></thead><tbody><tr><td>must</td><td>子条件，必须满足，类似逻辑 AND</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>filter</td><td>子条件 必须满足，但不参与相关性评分</td><td>❌ 否</td><td>✅ 是（可缓存）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery()</span><br><span class="line">    .must(QueryBuilders.termQuery(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;active&quot;</span>)) <span class="comment">// AND 条件</span></span><br><span class="line">    .must(QueryBuilders.rangeQuery(<span class="string">&quot;age&quot;</span>).gte(<span class="number">18</span>)) <span class="comment">// 另一个 AND 条件</span></span><br><span class="line">    .should(QueryBuilders.termQuery(<span class="string">&quot;tag&quot;</span>, <span class="string">&quot;urgent&quot;</span>)) <span class="comment">// OR 条件</span></span><br><span class="line">    .mustNot(QueryBuilders.termQuery(<span class="string">&quot;deleted&quot;</span>, <span class="literal">true</span>)); <span class="comment">// NOT 条件</span></span><br><span class="line"></span><br><span class="line"><span class="type">SearchSourceBuilder</span> <span class="variable">sourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">sourceBuilder.query(boolQuery);</span><br></pre></td></tr></table></figure><blockquote><p>虽然技术上可以将所有查询都包装成 BoolQuery，但直接使用单一条件更简洁</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RestHighLevelClient restHighLevelClient;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">search</span><span class="params">(UserSearchDto dto)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 检查参数</span></span><br><span class="line">    <span class="keyword">if</span>(dto == <span class="literal">null</span> || StringUtils.isBlank(dto.getSearchWords())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 设置查询条件</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">searchRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;app_info_article&quot;</span>);</span><br><span class="line">    <span class="comment">// searchSourceBuilder主要是对查询结果处理（分页、排序、高亮），不参与查询逻辑的构建</span></span><br><span class="line">    <span class="type">SearchSourceBuilder</span> <span class="variable">searchSourceBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchSourceBuilder</span>();</span><br><span class="line">    <span class="comment">// boolQuery主要是构建复杂的查询逻辑</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery(); <span class="comment">// 布尔查询</span></span><br><span class="line">    <span class="comment">// 2-1. 关键词分词后查询</span></span><br><span class="line">    <span class="type">QueryStringQueryBuilder</span> <span class="variable">queryStringQueryBuilder</span> <span class="operator">=</span> QueryBuilders.queryStringQuery(dto.getSearchWords()) <span class="comment">// 分词之后再查询</span></span><br><span class="line">            .field(<span class="string">&quot;title&quot;</span>) <span class="comment">// 对标题分词</span></span><br><span class="line">            .field(<span class="string">&quot;content&quot;</span>) <span class="comment">// 对内容分词</span></span><br><span class="line">            .defaultOperator(Operator.OR);<span class="comment">// 分词之后的条件(或的关系)</span></span><br><span class="line">    boolQuery.must(queryStringQueryBuilder); <span class="comment">// 2-1. 放入布尔查询中(must:参与算分)</span></span><br><span class="line">    <span class="comment">// 2-2. 查询小于minBehotTime的数据</span></span><br><span class="line">    <span class="type">RangeQueryBuilder</span> <span class="variable">rangeQueryBuilder</span> <span class="operator">=</span> QueryBuilders.rangeQuery(<span class="string">&quot;publishTime&quot;</span>) <span class="comment">// 发布时间</span></span><br><span class="line">            .lt(dto.getMinBehotTime().getTime());<span class="comment">// 小于minBehotTime</span></span><br><span class="line">    boolQuery.filter(rangeQueryBuilder); <span class="comment">// 2-2. 放入布尔查询中(filter:不参与算分)</span></span><br><span class="line">    <span class="comment">// 2-3. 分页查询</span></span><br><span class="line">    searchSourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">    searchSourceBuilder.size(dto.getPageSize());</span><br><span class="line">    <span class="comment">// 2-4. 按照发布时间倒叙查询</span></span><br><span class="line">    searchSourceBuilder.sort(<span class="string">&quot;publishTime&quot;</span>, SortOrder.DESC);</span><br><span class="line">    <span class="comment">// 2-5. 设置高亮</span></span><br><span class="line">    <span class="type">HighlightBuilder</span> <span class="variable">highlightBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>();</span><br><span class="line">    highlightBuilder.field(<span class="string">&quot;title&quot;</span>);<span class="comment">// 哪个字段高亮</span></span><br><span class="line">    highlightBuilder.preTags(<span class="string">&quot;&lt;font style=&#x27;color: red; font-size: inherit;&#x27;&gt;&quot;</span>); <span class="comment">// 高亮字段前缀</span></span><br><span class="line">    highlightBuilder.postTags(<span class="string">&quot;&lt;/font&gt;&quot;</span>); <span class="comment">// 高亮字段的后缀</span></span><br><span class="line">    searchSourceBuilder.highlighter(highlightBuilder);</span><br><span class="line">    searchSourceBuilder.query(boolQuery);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">searchResponse</span> <span class="operator">=</span> restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3. 结果封装返回</span></span><br><span class="line">    SearchHit[] hits = searchResponse.getHits().getHits();</span><br><span class="line">    List&lt;Map&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> JSON.parseObject(json, Map.class);</span><br><span class="line">        <span class="comment">// 处理高亮</span></span><br><span class="line">        <span class="keyword">if</span>(hit.getHighlightFields() != <span class="literal">null</span> &amp;&amp; hit.getHighlightFields().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Text[] titles = hit.getHighlightFields().get(<span class="string">&quot;title&quot;</span>).getFragments();</span><br><span class="line">            <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> StringUtils.join(titles); <span class="comment">// 高亮之后的title</span></span><br><span class="line">            map.put(<span class="string">&quot;h_title&quot;</span>, title); <span class="comment">// 设置高亮标题</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(<span class="string">&quot;h_title&quot;</span>, map.get(<span class="string">&quot;title&quot;</span>)); <span class="comment">// 没有设置高亮，就把原本的标题放入h_title中</span></span><br><span class="line">        &#125;</span><br><span class="line">        list.add(map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ResponseResult.okResult(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增文章创建索引"><a href="#新增文章创建索引" class="headerlink" title="新增文章创建索引"></a>新增文章创建索引</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\1e09ed1db8a94619a815d21d0217d189.png" alt="1e09ed1db8a94619a815d21d0217d189.png"><br>思路：文章审核成功后使用kafka发送消息，文章微服务是消息的生产者；搜索微服务接收到消息后，添加数据到索引库，搜索微服务是消息的消费者。</p><ol><li>文章微服务（生产者）</li></ol><p>到yml中配置生产者：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line"><span class="attr">bootstrap-servers:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:9092</span></span><br><span class="line"><span class="attr">producer:</span></span><br><span class="line">  <span class="comment"># 重试次数</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">10</span></span><br><span class="line">  <span class="comment"># key、value的序列化器</span></span><br><span class="line">  <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">  <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br></pre></td></tr></table></figure><p>往消息队列中发送消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息，创建索引</span></span><br><span class="line"><span class="type">SearchArticleVo</span> <span class="variable">searchArticleVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchArticleVo</span>();</span><br><span class="line">BeanUtils.copyProperties(article, searchArticleVo);</span><br><span class="line">searchArticleVo.setContent(dto.getContent());</span><br><span class="line">searchArticleVo.setStaticUrl(path);</span><br><span class="line">kafkaTemplate.send(ArticleConstants.ARTICLE_ES_SYNC_TOPIC, JSON.toJSONString(searchArticleVo));</span><br></pre></td></tr></table></figure><ol start="2"><li>搜索微服务（消费者）</li></ol><p>到yml中配置消费者：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:9092</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="comment"># 消费组</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">      <span class="comment"># key、value的反序列化器</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br></pre></td></tr></table></figure><h1 id="mongodb（搜索记录）"><a href="#mongodb（搜索记录）" class="headerlink" title="mongodb（搜索记录）"></a>mongodb（搜索记录）</h1><p>需要给每个用户保存一份搜索记录，数据量大，要求加载速度快，通常这样的数据存储到mongodb更合适，不建议存到mysql中。</p><ol><li>mongodb：<ul><li>支持分片，适合存储用户搜索日志这种持续写入的场景</li><li>基于磁盘存储，成本低</li></ul></li><li>mysql：<ul><li>对高频写入（如每秒数千次插入）的支持较弱</li><li>搜索记录通常是半结构化或非结构化数据，需频繁变更表结构来适应新字段</li></ul></li><li>redis：<ul><li>redis基于内存的，内存成本高，适合存储热数据（如缓存）</li><li>Redis 的 RDB 快照和 AOF 日志是异步持久化机制，在宕机时可能丢失部分数据</li><li>数据量过大时，从磁盘加载备份到内存的恢复过程耗时较长</li></ul></li></ol><blockquote><ul><li>MongoDB：适合作为主存储，满足海量数据、灵活查询、低成本持久化的核心需求。</li><li>Redis：适合作为缓存层，加速近期数据的访问，但无法替代 MongoDB 的长期存储角色。</li><li>MySQL：不适合高频写入和非结构化日志场景。</li></ul></blockquote><hr><h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1-配置环境"><a href="#1-配置环境" class="headerlink" title="1. 配置环境"></a>1. 配置环境</h3><p>使用docker安装mongodb：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -di \</span><br><span class="line">--name mongo-service \</span><br><span class="line">--restart=always \</span><br><span class="line">-p 27017:27017 \</span><br><span class="line">-v ~/data/mongodata:/data \</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure><h3 id="2-springboot集成mongodb"><a href="#2-springboot集成mongodb" class="headerlink" title="2. springboot集成mongodb"></a>2. springboot集成mongodb</h3><ol><li>添加mongodb依赖：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置mongodb：</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line">      <span class="attr">database:</span> <span class="string">leadnews-history</span></span><br></pre></td></tr></table></figure><ol start="3"><li>映射</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(&quot;ap_associate_words&quot;)</span> <span class="comment">// 映射哪个集合【mongodb表名】</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApAssociateWords</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联想词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String associateWords;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date createdTime;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>核心方法</li></ol><ul><li>保存或修改：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApAssociateWords</span> <span class="variable">apAssociateWords</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApAssociateWords</span>();</span><br><span class="line">    apAssociateWords.setAssociateWords(<span class="string">&quot;黑马头条&quot;</span>);</span><br><span class="line">    apAssociateWords.setCreatedTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    mongoTemplate.save(apAssociateWords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>查询一个对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveFindOne</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApAssociateWords</span> <span class="variable">apAssociateWords</span> <span class="operator">=</span> mongoTemplate.findById(<span class="string">&quot;67a330c35faec30826dcbe8e&quot;</span>, ApAssociateWords.class);</span><br><span class="line">    System.out.println(apAssociateWords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多条件查询</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;associateWords&quot;</span>).is(<span class="string">&quot;黑马头条&quot;</span>))</span><br><span class="line">            .with(Sort.by(Sort.Direction.DESC,<span class="string">&quot;createdTime&quot;</span>));</span><br><span class="line">    List&lt;ApAssociateWords&gt; apAssociateWordsList = mongoTemplate.find(query, ApAssociateWords.class);</span><br><span class="line">    System.out.println(apAssociateWordsList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDel</span><span class="params">()</span>&#123;</span><br><span class="line">    mongoTemplate.remove(Query.query(Criteria.where(<span class="string">&quot;associateWords&quot;</span>).is(<span class="string">&quot;黑马头条&quot;</span>)),ApAssociateWords.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="保存搜索记录"><a href="#保存搜索记录" class="headerlink" title="保存搜索记录"></a>保存搜索记录</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\4f4e55d94e6c4d40976c242fdb2934d3.png" alt="4f4e55d94e6c4d40976c242fdb2934d3.png"></p><blockquote><p>用户搜索后，为了让用户能更快的得到搜索的结果，异步发送请求记录关键字。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\c42987c8d6384195bb3e03f1230f1741.png" alt="c42987c8d6384195bb3e03f1230f1741.png"></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line"><span class="comment">// 保存搜索记录</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String keyword, Integer userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询当前用户搜索关键字</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(userId)</span><br><span class="line">                                        .and(<span class="string">&quot;keyword&quot;</span>).is(keyword));</span><br><span class="line">    <span class="type">ApUserSearch</span> <span class="variable">apUserSearch</span> <span class="operator">=</span> mongoTemplate.findOne(query, ApUserSearch.class);</span><br><span class="line">    <span class="comment">// 2. 存在 - 更新时间</span></span><br><span class="line">    <span class="keyword">if</span>(apUserSearch != <span class="literal">null</span>) &#123;</span><br><span class="line">        apUserSearch.setCreatedTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        mongoTemplate.save(apUserSearch); <span class="comment">// 有id-修改、没有id-新增</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 不存在 - 判断该用户的当前历史总数量是否 &gt; 10</span></span><br><span class="line">    apUserSearch = <span class="keyword">new</span> <span class="title class_">ApUserSearch</span>();</span><br><span class="line">    apUserSearch.setUserId(userId);</span><br><span class="line">    apUserSearch.setKeyword(keyword);</span><br><span class="line">    apUserSearch.setCreatedTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="comment">// 4. 当前用户的当前历史总数量 &lt; 10 - 直接保存</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">query1</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(userId));</span><br><span class="line">    query1.with(Sort.by(Sort.Direction.DESC, <span class="string">&quot;createdTime&quot;</span>)); <span class="comment">// 按照时间倒序排列</span></span><br><span class="line">    List&lt;ApUserSearch&gt; apUserSearches = mongoTemplate.find(query1, ApUserSearch.class);</span><br><span class="line">    <span class="keyword">if</span>(apUserSearches == <span class="literal">null</span> || apUserSearches.size() &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        mongoTemplate.save(apUserSearch); <span class="comment">// 直接保存</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 5. 当前用户的当前历史总数量 &gt;= 10 - 替换最后一条记录</span></span><br><span class="line">        <span class="type">ApUserSearch</span> <span class="variable">lastUserSearch</span> <span class="operator">=</span> apUserSearches.get(apUserSearches.size() - <span class="number">1</span>);</span><br><span class="line">        mongoTemplate.findAndReplace(Query.query(Criteria.where(<span class="string">&quot;id&quot;</span>).is(lastUserSearch.getId())), apUserSearch); <span class="comment">// 修改最后一条记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在之前写的文章搜索的业务代码中，异步调用“保存搜索记录”的方法。<br>其中：userId通过<code>app网关的过滤器</code>拦截到前端发过来的userId，并把userId放到请求头中传给搜索微服务，<code>搜索微服务的拦截器</code>获取app网关发来的userId，存到ThreadLocal中。<br>注意：由于是异步调用save方法，是又开了一个线程，此时这个线程是没办法从ThreadLocal中获取到userId，只能通过主线程传过来。</p></blockquote><h2 id="查询搜索历史"><a href="#查询搜索历史" class="headerlink" title="查询搜索历史"></a>查询搜索历史</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">findUserSearch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前用户</span></span><br><span class="line">        <span class="type">ApUser</span> <span class="variable">user</span> <span class="operator">=</span> AppThreadLocalUtil.getUser();</span><br><span class="line">        <span class="comment">// 根据用户查询当前数据（按照时间倒叙）</span></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ApUserSearch&gt; list = mongoTemplate.find(Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(user.getId()))</span><br><span class="line">                                                .with(Sort.by(Sort.Direction.DESC, <span class="string">&quot;createdTime&quot;</span>)), ApUserSearch.class);</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.okResult(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据用户id和当前某个用户的id查找记录，并按照创建时间降序排列。</p></blockquote><h2 id="删除某一个历史记录"><a href="#删除某一个历史记录" class="headerlink" title="删除某一个历史记录"></a>删除某一个历史记录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">delUserSearch</span><span class="params">(HistorySearchDto dto)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (dto.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前用户</span></span><br><span class="line">    <span class="type">ApUser</span> <span class="variable">user</span> <span class="operator">=</span> AppThreadLocalUtil.getUser();</span><br><span class="line">    <span class="comment">// 判断是否登录</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    mongoTemplate.remove(Query.query(Criteria.where(<span class="string">&quot;userId&quot;</span>).is(user.getId())</span><br><span class="line">                                            .and(<span class="string">&quot;id&quot;</span>).is(dto.getId())), ApUserSearch.class);</span><br><span class="line">    <span class="keyword">return</span> ResponseResult.okResult(AppHttpCodeEnum.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>根据用户id和当前某个搜索记录的id进行删除</p></blockquote><h1 id="搜索联想词"><a href="#搜索联想词" class="headerlink" title="搜索联想词"></a>搜索联想词</h1><h2 id="搜索词（数据来源）"><a href="#搜索词（数据来源）" class="headerlink" title="搜索词（数据来源）"></a>搜索词（数据来源）</h2><p>使用网上搜索频率较高的一些词：</p><ol><li>自己维护联想词：通过分析用户搜索频率较高的词，按照排名作为搜索词</li><li>第三方获取：<a href="https://www.5118.com/ciku/index">5118</a>…</li></ol><h2 id="导入联想词"><a href="#导入联想词" class="headerlink" title="导入联想词"></a>导入联想词</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\e1b5de45335d4987ab59025fbed1288c.png" alt="e1b5de45335d4987ab59025fbed1288c.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>正则表达式：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\488c069a0ae94adea4bdc16960f1bc9d.png" alt="488c069a0ae94adea4bdc16960f1bc9d.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 搜索联想词</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ResponseResult <span class="title function_">search</span><span class="params">(UserSearchDto dto)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 检查参数</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(dto.getSearchWords())) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 分页检查（最多只能查询20条）</span></span><br><span class="line">    <span class="keyword">if</span>(dto.getPageSize() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">        dto.setPageSize(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 执行模糊查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">regexStr</span> <span class="operator">=</span> <span class="string">&quot;.*?\\&quot;</span> + dto.getSearchWords() + <span class="string">&quot;.*&quot;</span>;</span><br><span class="line">    <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> Query.query(Criteria.where(<span class="string">&quot;associateWords&quot;</span>)</span><br><span class="line">                        .regex(regexStr))</span><br><span class="line">                        .limit(dto.getPageSize());</span><br><span class="line">    List&lt;ApAssociateWords&gt; list = mongoTemplate.find(query, ApAssociateWords.class);</span><br><span class="line">    <span class="keyword">return</span> ResponseResult.okResult(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实搜索联想词，就是提前先把词库导入到mongodb表中，用户在输入的时候，就会对这个表进行模糊查询，遇到符合条件的就立马匹配。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> elasticsearch </tag>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【热点文章-定时计算】分布式任务调度框架xxl-job</title>
      <link href="/post/fa1dd5d9.html"/>
      <url>/post/fa1dd5d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h1><p>在分布式架构下，一个服务会部署多个实例来运行业务；如果在这种分布式系统环境下运行任务调度，称为分布式任务调度。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1b9e288ea4a640adb8753d959b2e09c9.png" alt="1b9e288ea4a640adb8753d959b2e09c9.png"><br>分布式任务调度框架：<a href="https://www.xuxueli.com/xxl-job/">xxl-job</a></p><h1 id="xxl-job环境搭建"><a href="#xxl-job环境搭建" class="headerlink" title="xxl-job环境搭建"></a>xxl-job环境搭建</h1><h2 id="本机"><a href="#本机" class="headerlink" title="本机"></a>本机</h2><p>仓库源码：<a href="http://gitee.com/xuxueli0323/xxl-job">xxl-job</a><br><img src="D:\project\kaiFa\Blog\source_posts\assets\3a97e7e7a8324307b69c7fc01456b02e.png" alt="3a97e7e7a8324307b69c7fc01456b02e.png"></p><ol><li>初始化调度数据库</li><li>修改数据库连接信息<br><img src="D:\project\kaiFa\Blog\source_posts\assets\615a6a48782e4dc79fecbbf8b646ad04.png" alt="615a6a48782e4dc79fecbbf8b646ad04.png"></li></ol><blockquote><p>此时启动xxl-job-admin项目，在浏览器输入<code>http://localhost:8080/xxl-job-admin</code>即可看到调度中心页面</p></blockquote><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2><p>docker安装xxl-job</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://192.168.140.102:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 \</span><br><span class="line">--spring.datasource.username=root \</span><br><span class="line">--spring.datasource.password=123&quot; \</span><br><span class="line">-p 8888:8080 -v /tmp:/data/applogs \</span><br><span class="line">--name xxl-job-admin \</span><br><span class="line">--restart=always  \</span><br><span class="line">xuxueli/xxl-job-admin:2.3.0</span><br></pre></td></tr></table></figure><blockquote><p>此时在浏览器输入<code>http://192.168.140.102:8888/xxl-job-admin</code>即可看到调度中心页面</p></blockquote><h1 id="项目集成xxl-job"><a href="#项目集成xxl-job" class="headerlink" title="项目集成xxl-job"></a>项目集成xxl-job</h1><ol><li>导入xxl-job依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\64cad677848d451e808468bc0c2bb4e4.png" alt="64cad677848d451e808468bc0c2bb4e4.png"></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://192.168.140.102:8888/xxljob-admin</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">xxl-job-executor-sample</span> <span class="comment"># 去“任务调度中心-执行器管理”里找</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br></pre></td></tr></table></figure><ol start="3"><li>任务代码<br><img src="D:\project\kaiFa\Blog\source_posts\assets\b637cbc732e54579b113eb1f16660532.png" alt="b637cbc732e54579b113eb1f16660532.png"></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span> <span class="comment">// 去任务调度中心里查</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloJob</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;简单任务执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="任务详解"><a href="#任务详解" class="headerlink" title="任务详解"></a>任务详解</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\2be8cff18c93499ea2aa0de40cd1ab1a.png" alt="2be8cff18c93499ea2aa0de40cd1ab1a.png"></p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>任务绑定的执行器，任务触发调度时，会自动发现注册成功的执行器，实现任务自动发现功能。执行器也可以方便的进行任务分组，每个任务必须绑定一个执行器。</p><h2 id="报警邮件"><a href="#报警邮件" class="headerlink" title="报警邮件"></a>报警邮件</h2><p>任务调度失败时邮件通知的邮箱地址</p><h2 id="调度配置"><a href="#调度配置" class="headerlink" title="调度配置"></a>调度配置</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\50d0ee72b2aa4699ad89f5aeba0e550a.png" alt="50d0ee72b2aa4699ad89f5aeba0e550a.png"></p><h2 id="任务配置"><a href="#任务配置" class="headerlink" title="任务配置"></a>任务配置</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\092275beee7b40f382fdb6856156c3c0.png" alt="092275beee7b40f382fdb6856156c3c0.png"></p><ol><li>运行模式：BEAN模式（任务以JobHandler方式维护在执行器端）</li><li>JobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值</li></ol><h2 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\d2ef130a21b24fd5831b1321bede1670.png" alt="d2ef130a21b24fd5831b1321bede1670.png"></p><ul><li><p>FIRST（第一个）：固定选择第一个机器；</p></li><li><p>LAST（最后一个）：固定选择最后一个机器；</p></li><li><p><strong>ROUND（轮询）</strong>：每个微服务轮询的去执行任务</p></li><li><p>RANDOM（随机）：随机选择在线的机器；</p></li><li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。</p></li><li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；</p></li><li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举；</p></li><li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；</p></li><li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；</p></li><li><p>**SHARDING_BROADCAST(分片广播)**：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；</p></li></ul><h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><p>任务路由策略选择“分片广播”的情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务。</p><p>在同一个时间点，如果需要同时执行大量的任务，肯定是需要用到集群的，此时可以给每台服务器分配多个任务。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\45189dbd63b740a28c31ae30de04fa5f.png" alt="45189dbd63b740a28c31ae30de04fa5f.png"></p><blockquote><p>假设每秒10000请求，<br>【轮询方式】：实例A在第一秒接受了全部10000个任务并处理，而实例B空闲，第二秒则是实例B接受并处理10000个任务，A空闲<br>【分片广播方式】：实例A和实例B两个服务同时执行10000个任务</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 分片的参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex(); <span class="comment">// 当前某个分片</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal(); <span class="comment">// 总分片数</span></span><br><span class="line">        <span class="comment">// 业务逻辑</span></span><br><span class="line">        List&lt;Integer&gt; list = getList();</span><br><span class="line">        <span class="keyword">for</span>(Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % shardTotal == shardIndex) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前第&quot;</span>+shardIndex+<span class="string">&quot;分片执行了，任务项是：&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用：热点文章定时计算"><a href="#应用：热点文章定时计算" class="headerlink" title="应用：热点文章定时计算"></a>应用：热点文章定时计算</h1><p>spring传统的定时任务@Scheduled，但是存在一些问题：</p><ol><li>集群任务的重复执行问题</li><li>cron表达式定义在代码中，修改不方便</li><li>定时任务失败了，无法重试，也没有统计</li><li>如果任务量过大，不能有效地分片执行</li></ol><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\4a7ae49e31e841628392f11dd948a393.png" alt="4a7ae49e31e841628392f11dd948a393.png"></p><h2 id="计算热点文章分值业务代码"><a href="#计算热点文章分值业务代码" class="headerlink" title="计算热点文章分值业务代码"></a>计算热点文章分值业务代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算热点文章</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">computeHotArticle</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询前五天的文章数据</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">dayParam</span> <span class="operator">=</span> DateTime.now().minusDays(<span class="number">5</span>).toDate();</span><br><span class="line">    List&lt;ApArticle&gt; articleList = articleMapper.findArticleListByLast5days(dayParam);</span><br><span class="line">    <span class="comment">// 2. 计算文章的分值</span></span><br><span class="line">    List&lt;HotArticleVo&gt; hotArticleVoList = computeArticleScore(articleList);</span><br><span class="line">    <span class="comment">// 3. 为每个频道缓存30条分值较高的文章</span></span><br><span class="line">    cacheTagToRedis(hotArticleVoList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算文章分值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> articleList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HotArticleVo&gt; <span class="title function_">computeArticleScore</span><span class="params">(List&lt;ApArticle&gt; articleList)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (articleList == <span class="literal">null</span> || articleList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;HotArticleVo&gt; hotArticleVoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ApArticle apArticle : articleList) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> computeScore(apArticle);</span><br><span class="line">        <span class="type">HotArticleVo</span> <span class="variable">hotArticleVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotArticleVo</span>();</span><br><span class="line">        BeanUtils.copyProperties(apArticle, hotArticleVo);</span><br><span class="line">        hotArticleVo.setScore(score);</span><br><span class="line">        hotArticleVoList.add(hotArticleVo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hotArticleVoList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算文章的具体分值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apArticle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">computeScore</span><span class="params">(ApArticle apArticle)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">scere</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getLikes() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getLikes() * ArticleConstants.HOT_ARTICLE_LIKE_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getViews() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getViews();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getComment() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getComment() * ArticleConstants.HOT_ARTICLE_COMMENT_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getCollection() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getCollection() * ArticleConstants.HOT_ARTICLE_COLLECTION_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scere;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存到redis中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hotArticleVoList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cacheTagToRedis</span><span class="params">(List&lt;HotArticleVo&gt; hotArticleVoList)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 为每个频道缓存30条分值较高的文章</span></span><br><span class="line">    <span class="type">ResponseResult</span> <span class="variable">responseResult</span> <span class="operator">=</span> wemediaClient.getChannels();</span><br><span class="line">    <span class="keyword">if</span>(responseResult.getCode().equals(<span class="number">200</span>)) &#123;</span><br><span class="line">        <span class="comment">// List&lt;WmChannel&gt; wmChannels = (List&lt;WmChannel&gt;)responseResult.getData();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">channelJson</span> <span class="operator">=</span> JSON.toJSONString(responseResult.getData());</span><br><span class="line">        List&lt;WmChannel&gt; wmChannels = JSON.parseArray(channelJson, WmChannel.class);</span><br><span class="line">        <span class="comment">// 检索每个频道的文章</span></span><br><span class="line">        <span class="keyword">if</span>(wmChannels != <span class="literal">null</span> &amp;&amp; wmChannels.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(WmChannel wmChannel : wmChannels) &#123;</span><br><span class="line">                <span class="comment">// 当前频道的数据，降序排列，最多30条</span></span><br><span class="line">                List&lt;HotArticleVo&gt; list = hotArticleVoList.stream()</span><br><span class="line">                        .filter(x -&gt; wmChannel.getId() == x.getChannelId())</span><br><span class="line">                        .limit(<span class="number">30</span>) <span class="comment">// 最多30条</span></span><br><span class="line">                        .sorted(Comparator.comparing(HotArticleVo::getScore).reversed())<span class="comment">// 给文章进行排序</span></span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">                cacheService.set(ArticleConstants.HOT_ARTICLE_FIRST_PAGE + wmChannel.getId(), JSON.toJSONString(list));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 设置推荐的数据</span></span><br><span class="line">    List&lt;HotArticleVo&gt; list = hotArticleVoList.stream()</span><br><span class="line">                        .limit(<span class="number">30</span>) <span class="comment">// 最多30条</span></span><br><span class="line">                        .sorted(Comparator.comparing(HotArticleVo::getScore).reversed())<span class="comment">// 给文章进行排序</span></span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">    cacheService.set(ArticleConstants.HOT_ARTICLE_FIRST_PAGE + ArticleConstants.DEFAULT_TAG, JSON.toJSONString(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置定时任务（凌晨两点执行一次）"><a href="#设置定时任务（凌晨两点执行一次）" class="headerlink" title="设置定时任务（凌晨两点执行一次）"></a>设置定时任务（凌晨两点执行一次）</h2><ol><li>新增执行器<br><img src="D:\project\kaiFa\Blog\source_posts\assets\70c94d0dea774b75ae5b36cc2263e0a1.png" alt="70c94d0dea774b75ae5b36cc2263e0a1.png"></li><li>新增任务<br><img src="D:\project\kaiFa\Blog\source_posts\assets\405057c1cf6f48349554054187b71db5.png" alt="405057c1cf6f48349554054187b71db5.png"></li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>添加配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://192.168.140.102:8888/xxl-job-admin</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">leadnews-hotarticle-executor</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br></pre></td></tr></table></figure><ol start="5"><li>创建任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputeHotArticleJob</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HotArticleService hotArticleService;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;computeHotArticleJob&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;热文章分值计算调度任务开始执行&quot;</span>);</span><br><span class="line">        hotArticleService.computeHotArticle(); <span class="comment">// 调用“计算热点文章分值业务代码”</span></span><br><span class="line">        log.info(<span class="string">&quot;热文章分值计算调度任务执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只要在查询文章列表的时候，先去判断redis中是否有数据，如果有数据，直接从redis中获取。（redis中存储的数据就是按照文章的热点分值排序后的）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> springcloud </tag>
            
            <tag> xxl-job </tag>
            
            <tag> 分布式任务调度框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【热点文章-实时计算】kafkaStream</title>
      <link href="/post/16ac59c1.html"/>
      <url>/post/16ac59c1.html</url>
      
        <content type="html"><![CDATA[<h1 id="实时计算与定时计算"><a href="#实时计算与定时计算" class="headerlink" title="实时计算与定时计算"></a>实时计算与定时计算</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\2e5f7107409941a085fc5b4ca11a9fda.png" alt="2e5f7107409941a085fc5b4ca11a9fda.png"></p><blockquote><p>定时计算是争对首页推荐文章更新<br>实时计算是争对点赞、收藏数的</p></blockquote><h1 id="流式计算应用场景"><a href="#流式计算应用场景" class="headerlink" title="流式计算应用场景"></a>流式计算应用场景</h1><ol><li>日志分析：网站的用户访问日志进行实时的分析，计算访问量、用户画像、留存率等。实时的进行数据分析。</li><li>大屏看板统计：实时的查看网站注册数量，订单数量，购买数量，金额等。</li><li>公交的实时数据：可以随时更新公交车方位，计算多久到达站牌。</li><li>实时文章热度计算：头条类文章的分值计算，通过用户的行为实时更新文章的分值，分值越高的就越被推荐。</li></ol><h1 id="Kafka-Stream"><a href="#Kafka-Stream" class="headerlink" title="Kafka Stream"></a>Kafka Stream</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\496f64cb9a0246f5bfdb894b9cfd5813.png" alt="496f64cb9a0246f5bfdb894b9cfd5813.png"><br>源处理器（Source Processor）：消息的生产者（可以有多个），发送消息给Stream流式处理，Stream汇总数据后往下游发送给当前某个topic。</p><h2 id="案例-统计单词个数"><a href="#案例-统计单词个数" class="headerlink" title="案例. 统计单词个数"></a>案例. 统计单词个数</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\538706ff792a4781a7c722a6d541e343.png" alt="538706ff792a4781a7c722a6d541e343.png"></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写流式处理代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流式处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaStreamQuickStart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0. kafka的配置信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        prop.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.140.102:9092&quot;</span>); <span class="comment">// 连接地址</span></span><br><span class="line">        prop.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass()); <span class="comment">// key的序列化器</span></span><br><span class="line">        prop.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass()); <span class="comment">// value的序列化器</span></span><br><span class="line">        prop.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">&quot;streams-quickstart&quot;</span>); <span class="comment">// 应用名称</span></span><br><span class="line">        <span class="comment">// 0. stream构建器</span></span><br><span class="line">        <span class="type">StreamsBuilder</span> <span class="variable">streamsBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamsBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 流式计算</span></span><br><span class="line">        streamProcessor(streamsBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建KafkaStream对象</span></span><br><span class="line">        <span class="type">KafkaStreams</span> <span class="variable">streams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KafkaStreams</span>(streamsBuilder.build(), prop);</span><br><span class="line">        <span class="comment">// 2. 开启流失计算</span></span><br><span class="line">        streams.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流式计算</span></span><br><span class="line"><span class="comment">     * 消息的内容：hello kafka</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> streamsBuilder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">streamProcessor</span><span class="params">(StreamsBuilder streamsBuilder)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Kstream对象，同时指定从哪个topic中接收消息</span></span><br><span class="line">        KStream&lt;String, String&gt; stream = streamsBuilder.stream(<span class="string">&quot;xiaolin0333-topic-input&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理消息的value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stream.flatMapValues(value -&gt; Arrays.asList(value.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">                .groupBy((key, value) -&gt; value) <span class="comment">// 按照value分组聚合处理</span></span><br><span class="line">                .windowedBy(TimeWindows.of(Duration.ofSeconds(<span class="number">10</span>))) <span class="comment">// 时间窗口设置(每10s聚合一次)</span></span><br><span class="line">                .count() <span class="comment">// 聚合计算：统计单词的个数</span></span><br><span class="line">                .toStream() <span class="comment">// 转化为KStream对象</span></span><br><span class="line">                .map((key, value) -&gt; <span class="keyword">new</span> <span class="title class_">KeyValue</span>&lt;&gt;(key.key().toString(), value.toString())) <span class="comment">// 处理后结果key和value转化为字符串</span></span><br><span class="line">                .to(<span class="string">&quot;xiaolin0333-topic-out&quot;</span>); <span class="comment">// 发送消息</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试<ul><li>生产者在topic为xiaolin0333-topic-input中发送多条消息</li><li>消费者接收topic为xiaolin0333-topic-out</li></ul></li></ol><blockquote><p>通过流式计算，把生产者的多条消息汇总成一条发送到消费者中输出</p></blockquote><h2 id="springboot集成kafkaStream"><a href="#springboot集成kafkaStream" class="headerlink" title="springboot集成kafkaStream"></a>springboot集成kafkaStream</h2><ol><li>添加配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span> <span class="comment">// 开启KafkaStream</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;kafka&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaStreamConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_MESSAGE_SIZE</span> <span class="operator">=</span> <span class="number">16</span>* <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> String hosts;</span><br><span class="line">    <span class="keyword">private</span> String group;</span><br><span class="line">    <span class="meta">@Bean(name = KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME)</span></span><br><span class="line">    <span class="keyword">public</span> KafkaStreamsConfiguration <span class="title function_">defaultKafkaStreamsConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; props = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, hosts);</span><br><span class="line">        props.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="built_in">this</span>.getGroup()+<span class="string">&quot;_stream_aid&quot;</span>);</span><br><span class="line">        props.put(StreamsConfig.CLIENT_ID_CONFIG, <span class="built_in">this</span>.getGroup()+<span class="string">&quot;_stream_cid&quot;</span>);</span><br><span class="line">        props.put(StreamsConfig.RETRIES_CONFIG, <span class="number">10</span>);</span><br><span class="line">        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());</span><br><span class="line">        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KafkaStreamsConfiguration</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kafka:</span></span><br><span class="line">  <span class="attr">hosts:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:9092</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在配置类中定义方法：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KafkaStreamHelloListener</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KStream&lt;String, String&gt; <span class="title function_">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Kstream对象，同时指定从哪个topic中接收消息</span></span><br><span class="line">        KStream&lt;String, String&gt; stream = streamsBuilder.stream(<span class="string">&quot;xiaolin0333-topic-input&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理消息的value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        stream.flatMapValues(value -&gt; Arrays.asList(value.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">                .groupBy((key, value) -&gt; value) <span class="comment">// 按照value分组聚合处理</span></span><br><span class="line">                .windowedBy(TimeWindows.of(Duration.ofSeconds(<span class="number">10</span>))) <span class="comment">// 时间窗口设置(每10s聚合一次)</span></span><br><span class="line">                .count() <span class="comment">// 聚合计算：统计单词的个数</span></span><br><span class="line">                .toStream() <span class="comment">// 转化为KStream对象</span></span><br><span class="line">                .map((key, value) -&gt; <span class="keyword">new</span> <span class="title class_">KeyValue</span>&lt;&gt;(key.key().toString(), value.toString())) <span class="comment">// 处理后结果key和value转化为字符串</span></span><br><span class="line">                .to(<span class="string">&quot;xiaolin0333-topic-out&quot;</span>); <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="应用：热点文章实时计算"><a href="#应用：热点文章实时计算" class="headerlink" title="应用：热点文章实时计算"></a>应用：热点文章实时计算</h1><p>用户点赞、阅读、评论、收藏后，发送消息给kafkastream，更新数据库的数量，重新计算文章分值，更新对应频道的缓存数据以及推荐对应的热点数据。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3313c7a8c5ce4554a62c5cecbbc6a75e.png" alt="3313c7a8c5ce4554a62c5cecbbc6a75e.png"></p><ol><li>在点赞、阅读、收藏、评论的业务代码下发送消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="type">UpdateArticleMess</span> <span class="variable">mess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateArticleMess</span>();</span><br><span class="line">mess.setArticleId(dto.getArticleId());</span><br><span class="line">mess.setType(UpdateArticleMess.UpdateArticleType.VIEWS);</span><br><span class="line">mess.setAdd(<span class="number">1</span>);</span><br><span class="line">kafkaTemplate.send(HotArticleConstants.HOT_ARTICLE_SCORE_TOPIC, JSON.toJSONString(mess));</span><br></pre></td></tr></table></figure><ol start="2"><li>使用kafkaStream实时接收消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotArticleStreamHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> KStream&lt;String, String&gt; <span class="title function_">kStream</span><span class="params">(StreamsBuilder builder)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 接收消息</span></span><br><span class="line">        KStream&lt;String, String&gt; stream = builder.stream(HotArticleConstants.HOT_ARTICLE_SCORE_TOPIC);</span><br><span class="line">        <span class="comment">// 2. 聚合流式处理</span></span><br><span class="line">        stream.map((key, value) -&gt; &#123;</span><br><span class="line">            <span class="type">UpdateArticleMess</span> <span class="variable">mess</span> <span class="operator">=</span> JSON.parseObject(value, UpdateArticleMess.class);</span><br><span class="line">            <span class="comment">// 重置消息的key - 文章id、value - likes:1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyValue</span>&lt;&gt;(mess.getArticleId().toString(), mess.getType().name() + <span class="string">&quot;:&quot;</span> + mess.getAdd());</span><br><span class="line">        &#125;).groupBy((key, value) -&gt; key)</span><br><span class="line">                .windowedBy(TimeWindows.of(Duration.ofSeconds(<span class="number">10</span>)))  <span class="comment">// 时间窗口，按照文章id聚合</span></span><br><span class="line">                .aggregate(<span class="keyword">new</span> <span class="title class_">Initializer</span>&lt;String&gt;() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 初始方法，返回值是消息的value</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;COLLECTION:0,COMMENT:0,LIKES:0,VIEWS:0&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">new</span> <span class="title class_">Aggregator</span>&lt;String, String, String&gt;() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 真正的聚合操作，返回值是消息的value</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> aggValue</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(String key, String value, String aggValue)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(StringUtils.isBlank(value)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> aggValue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String[] aggAry = aggValue.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>, com = <span class="number">0</span>, like = <span class="number">0</span>, views = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 获得初始值，也是时间窗口内计算之后的值</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">for</span> (String agg : aggAry) &#123;</span><br><span class="line">                            String[] split = agg.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                            <span class="keyword">switch</span>(UpdateArticleMess.UpdateArticleType.valueOf(split[<span class="number">0</span>]))&#123;</span><br><span class="line">                                <span class="keyword">case</span> COLLECTION:</span><br><span class="line">                                    col = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> COMMENT:</span><br><span class="line">                                    com = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> LIKES:</span><br><span class="line">                                    like = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> VIEWS:</span><br><span class="line">                                    views = Integer.parseInt(split[<span class="number">1</span>]);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * 累加操作</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        String[] valAry = value.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                        <span class="keyword">switch</span>(UpdateArticleMess.UpdateArticleType.valueOf(valAry[<span class="number">0</span>]))&#123;</span><br><span class="line">                            <span class="keyword">case</span> COLLECTION:</span><br><span class="line">                                col += Integer.parseInt(valAry[<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> COMMENT:</span><br><span class="line">                                com += Integer.parseInt(valAry[<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> LIKES:</span><br><span class="line">                                like += Integer.parseInt(valAry[<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> VIEWS:</span><br><span class="line">                                views += Integer.parseInt(valAry[<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> String.format(<span class="string">&quot;COLLECTION:%d,COMMENT:%d,LIKES:%d,VIEWS:%d&quot;</span>, col, com, like, views);</span><br><span class="line">                        System.out.println(<span class="string">&quot;文章id&quot;</span> + key);</span><br><span class="line">                        System.out.println(<span class="string">&quot;当前时间窗口内消息的处理结果&quot;</span> + format);</span><br><span class="line">                        <span class="keyword">return</span> format;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, Materialized.as(<span class="string">&quot;hot-article-stream-count-001&quot;</span>))</span><br><span class="line">                .toStream()</span><br><span class="line">                .map((key, value)-&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KeyValue</span>&lt;&gt;(key.key().toString(), formatObj(key.key().toString(), value));</span><br><span class="line">                &#125;)</span><br><span class="line">                .to(HotArticleConstants.HOT_ARTICLE_INCR_HANDLE_TOPIC);</span><br><span class="line">        <span class="comment">// 3. 发送消息</span></span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 格式化消息的value数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> articleId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">formatObj</span><span class="params">(String articleId, String value)</span> &#123;</span><br><span class="line">        <span class="type">ArticleVisitStreamMess</span> <span class="variable">mess</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArticleVisitStreamMess</span>();</span><br><span class="line">        mess.setArticleId(Long.valueOf(articleId));</span><br><span class="line">        String[] valueArr = value.split(<span class="string">&quot;,&quot;</span>); <span class="comment">//  &quot;COLLECTION:0,COMMENT:0,LIKES:0,VIEWS:0&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (String val : valueArr) &#123;</span><br><span class="line">            String[] valAry = val.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">switch</span>(UpdateArticleMess.UpdateArticleType.valueOf(valAry[<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="keyword">case</span> COLLECTION:</span><br><span class="line">                    mess.setCollect(Integer.parseInt(valAry[<span class="number">1</span>]));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> COMMENT:</span><br><span class="line">                    mess.setComment(Integer.parseInt(valAry[<span class="number">1</span>]));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> LIKES:</span><br><span class="line">                    mess.setLike(Integer.parseInt(valAry[<span class="number">1</span>]));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> VIEWS:</span><br><span class="line">                    mess.setView(Integer.parseInt(valAry[<span class="number">1</span>]));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;聚合消息处理之后的结果：&#123;&#125;&quot;</span>, JSON.toJSONString(mess)) ;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(mess);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>添加listener监听器，重新计算文章的分值，并更新到数据库和缓存中<br>监听器代码：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArticleIncrHandleListener</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApArticleService apArticleService;</span><br><span class="line">    <span class="meta">@KafkaListener(topics = HotArticleConstants.HOT_ARTICLE_INCR_HANDLE_TOPIC)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(message))&#123;</span><br><span class="line">            <span class="type">ArticleVisitStreamMess</span> <span class="variable">articleVisitStreamMess</span> <span class="operator">=</span> JSON.parseObject(message, ArticleVisitStreamMess.class);</span><br><span class="line">            apArticleService.updateScore(articleVisitStreamMess);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新文章分值，同时更新缓存中热点文章数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">(ArticleVisitStreamMess mess)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新文章的阅读、点赞、收藏、评论的数量</span></span><br><span class="line">    <span class="type">ApArticle</span> <span class="variable">apArticle</span> <span class="operator">=</span> updateArticle(mess);</span><br><span class="line">    <span class="comment">// 2. 计算文章的分值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> computeScore(apArticle);</span><br><span class="line">    score *= <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 3. 替换当前文章对应频道的热点数据</span></span><br><span class="line">    replaceDataToRedis(ArticleConstants.HOT_ARTICLE_FIRST_PAGE + apArticle.getChannelId(), apArticle, score);</span><br><span class="line">    <span class="comment">// 4. 替换推荐对应的热点数据</span></span><br><span class="line">    replaceDataToRedis(ArticleConstants.HOT_ARTICLE_FIRST_PAGE + ArticleConstants.DEFAULT_TAG, apArticle, score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新文章行为数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> ApArticle <span class="title function_">updateArticle</span><span class="params">(ArticleVisitStreamMess mess)</span> &#123;</span><br><span class="line">    <span class="type">ApArticle</span> <span class="variable">article</span> <span class="operator">=</span> getById(mess.getArticleId());</span><br><span class="line">    article.setCollection((article.getCollection() == <span class="literal">null</span> ? <span class="number">0</span> : article.getCollection()) + mess.getCollect());</span><br><span class="line">    article.setComment((article.getComment() == <span class="literal">null</span> ? <span class="number">0</span> : article.getComment()) + mess.getComment());</span><br><span class="line">    article.setLikes((article.getLikes() == <span class="literal">null</span> ? <span class="number">0</span> : article.getLikes()) + mess.getLike());</span><br><span class="line">    article.setViews((article.getViews() == <span class="literal">null</span> ? <span class="number">0</span> : article.getViews()) + mess.getView());</span><br><span class="line">    updateById(article);</span><br><span class="line">    <span class="keyword">return</span> article;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算文章的具体分值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apArticle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">computeScore</span><span class="params">(ApArticle apArticle)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">scere</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getLikes() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getLikes() * ArticleConstants.HOT_ARTICLE_LIKE_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getViews() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getViews();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getComment() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getComment() * ArticleConstants.HOT_ARTICLE_COMMENT_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(apArticle.getCollection() != <span class="literal">null</span>)&#123;</span><br><span class="line">        scere += apArticle.getCollection() * ArticleConstants.HOT_ARTICLE_COLLECTION_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scere;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换数据并存入redis中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apArticle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> score</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceDataToRedis</span><span class="params">(String key, ApArticle apArticle, <span class="type">int</span> score)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">articleListStr</span> <span class="operator">=</span> cacheService.get(key);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(articleListStr)) &#123;</span><br><span class="line">        List&lt;HotArticleVo&gt; hotArticleVoList = JSON.parseArray(articleListStr, HotArticleVo.class);</span><br><span class="line">        <span class="comment">// 如果缓存中存在该文章，只要更新分值</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (HotArticleVo hotArticleVo : hotArticleVoList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hotArticleVo.getId().equals(apArticle.getId())) &#123;</span><br><span class="line">                hotArticleVo.setScore(score); <span class="comment">// 更新分值</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; hotArticleVoList.size() &gt;= <span class="number">30</span>) &#123;<span class="comment">// 如果缓存中不存在该文章</span></span><br><span class="line">            <span class="comment">// 查询缓存中分值最小的一条数据</span></span><br><span class="line">            hotArticleVoList = hotArticleVoList.stream().sorted(Comparator.comparing(HotArticleVo::getScore).reversed())</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">            <span class="type">HotArticleVo</span> <span class="variable">lastHot</span> <span class="operator">=</span> hotArticleVoList.get(hotArticleVoList.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果该文章分值 &gt; 缓存中数据 - 替换</span></span><br><span class="line">            <span class="keyword">if</span> (lastHot.getScore() &lt; score) &#123;</span><br><span class="line">                hotArticleVoList.remove(hotArticleVoList.size() - <span class="number">1</span>); <span class="comment">// 删除分值最小的数据</span></span><br><span class="line">                <span class="type">HotArticleVo</span> <span class="variable">hot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotArticleVo</span>();</span><br><span class="line">                BeanUtils.copyProperties(apArticle, hot);</span><br><span class="line">                hot.setScore(score);</span><br><span class="line">                hotArticleVoList.add(hot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新增</span></span><br><span class="line">            <span class="type">HotArticleVo</span> <span class="variable">hot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotArticleVo</span>();</span><br><span class="line">            BeanUtils.copyProperties(apArticle, hot);</span><br><span class="line">            hot.setScore(score);</span><br><span class="line">            hotArticleVoList.add(hot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存到redis</span></span><br><span class="line">        hotArticleVoList = hotArticleVoList.stream().sorted(Comparator.comparing(HotArticleVo::getScore).reversed())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        cacheService.set(key, JSON.toJSONString(hotArticleVoList));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> springcloud </tag>
            
            <tag> kafkaStream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目】黑马头条 - 自媒体端</title>
      <link href="/post/dbbefa8a.html"/>
      <url>/post/dbbefa8a.html</url>
      
        <content type="html"><![CDATA[<h1 id="图片上传"><a href="#图片上传" class="headerlink" title="图片上传"></a>图片上传</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\c18735c1b19a4b0591b3f57e9f16d92d.png" alt="c18735c1b19a4b0591b3f57e9f16d92d.png"></p><blockquote><ol><li>前端发请求后到达网关，网关会解析用户token后可以得到用户信息，把用户信息放入请求头中继续向自媒体微服务发请求，在自媒体用户微服务的拦截器中就可以获得用户信息。</li><li>在自媒体微服务会把图片存储到minio中，并在数据库中存储图片的路径</li></ol></blockquote><ol><li>网关传递userId给自媒体微服务：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span>, GlobalFilter &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1.获取request和response对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//2.判断是否是登录</span></span><br><span class="line">        <span class="keyword">if</span>(request.getURI().getPath().contains(<span class="string">&quot;/login&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//4.判断token是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.判断token是否有效</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claimsBody</span> <span class="operator">=</span> AppJwtUtil.getClaimsBody(token);</span><br><span class="line">            <span class="comment">//是否是过期</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> AppJwtUtil.verifyToken(claimsBody);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="number">1</span> || result  == <span class="number">2</span>)&#123;</span><br><span class="line">                response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">                <span class="keyword">return</span> response.setComplete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// token没问题</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">userId</span> <span class="operator">=</span> claimsBody.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="comment">// 把token放入请求头中传给自媒体微服务</span></span><br><span class="line">            <span class="type">ServerHttpRequest</span> <span class="variable">serverHttpRequest</span> <span class="operator">=</span> request.mutate().headers(httpHeaders -&gt; &#123;</span><br><span class="line">                httpHeaders.add(<span class="string">&quot;userId&quot;</span>, userId + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;).build();</span><br><span class="line">            exchange.mutate().request(serverHttpRequest);<span class="comment">// 重置请求</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.放行</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级设置  值越小  优先级越高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>自媒体微服务的拦截器拦截到userId后存入ThreadLocal中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">// 前置方法（得到header中的用户信息并存入当前线程中）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.从请求头中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.存入ThreadLocal中</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(userId)) &#123;</span><br><span class="line">            <span class="type">WmUser</span> <span class="variable">wmUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WmUser</span>();</span><br><span class="line">            wmUser.setApUserId(Integer.parseInt(userId));</span><br><span class="line">            WmThreadLocalUtil.setUser(wmUser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置方法（清理线程中的数据）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 清理用户</span></span><br><span class="line">        WmThreadLocalUtil.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置使自定义拦截器生效</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文章自动审核流程"><a href="#文章自动审核流程" class="headerlink" title="文章自动审核流程"></a>文章自动审核流程</h1><ol><li>文章发布后，系统自动审核，主要是通过第三方接口对文章内容进行审核（成功、失败、不确定）。</li><li>自动审核返回不确定信息时，转到人工审核，由平台管理员进行审核。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\0f81e5cbf552466d9118ee05280ed9f9.png" alt="0f81e5cbf552466d9118ee05280ed9f9.png"></li></ol><blockquote><p>先审核文章，再审核图片，如果文章和图片都通过了，修改文章状态；如果有一个没有审核通过，转为人工审核。<br>其中审核时调用阿里云的第三方接口</p></blockquote><h2 id="内容安全第三方接口"><a href="#内容安全第三方接口" class="headerlink" title="内容安全第三方接口"></a>内容安全第三方接口</h2><p>内容安全是识别服务，支持对图片、视频、文本、语音等对象进行多样化场景检测，有效降低内容违规风险。<br><a href="https://help.aliyun.com/document_detail/71095.html">阿里云内容安全文档</a><br><a href="https://help.aliyun.com/document_detail/70439.html?spm=a2c4g.11186623.help-menu-28415.d_3_1_4_2_0.4f4755d9zu1Aae">文本审核</a></p><h1 id="分布式id"><a href="#分布式id" class="headerlink" title="分布式id"></a>分布式id</h1><p>随着业务的增长，文章表可能会占用很大的物理存储空间，为了解决该问题，后期使用数据库分片技术，将一个数据库进行拆分，通过数据库中间件连接。如果数据库中该表选用id自增策略，则可能产生重复的id，就可以使用分布式id生成策略。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\8f7f0ab1a45d494e860b31e4063d1f06.png" alt="8f7f0ab1a45d494e860b31e4063d1f06.png"></p><h2 id="分布式id生成策略"><a href="#分布式id生成策略" class="headerlink" title="分布式id生成策略"></a>分布式id生成策略</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\f361435dea7442ad9e5c47386fa59e89.png" alt="f361435dea7442ad9e5c47386fa59e89.png"><br>雪花算法：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3ba06efd4b1542258f7fa83629b42522.png" alt="3ba06efd4b1542258f7fa83629b42522.png"></p><ol><li>在实体类中的id上加入以下配置：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableId(value = &quot;id&quot;,type = IdType.ID_WORKER)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure><ol start="2"><li>在配置文件中配置数据中心id和机器id</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:mapper/*.xml</span></span><br><span class="line">  <span class="comment"># 设置别名包扫描路径，通过该属性可以给包中的类注册别名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.heima.model.article.pojos</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">datacenter-id:</span> <span class="number">1</span> <span class="comment"># 数据中心id（范围：0-31）</span></span><br><span class="line">    <span class="attr">workerId:</span> <span class="number">1</span> <span class="comment"># 机器id（范围：0-31）</span></span><br></pre></td></tr></table></figure><h1 id="Feign远程调用服务降级处理"><a href="#Feign远程调用服务降级处理" class="headerlink" title="Feign远程调用服务降级处理"></a>Feign远程调用服务降级处理</h1><ol><li>编写降级逻辑</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IArticleClientFallback</span> <span class="keyword">implements</span> <span class="title class_">IArticleClient</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">saveArticle</span><span class="params">(ArticleDto articleDto)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR, <span class="string">&quot;获取数据失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>远程接口中指向降级代码</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;leadnews-article&quot;, fallback = IArticleClientFallback.class)</span> <span class="comment">// 指向降级代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IArticleClient</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/api/v1/article/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">saveArticle</span><span class="params">(<span class="meta">@RequestBody</span> ArticleDto articleDto)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>客户端开启对熔断降级的支持</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="comment"># 开启feign对hystrix熔断降级的支持</span></span><br><span class="line">  <span class="attr">hystrix:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 修改调用超时时间</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">2000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><h1 id="同步调用和异步调用"><a href="#同步调用和异步调用" class="headerlink" title="同步调用和异步调用"></a>同步调用和异步调用</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\4beb87b53ac54e50ad3a05e2e56aaa3c.png" alt="4beb87b53ac54e50ad3a05e2e56aaa3c.png"></p><blockquote><p>同步：发出一个调用后，没有得到结果之前，该调用不返回（实时处理）<br>异步：调用在发出后，这个调用直接返回了，没有返回结果（分时处理）</p></blockquote><h2 id="SpringBoot集成异步线程调用"><a href="#SpringBoot集成异步线程调用" class="headerlink" title="SpringBoot集成异步线程调用"></a>SpringBoot集成异步线程调用</h2><ol><li>在自动审核的方法上加<code>@Async</code>注解（标明要异步调用）</li><li>在文章发布成功后异步调用审核的方法</li><li>在自媒体引导类中使用<code>@EnableAsync</code>注解开启异步调用</li></ol><h1 id="自管理敏感词过滤"><a href="#自管理敏感词过滤" class="headerlink" title="自管理敏感词过滤"></a>自管理敏感词过滤</h1><h2 id="自管理敏感词过滤（文本）"><a href="#自管理敏感词过滤（文本）" class="headerlink" title="自管理敏感词过滤（文本）"></a>自管理敏感词过滤（文本）</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\2c687d18fe064afc8f865d09571c18c3.png" alt="2c687d18fe064afc8f865d09571c18c3.png"></p><h3 id="DFA确定有穷自动机"><a href="#DFA确定有穷自动机" class="headerlink" title="DFA确定有穷自动机"></a>DFA确定有穷自动机</h3><p>一次性把所有的敏感词存储到多个map中。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\cf31722e5c574004840a064118418373.png" alt="cf31722e5c574004840a064118418373.png"></p><h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><p><img src="D:\project\kaiFa\Blog\source_posts\assets\d573133dd34c41eaaa3076649c8e3a46.png" alt="d573133dd34c41eaaa3076649c8e3a46.png"></p><h2 id="自管理敏感词过滤（图片）"><a href="#自管理敏感词过滤（图片）" class="headerlink" title="自管理敏感词过滤（图片）"></a>自管理敏感词过滤（图片）</h2><h3 id="图片文字识别OCR"><a href="#图片文字识别OCR" class="headerlink" title="图片文字识别OCR"></a>图片文字识别OCR</h3><p><img src="D:\project\kaiFa\Blog\source_posts\assets\82684bcc593349d4b8593b5508162b64.png" alt="82684bcc593349d4b8593b5508162b64.png"><br>Tess4J支持多种输出格式：纯文本、hOCR（HTML）、PDF等</p><ol><li>导入依赖：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.tess4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tess4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>导入中文字体库</li><li>识别图片中的文字</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> TesseractException &#123;</span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="type">ITesseract</span> <span class="variable">tesseract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tesseract</span>();</span><br><span class="line">    <span class="comment">// 设置字体库路径</span></span><br><span class="line">    tesseract.setDatapath(<span class="string">&quot;D:\\project\\kaiFa\\heiMaProject\\weiFuWu\\leadnews&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置语言</span></span><br><span class="line">    tesseract.setLanguage(<span class="string">&quot;chi_sim&quot;</span>);</span><br><span class="line">    <span class="comment">// 识别图片</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\project\\kaiFa\\heiMaProject\\weiFuWu\\leadnews\\image-20210524161243572.png&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> tesseract.doOCR(file);</span><br><span class="line">    System.out.println(res.replaceAll(<span class="string">&quot;\\r|\\n&quot;</span>, <span class="string">&quot;-&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> 敏感词过滤 </tag>
            
            <tag> springcloud </tag>
            
            <tag> 分布式id </tag>
            
            <tag> 自动审核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis实现延迟任务</title>
      <link href="/post/20601890.html"/>
      <url>/post/20601890.html</url>
      
        <content type="html"><![CDATA[<p>定时任务：有固定周期，有明确的触发时间<br>延迟任务：没有固定的开始时间，由一个事件触发，在这个事件触发之后的一段时间内触发另一个事件，任务可以立即执行，也可以延迟执行。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3f808a9512304e7fa614c5993e7a234b.png" alt="3f808a9512304e7fa614c5993e7a234b.png"></p><blockquote><p>场景1：订单下单30分钟后，如果用户没有付钱，则系统自动取消订单；如果期间下单成功，任务取消。<br>场景2：接口对接接口出现网络问题，1分钟后重试，如果失败，2分钟后重试，直到出现阈值终止。</p></blockquote><p>实现方式</p><ol><li>DelayQueue，基于JVM</li><li>RabbitMQ：TTL+死信队列</li><li>Redis：zset（本项目实现）</li></ol><hr><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><ol><li>添加任务的时候会先放入数据库中</li><li>list队列存储的是<strong>立即执行的任务</strong>，如果<code>执行时间&lt;=当前时间</code>，则任务进入list队列中，立即执行。</li><li>zset队列中存储的是<strong>未来要执行的任务</strong>，如果<code>执行时间&lt;=当前时间+5min</code>（不需要把所有未来执行的任务都放入zset中，如果<code>执行时间&gt;当前时间+5min</code>，则还是放入数据库中），则任务进入zset队列，每分钟定时刷新把到期的任务再放入list队列中。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1d72b397f91847fb940c218859c5fc01.png" alt="1d72b397f91847fb940c218859c5fc01.png"></li></ol><blockquote><p>延迟任务是一个通用的服务，任何有延迟需求的任务都可以调用该服务，内存数据库的存储是有限的，需要考虑数据持久化的问题，存储到数据库中可以保证数据安全。<br>任务量过大以后，zset的性能会下降<br>如果任务数据特别大，为了防止阻塞，所以只需要把未来几分钟要执行的数据存入缓存即可，是一种优化的形式。</p></blockquote><h1 id="数据库自身解决并发的两种策略"><a href="#数据库自身解决并发的两种策略" class="headerlink" title="数据库自身解决并发的两种策略"></a>数据库自身解决并发的两种策略</h1><ol><li><p>悲观锁：每次拿数据的时候都认为别人会修改，所以在每次拿数据的时候都会上锁。</p></li><li><p>乐观锁：每次拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据（版本号）。</p></li></ol><h2 id="乐观锁的实现步骤"><a href="#乐观锁的实现步骤" class="headerlink" title="乐观锁的实现步骤"></a>乐观锁的实现步骤</h2><ol><li>在版本号上加<code>@Version</code>注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><ol start="2"><li>在mybatis-plus开启乐观锁支持</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis-plus乐观锁支持</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">optimisticLockerInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h1><ol><li>安装redis：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis --restart=always -p 6379:6379 redis --requirepass &quot;leadnews&quot;</span><br></pre></td></tr></table></figure><ol start="2"><li>项目中集成redis</li></ol><ul><li>导入依赖：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- redis依赖commons-pool 这个依赖一定要添加 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加配置：</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">leadnews</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="1-拉取任务"><a href="#1-拉取任务" class="headerlink" title="1. 拉取任务"></a>1. 拉取任务</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拉取任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">addTask</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 添加任务到数据库中</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> addTaskToDb(task);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;添加任务到数据库失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 添加任务到redis中</span></span><br><span class="line">    addTaskToCache(task);</span><br><span class="line">    <span class="keyword">return</span> task.getTaskId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加任务到数据库中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addTaskToDb</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 保存任务表</span></span><br><span class="line">        <span class="type">Taskinfo</span> <span class="variable">taskinfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Taskinfo</span>();</span><br><span class="line">        BeanUtils.copyProperties(task, taskinfo);</span><br><span class="line">        taskinfo.setExecuteTime(<span class="keyword">new</span> <span class="title class_">Date</span>(task.getExecuteTime()));</span><br><span class="line">        taskinfoMapper.insert(taskinfo);</span><br><span class="line">        <span class="comment">// 2. 保存任务日志数据</span></span><br><span class="line">        <span class="type">TaskinfoLogs</span> <span class="variable">taskinfoLogs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskinfoLogs</span>();</span><br><span class="line">        BeanUtils.copyProperties(taskinfo, taskinfoLogs);</span><br><span class="line">        taskinfoLogs.setVersion(<span class="number">1</span>);</span><br><span class="line">        taskinfoLogs.setStatus(ScheduleConstants.SCHEDULED);</span><br><span class="line">        taskinfoLogsMapper.insert(taskinfoLogs);</span><br><span class="line">        <span class="comment">// 设置taskId</span></span><br><span class="line">        task.setTaskId(taskinfo.getTaskId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加任务到redis中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addTaskToCache</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> task.getTaskType() + <span class="string">&quot;_&quot;</span> + task.getPriority();</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    calendar.add(Calendar.MINUTE, <span class="number">5</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">nextScheduledTime</span> <span class="operator">=</span> calendar.getTimeInMillis();</span><br><span class="line">    <span class="keyword">if</span>(task.getExecuteTime() &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line">        <span class="comment">// 如果任务的执行时间≤当前时间，存入list中</span></span><br><span class="line">        cacheService.lLeftPush(ScheduleConstants.TOPIC + key, JSON.toJSONString(task));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(task.getExecuteTime() &lt;= nextScheduledTime) &#123;</span><br><span class="line">        <span class="comment">// 如果任务的执行时间＞当前时间 &amp;&amp; 任务的执行时间&gt;预设时间（未来五分钟），存入zset中</span></span><br><span class="line">        cacheService.zAdd(ScheduleConstants.FUTURE + key, JSON.toJSONString(task), task.getExecuteTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>在数据库中保存一份，要保存到任务表和任务数据表中</li><li>添加任务到redis中，如果≤当前时间的，要存入list中，如果≤预设时间的，要存入zset中。</li></ol></blockquote><h2 id="2-取消任务"><a href="#2-取消任务" class="headerlink" title="2. 取消任务"></a>2. 取消任务</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\0b8bb5b034804a75bccbd9f5e23eb154.png" alt="0b8bb5b034804a75bccbd9f5e23eb154.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> taskId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">cancelTask</span><span class="params">(<span class="type">long</span> taskId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.删除任务，更新任务日志</span></span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> updateDb(taskId, ScheduleConstants.CANCELLED);</span><br><span class="line">    <span class="keyword">if</span>(task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;删除任务失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.删除redis的数据</span></span><br><span class="line">    removeTaskFromCache(task);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除缓存中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTaskFromCache</span><span class="params">(Task task)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> task.getTaskType() + <span class="string">&quot;_&quot;</span> + task.getPriority();</span><br><span class="line">        <span class="keyword">if</span>(task.getExecuteTime() &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">// 如果任务的执行时间≤当前时间，从list中删除</span></span><br><span class="line">            cacheService.lRemove(ScheduleConstants.TOPIC + key, <span class="number">0</span>, JSON.toJSONString(task));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// task任务不是在list中，就是在zset中，这里就不需要再判断一次了</span></span><br><span class="line">            cacheService.zRemove(ScheduleConstants.FUTURE + key, JSON.toJSONString(task));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除任务，更新任务日志</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> taskId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Task <span class="title function_">updateDb</span><span class="params">(<span class="type">long</span> taskId, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 删除任务</span></span><br><span class="line">        taskinfoMapper.deleteById(taskId);</span><br><span class="line">        <span class="comment">// 更新任务日志</span></span><br><span class="line">        <span class="type">TaskinfoLogs</span> <span class="variable">taskinfoLogs</span> <span class="operator">=</span> taskinfoLogsMapper.selectById(taskId);</span><br><span class="line">        taskinfoLogs.setStatus(status);</span><br><span class="line">        taskinfoLogsMapper.updateById(taskinfoLogs);</span><br><span class="line">        task = <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        BeanUtils.copyProperties(taskinfoLogs, task);</span><br><span class="line">        task.setExecuteTime(taskinfoLogs.getExecuteTime().getTime());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>在数据库中，从任务表中删除taskId的任务，更新任务日志表中的日志状态</li><li>在缓存中，删除list或zset中的任务</li></ol></blockquote><h2 id="3-消费任务"><a href="#3-消费任务" class="headerlink" title="3. 消费任务"></a>3. 消费任务</h2><h3 id="从list中消费任务"><a href="#从list中消费任务" class="headerlink" title="从list中消费任务"></a>从list中消费任务</h3><p><img src="D:\project\kaiFa\Blog\source_posts\assets\73129db38fc945bd9d5375c43a53d300.png" alt="73129db38fc945bd9d5375c43a53d300.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Task <span class="title function_">poll</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">    <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从redis中拉取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> type + <span class="string">&quot;_&quot;</span> + priority;</span><br><span class="line">        <span class="type">String</span> <span class="variable">taskJson</span> <span class="operator">=</span> cacheService.lRightPop(ScheduleConstants.TOPIC + key);</span><br><span class="line">        <span class="keyword">if</span>(taskJson != <span class="literal">null</span>) &#123;</span><br><span class="line">            task = JSON.parseObject(taskJson, Task.class);</span><br><span class="line">            <span class="comment">// 修改数据库信息</span></span><br><span class="line">            updateDb(task.getTaskId(), ScheduleConstants.EXECUTED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未来数据定时刷新"><a href="#未来数据定时刷新" class="headerlink" title="未来数据定时刷新"></a>未来数据定时刷新</h3><p>从zset中定时刷新任务到list中<br><img src="D:\project\kaiFa\Blog\source_posts\assets\4ce9e74e47d443f9aeeece5d7ac94f65.png" alt="4ce9e74e47d443f9aeeece5d7ac94f65.png"><br><strong>获取zset中所有的key</strong>：</p><ul><li>keys模糊匹配：效率低</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; keys = cacheService.keys(<span class="string">&quot;future_*&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>scan命令：是一个基于游标的迭代器，每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新的游标作为SCAN命令的游标参数。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3247deaa714c493f83aa3e4f0dfb98c0.png" alt="3247deaa714c493f83aa3e4f0dfb98c0.png"></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; scan = cacheService.scan(<span class="string">&quot;future_*&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>添加定时任务，每分钟刷新，从zset中取出符合条件的数据后放入redis管道中<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ce2ae71d1b544ab98d972da4d9a84644.png" alt="ce2ae71d1b544ab98d972da4d9a84644.png"></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 未来数据定时刷新</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Scheduled(cron = &quot;0 */1 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;refresh...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取未来数据的keys集合</span></span><br><span class="line">    Set&lt;String&gt; futureKeys = cacheService.scan(ScheduleConstants.FUTURE + <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="comment">// 按照key和分值查询符合条件的数据</span></span><br><span class="line">    <span class="keyword">for</span> (String futureKey : futureKeys) &#123; <span class="comment">// future_100_50</span></span><br><span class="line">        <span class="comment">// 获取当前数据的topicKey</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">topicKey</span> <span class="operator">=</span> ScheduleConstants.TOPIC + futureKey.split(ScheduleConstants.FUTURE)[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 0到当前时间所有查询符合条件的数据</span></span><br><span class="line">        Set&lt;String&gt; tasks = cacheService.zRangeByScore(futureKey, <span class="number">0</span>, System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">if</span>(!tasks.isEmpty()) &#123;</span><br><span class="line">            cacheService.refreshWithPipeline(futureKey, topicKey, tasks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在启动类上开启定时任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span> <span class="comment">// 开启定时任务</span></span><br></pre></td></tr></table></figure><blockquote><p>【目前存在的问题】：如果启动了两个服务，那么这两个服务会在同一时间去执行定时任务，会导致方法抢占的问题。但是我们的需求是只要时间到了，有一台服务在执行定时任务即可。<br>【解决办法】：分布式锁来解决方法抢占的问题</p></blockquote><p><strong>分布式锁</strong>：控制分布式系统有序的去对共享资源进行操作，通过互斥来保证数据的一致性。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\668c8755ac614eee8ae3857e271347ba.png" alt="668c8755ac614eee8ae3857e271347ba.png"></p><blockquote><p>服务A在访问的Redis服务的时候，先加锁，此时只有A可以访问Redis服务，B访问Redis服务会失败。A释放锁后，B才可以访问。<br>A获取锁后，其他客户端不能操作，只能等待A释放锁以后，其他客户端才能操作。</p></blockquote><ol start="3"><li>加锁代码：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expire</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">tryLock</span><span class="params">(String name, <span class="type">long</span> expire)</span> &#123;</span><br><span class="line">    name = name + <span class="string">&quot;_lock&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="type">RedisConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> stringRedisTemplate.getConnectionFactory();</span><br><span class="line">    <span class="type">RedisConnection</span> <span class="variable">conn</span> <span class="operator">=</span> factory.getConnection();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参考redis命令：</span></span><br><span class="line">        <span class="comment">//set key value [EX seconds] [PX milliseconds] [NX|XX]</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> conn.set(</span><br><span class="line">                name.getBytes(),</span><br><span class="line">                token.getBytes(),</span><br><span class="line">                Expiration.from(expire, TimeUnit.MILLISECONDS),</span><br><span class="line">                RedisStringCommands.SetOption.SET_IF_ABSENT <span class="comment">//NX</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">null</span> &amp;&amp; result)</span><br><span class="line">            <span class="keyword">return</span> token;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        RedisConnectionUtils.releaseConnection(conn, factory,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>修改refresh()方法：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 */1 * * * ?&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> cacheService.tryLock(<span class="string">&quot;FUTRUE_TASK_SYNC&quot;</span>, <span class="number">1000</span> * <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isNotBlank(token)) &#123;</span><br><span class="line">        <span class="comment">// 原本的refresh逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-数据库任务定时同步到redis中"><a href="#4-数据库任务定时同步到redis中" class="headerlink" title="4. 数据库任务定时同步到redis中"></a>4. 数据库任务定时同步到redis中</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 数据库任务定时同步到redis中</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@PostConstruct</span> <span class="comment">// 微服务启动的时候执行</span></span><br><span class="line"> <span class="meta">@Scheduled(cron = &quot;0 */5 * * * ?&quot;)</span><span class="comment">// 每五分钟执行</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reloadData</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 清理缓存中的数据 list、zset</span></span><br><span class="line">     clearCache();</span><br><span class="line">     <span class="comment">// 查询符合条件的任务(小于未来五分钟的数据)</span></span><br><span class="line">     <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">     calendar.add(Calendar.MINUTE, <span class="number">5</span>);</span><br><span class="line">     <span class="type">long</span> <span class="variable">nextScheduledTime</span> <span class="operator">=</span> calendar.getTimeInMillis();</span><br><span class="line">     List&lt;Taskinfo&gt; taskinfoList = taskinfoMapper.selectList(Wrappers.&lt;Taskinfo&gt;lambdaQuery().lt(Taskinfo::getExecuteTime, calendar.getTime()));</span><br><span class="line">     <span class="comment">// 把任务添加到redis中</span></span><br><span class="line">     <span class="keyword">if</span>(taskinfoList != <span class="literal">null</span> &amp;&amp; !taskinfoList.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">for</span> (Taskinfo taskinfo : taskinfoList) &#123;</span><br><span class="line">             <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">             BeanUtils.copyProperties(taskinfo, task);</span><br><span class="line">             task.setExecuteTime(taskinfo.getExecuteTime().getTime());</span><br><span class="line">             addTaskToCache(task);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     log.info(<span class="string">&quot;数据库任务同步到redis中&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 延迟任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【复习】计算机网络</title>
      <link href="/post/e9efd809.html"/>
      <url>/post/e9efd809.html</url>
      
        <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><ul><li>应用层：给应用程序提供统一的接口</li><li>表示层：把数据转换成兼容另一个系统能识别的格式</li><li>会话层：负责建立、管理、终止表示层实体之间的通信会话</li><li>传输层：负责端到端的数据传输</li><li>网络层：负责数据的路由、转发、分片</li><li>数据链路层：负责数据的封帧和差错检测，以及MAC寻址</li><li>物理层：负责在物理网络中传输数据帧</li></ul><h2 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h2><ul><li>应用层：支持HTTP、SMTP等最终用户进程</li><li>传输层：处理主机到主机之间的通信</li><li>网络层：寻址和路由数据包</li><li>链路层：通过网络的物理电线或无线信道移动比特</li></ul><blockquote><p>TCP在传输层；IP在网络层</p></blockquote><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层的协议？"><a href="#应用层的协议？" class="headerlink" title="应用层的协议？"></a>应用层的协议？</h2><p>HTTP、HTTPS、CDN、DNS、FTP</p><h2 id="HTTP报文有哪几部分？"><a href="#HTTP报文有哪几部分？" class="headerlink" title="HTTP报文有哪几部分？"></a>HTTP报文有哪几部分？</h2><p>请求报文：</p><ul><li>请求行：请求方法、目标、HTTP版本</li><li>请求头：请求的附加信息（Host、User-Agent….）</li><li>空行：请求头和请求体之间用空行空格</li><li>请求体：请求的数据，用于POST请求需要传输数据的情况</li></ul><p>响应报文：</p><ul><li>状态行：HTTP协议、状态码、状态信息</li><li>响应头：响应的附加信息（Content-Type、Content-Length…）</li><li>空行：响应头和响应体之间用空行空格</li><li>响应体：包含响应的数据（服务器返回的HTML、JSON….）</li></ul><h2 id="HTTP常用状态码"><a href="#HTTP常用状态码" class="headerlink" title="HTTP常用状态码"></a>HTTP常用状态码</h2><ul><li><p>1xx：提示信息，协议处理的中间状态，还需要后续操作（少用）</p></li><li><p>2xx：成功，报文已收到并被正确处理（200、204、206）</p></li><li><p>3xx：资源重定向，资源位置发生变动，需要客户端重新用新的URL发请求（301、302、304）</p><ul><li>301 - 永久重定向，说明请求的资源已经不存在了，需要改用新的URL再次访问</li><li>302 - 临时重定向，说明请求的资源还在但是暂时需要用另一个URL访问</li></ul><blockquote><p>301 和 302都会在响应头指明后续要跳转的URL</p></blockquote></li><li><p>4xx：客户端错误，请求报文有误，服务器无法处理（400、403、404、405）</p><ul><li>404 - 无法找到此页面</li><li>405 - 请求的方法类型不支持</li></ul></li><li><p>5xx：服务器错误（500、501、502、503）</p><ul><li>502 - 服务器执行请求时，从上游服务器接收到无效的响应</li><li>504 - 服务器执行请求时，未能及时从上游服务器收到响应</li></ul></li></ul><blockquote><p>nginx是代理服务器，收到客户端请求后，将请求发到后端服务器；</p><ul><li>502：nginx收到无效的响应</li><li>503：请求超时（超过了nginx的配置时间）</li></ul></blockquote><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>GET：从服务器获取资源，请求参数写在URL位置（URL只支持ASCII且浏览器对URL的有限制）</p><p>POST：根据body对指定的资源做处理，携带的数据写在body里。</p><blockquote><p>GET是安全、幂等的（只读），可以对GET数据做缓存，可以缓存到浏览器上，也可以缓存到nginx上，在浏览器中GET请求可以保存为书签。</p><p>POST是不安全、不是幂等的（写），浏览器一般不会缓存POST请求，也不能把POST请求保存为书签</p></blockquote><blockquote><p>实际开发中，也会用POST方法实现查询数据的请求</p></blockquote><h2 id="HTTP长连接"><a href="#HTTP长连接" class="headerlink" title="HTTP长连接"></a>HTTP长连接</h2><p>HTTP协议是“请求-响应”模式，先建立TCP连接，客户端发起了HTTP请求，服务器收到后就返回响应，然后释放TCP连接。</p><p>HTTP短连接：一次连接只能请求一次资源</p><p>HTTP长连接（Keep-Alive）：使用同一个TCP连接来发送和接收多个HTTP请求，避免了连接建立和释放的开销。只要任何一段没有明确提出断开连接，则保持TCP连接状态。</p><h2 id="HTTP怎么对请求做拆包的？"><a href="#HTTP怎么对请求做拆包的？" class="headerlink" title="HTTP怎么对请求做拆包的？"></a>HTTP怎么对请求做拆包的？</h2><p>请求的拆包是通过“Content-Length”头字段来进行的。该字段指示了请求正文的长度，服务器可以根据该长度来正确接收和解析请求。</p><ol><li>客户端发送HTTP请求，会在请求头中增加“Content-Length”字段，用来表示请求正文的字节数</li><li>浏览器根据“Content-Length”字段来确定请求的长度，并从请求中读取相应数量的字节，直到读取完整个请求的内容</li></ol><h2 id="HTTP为什么不安全？"><a href="#HTTP为什么不安全？" class="headerlink" title="HTTP为什么不安全？"></a>HTTP为什么不安全？</h2><p>HTTP是基于明文传输的，通信链路上可以获取通信内容；其他用户可以篡改内容；也可以冒充发送方。</p><p>HTTPS是在HTTP和TCP层之间引入了SSL&#x2F;TLS协议，解决了上述风险。</p><h2 id="HTTP-和-HTTPS的区别？"><a href="#HTTP-和-HTTPS的区别？" class="headerlink" title="HTTP 和 HTTPS的区别？"></a>HTTP 和 HTTPS的区别？</h2><ol><li>HTTP是超文本传输协议，存在安全风险；HTTPS解决了HTTP不安全的缺陷，在TCP和HTTP之间加入了SSL&#x2F;TLS协议</li><li>HTTP建立相对简单，通过TCP三次握手后就可以进行HTTP的报文传输；HTTPS在TCP三次握手后还需要建立SSL&#x2F;TLS的握手才能进行加密报文传输</li><li>HTTP默认端口80；HTTPS默认端口443</li><li>HTTPS需要向CA申请数字证书，来保证服务器的身份是可用的</li></ol><h2 id="TLS的四次握手过程？"><a href="#TLS的四次握手过程？" class="headerlink" title="TLS的四次握手过程？"></a>TLS的四次握手过程？</h2><ol><li><p>第一次握手：客户端向服务器发起加密通信请求（ClientHello），主要发送以下信息：</p><ul><li>客户端支持的TLS协议版本</li><li>客户端生成的<strong>随机数</strong>（后边用于生成会话秘钥）</li><li>客户端支持的密码套件列表（RSA加密算法）</li></ul></li><li><p>第二次握手：服务器收到客户端请求后，向客户端发出响应（ServerHello），主要回应以下信息：</p><ul><li>确认TLS协议版本</li><li>服务器生成的<strong>随机数</strong>（后边也是用于生成会话秘钥）</li><li>确认的密码套件列表（RSA加密算法）</li><li>服务器的数字证书</li></ul></li><li><p>第三次握手：客户端收到服务器回应后，通过浏览器或操作系统里的CA公钥，确认服务器的数字证书的真实性。整数如果没有问题，就会从数字证书里取出服务器的公钥，用它加密报文，向服务器发送以下信息：</p><ul><li>一个<strong>随机数</strong>（会被服务器公钥加密）</li><li>加密通信算法改变通知（告知服务器随后的信息都会用“会话密钥”加密通信）</li><li>客户端握手结束通知（表示客户端的握手已经结束）</li></ul><blockquote><p>通过这三个随机数，接着用双方协商的加密算法，各自生成本次通信的“会话密钥”</p></blockquote></li><li><p>第四次握手：服务器通过协商的加密算法，计算出本次通信的“会话密钥”，向客户端回应以下消息：</p><ul><li>加密通信算法改变通知（告知客户端随后的消息都会用“会话密钥”加密通信）</li><li>服务器握手结束通知（表明服务器的握手已经结束）</li></ul></li></ol><blockquote><p>整个TLS的握手全部结束后，服务器与客户端就会进入加密通信，完全是使用普通的HTTP协议，只不过用“会话密钥”加密内容</p></blockquote><h2 id="HTTPS如何防范中间人攻击？"><a href="#HTTPS如何防范中间人攻击？" class="headerlink" title="HTTPS如何防范中间人攻击？"></a>HTTPS如何防范中间人攻击？</h2><ul><li>加密：https握手期间会通过非对称加密方式协商出对称加密密钥</li><li>身份验证：客户端与服务器建立连接后，服务器会将CA证书发送给客户端，客户端会去校验CA整数的合法性。验证通过后，使用证书中的公钥来加密数据，并将加密后的数据传给服务器，服务器用私钥解密</li></ul><blockquote><p>中间人的攻击在于冒充服务器与客户端建立连接，但是中间人拿不到服务器的私钥，无法正确解密客户端发过来的数据。同时如果客户端校验CA证书后，证书验证失败，也会中断连接。</p></blockquote><h2 id="HTTP1-1-和-HTTP2-0的区别？"><a href="#HTTP1-1-和-HTTP2-0的区别？" class="headerlink" title="HTTP1.1 和 HTTP2.0的区别？"></a>HTTP1.1 和 HTTP2.0的区别？</h2><ol><li>头部压缩：HTTP2会压缩头部，如果发送多个请求，他们的请求头部是一样的，协议会帮忙消除重复的部分。</li></ol><blockquote><p>HPACK算法：客户端和服务器同时维护一张头部信息表，所有的字段都存入这个表中，并生成一个索引号，以后就不会发送同样的字段，直接发送索引号即可。</p></blockquote><ol start="2"><li>二进制格式：HTTP1.1采用的是纯文本形式的报文；HTTP2全面采用了二进制格式。增加了数码据传输的效率</li><li>并发传输：多个Stream复用在同一条TCP连接上，解决了HTTP1.1队头阻塞的问题</li><li>服务器主动推送资源：服务器不再是被动的响应，可以主动向客户端发送消息</li></ol><h2 id="HTTP进行TCP连接之后，什么情况下会断开连接？"><a href="#HTTP进行TCP连接之后，什么情况下会断开连接？" class="headerlink" title="HTTP进行TCP连接之后，什么情况下会断开连接？"></a>HTTP进行TCP连接之后，什么情况下会断开连接？</h2><ol><li>客户端 或 服务器发送一条FIN报文，就会进行四次挥手</li><li>发送方发送了一条数据给服务器，服务器超过一段时间没有响应ACK报文，发送方重传达到最大次数时，就会断开TCP连接</li><li>HTTP长时间没有进行请求和响应。</li></ol><h2 id="HTTP、SOCKET和TCP的区别？"><a href="#HTTP、SOCKET和TCP的区别？" class="headerlink" title="HTTP、SOCKET和TCP的区别？"></a>HTTP、SOCKET和TCP的区别？</h2><ul><li>HTTP：应用层协议，定义了客户端和服务器之间交换数据的规则；在客户端和服务器之间传输和显示web页面</li><li>Socket：用于描述通信链路的一端，提供了底层的通信接口，可实现不同计算机之间的数据交换</li><li>TCP：传输层协议，负责在网络中建立可靠的数据传输连接</li></ul><h2 id="DNS是什么？"><a href="#DNS是什么？" class="headerlink" title="DNS是什么？"></a>DNS是什么？</h2><p>DNS是用来将域名转化成IP地址的数据库系统，端口号53。（越靠右层级越高）</p><ul><li>根域名服务器</li><li>顶级域名服务器</li><li>权威域名服务器</li></ul><p>DNS底层是基于UDP协议的，因为UDP可以提供低延迟的特性，更适合DNS这种需要快速响应的域名解析服务。</p><blockquote><p>虽然UDP存在丢包和数据包损坏的风险，但是DNS使用一些机制来提高可靠性（超时重传、请求重试、缓存…）</p></blockquote><h2 id="DNS域名解析流程？"><a href="#DNS域名解析流程？" class="headerlink" title="DNS域名解析流程？"></a>DNS域名解析流程？</h2><ol><li>客户端发送DNS请求，发送给本地域名服务器</li><li>本地域名服务器先去查询缓存，如果查到，直接返回IP地址；如果没有查到，就进行迭代查询<ul><li>本地域名服务器去访问他的根域名服务器，根域名服务器并不会进行域名解析，而是告诉它顶级域名服务器的IP地址</li><li>本地域名服务器又去访问顶级域名服务器，顶级域名服务器也不会进行域名解析，而是告诉它权威域名服务器的IP地址</li><li>本地域名服务器又去访问权威域名服务器，权威域名服务器是域名解析结果的原出处，将该域名对应的IP地址告诉本地域名服务器，随后本地域名服务器将IP地址返回给客户端，成功建立连接。</li></ul></li></ol><h2 id="HTTP是无状态的吗？"><a href="#HTTP是无状态的吗？" class="headerlink" title="HTTP是无状态的吗？"></a>HTTP是无状态的吗？</h2><p>HTTP是无状态的，服务器不会在多个请求中保留客户端状态的信息，在每个HTTP请求中，服务器不会记住之前的请求和会话状态，每个请求都是独立的。</p><blockquote><p>可以通过一些机制来实现状态保持，例如：使用Cookie和Session来跟踪用户的状态。</p><p>通过在客户端存储会话信息，服务器可以识别和跟踪特定用户的状态。</p></blockquote><p>携带Cookie的HTTP是有状态的，Cookie是用来在客户端存储会话信息和状态信息的，通过使用Cookie可以实现一定程度的状态保持功能。</p><blockquote><p>Cookie是HTTP协议簇的一部分，只是无状态协议下的一种补充，用来在客户端存储状态信息以实现状态保持。</p></blockquote><h2 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h2><ol><li>存储位置：Cookie存储在客户端，浏览器向服务器发请求时，会自动携带Cookie；Session存在服务器，服务器为每个用户分配一个SessionId，通过Cookie的方式发送给客户端，客户端的后续请求都会携带SessionId，服务器根据SessionId找到对应的数据</li><li>数据容量：单个Cookie大小限制在4KB左右；Session存储在服务器上，主要受限于服务器内存大小</li><li>安全性：Cookie存储在客户端，相对不安全；Session存储在服务器，比Cookie安全</li><li>生命周期：Cookie可以设置过期时间，过期后自动删除，也可以设置会话Cookie，浏览器关闭后自动删除；Session在默认情况下，用户关闭浏览器时Session结束，服务器也可以设置Session的超时时间。</li></ol><h2 id="token、session、cookie的区别？"><a href="#token、session、cookie的区别？" class="headerlink" title="token、session、cookie的区别？"></a>token、session、cookie的区别？</h2><ol><li><p>session：存储在服务器，拥有一个唯一的SessionId，这个SessionId一般存放在Cookie中。服务器收到Cookie后会解析SessionId，再去Session列表中查找，找到对应的Session。</p></li><li><p>Cookie：类似于一个令牌，装有SessionId，存储在客户端，浏览器一般会自动添加</p></li><li><p>Token：类似一个令牌，无状态，用户信息都被加密到Token中，服务器收到Token后解密就可以知道是哪个用户，需要开发者手动添加。</p></li></ol><blockquote><p>客户端如果禁用了Cookie，Session也无法正常使用，因为大部分的服务器都是依赖Cookie来传递sessionId。</p></blockquote><h2 id="数据存储在localStorage和Cookie有什么区别？"><a href="#数据存储在localStorage和Cookie有什么区别？" class="headerlink" title="数据存储在localStorage和Cookie有什么区别？"></a>数据存储在localStorage和Cookie有什么区别？</h2><ol><li>存储容量：Cookie的存储容量小；LocalStorage的存储容量通常较大（存储大量数据时，LocalStorage更合适）</li><li>数据发送：Cookie在每次请求时都会自动发送到服务器，<strong>适合在服务器和浏览器中传输数据</strong>；LocalStorage不会自动发送数据，只在浏览器中存储数据，更适合于<strong>同一个域名下不同页面之间共享数据</strong></li><li>生命周期：Cookie可以设置过期时间；LocalStorage的数据将永远存在浏览器中，除非通过js代码手动删除</li><li>安全性：Cookie的安全性低，因为Cookie每次请求都会发送给服务器，存在监听和篡改的风险；LocalStorage的数据只存储在浏览器中，相对更安全。</li></ol><h2 id="JWT和传统方式的区别？"><a href="#JWT和传统方式的区别？" class="headerlink" title="JWT和传统方式的区别？"></a>JWT和传统方式的区别？</h2><ol><li>无状态：JWT时无状态的令牌，不需要在服务器存储会话信息。JWT令牌中包含了所有必要的信息。</li><li>安全性：JWT使用秘钥对令牌进行签名，保证令牌的完整性和真实性。</li><li>跨域：JWT令牌可以在不同域之间传递，可以实现无需Cookie的跨域身份验证。</li></ol><blockquote><p>JWT令牌由：头部、载荷、签名三部分组成。</p><p>头部、载荷：JSON格式，使用Base64编码进行序列化</p><p>签名：对头部、载荷、秘钥进行签名后的结果</p></blockquote><h2 id="JWT的缺点？"><a href="#JWT的缺点？" class="headerlink" title="JWT的缺点？"></a>JWT的缺点？</h2><p>JWT一旦派发出去，在失效之前都是有效的，没法即使撤销JWT</p><p>解决：在业务层增加判断逻辑，比如：添加黑名单机制。使用Redis维护一个黑名单，如果让某个JWT失效就直接把这个JWT加入黑名单中，每次使用前就判断这个JWT是否存在黑名单中。</p><h2 id="前端如何存储JWT？"><a href="#前端如何存储JWT？" class="headerlink" title="前端如何存储JWT？"></a>前端如何存储JWT？</h2><p>传统方式：</p><ol><li>浏览器向服务器发起请求</li><li>服务器在当前会话（session）里保存相关数据，并返回一个sessionId</li><li>浏览器拿到sessionId后会存入Cookie，以后每次发请求都会携带Cookie。</li><li>服务器拿到Cookie后会解析出sessionId，并通过这个sessionId找到前期保存的数据。</li></ol><blockquote><p>如果是服务器集群情况下，就需要session共享数据，使得每个服务器都可以读取到session</p></blockquote><p>优化：</p><p>服务器不存储session数据，所有数据都保存在客户端，每次请求都会发回服务器，客户端收到服务器返回的JWT后，可以存储在LocalStorage里，也可以存储在Cookie里，还可以存储在SessionStorage里。</p><ul><li>存储在LocalStorage里：提供了较大的存储空间，不会随HTTP一起发送给服务器，但是恶意脚本可能可以通过JS代码访问到JWT（XSS攻击）。</li><li>存储在Cookie里：设置HttpOnly标志来防止通过JS访问，减少XSS攻击的风险；但是单个Cookie只能存储4KB，并且每次HTTP请求都会携带Cookie</li><li>存储在SessionStorage：当窗口关闭后，数据会被清除；但是用户的体验可能会受到影响，每次刷新页面都需要重新登陆。</li></ul><h2 id="HTTP长连接和WebSocket的区别？"><a href="#HTTP长连接和WebSocket的区别？" class="headerlink" title="HTTP长连接和WebSocket的区别？"></a>HTTP长连接和WebSocket的区别？</h2><ol><li>TCP协议是全双工的（HTTP1.1虽然是基于TCP的协议，但是他是半双工的；HTTP2是全双工的），HTTP1.1对于大部分需要服务器主动推送到客户端的场景都不太友好；而WebSocket是全双工的</li><li>HTTP1.1里，只要客户端不发起请求，服务器就不会给响应。对于服务器和客户端之间需要频繁交互的复杂场景，可以考虑webSocket</li></ol><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><ol><li><p>序列号（seq）：在建立连接时由计算机生成的随机数作为初始值，每发送一次数据，就累加一次该数据字节的大小。（用来解决网络包乱序的问题）</p></li><li><p>确认应答号（ack）：下次“期望”收到的数据的序列号，发送端收到这个说明在这个序列号之前的所有数据都已被正常接收（用来解决丢包问题）</p></li><li><p>控制位：</p><ul><li>ACK：1 -  确认应答号有效</li><li>RST：1 - TCP连接出现异常时必须强制断开连接</li><li>SYN：1 - 希望建立连接</li><li>FIN：1 - 希望断开连接</li></ul></li></ol><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\a47b113b82b7447f9c628ccbaec0a499.png" alt="a47b113b82b7447f9c628ccbaec0a499.png"></p><blockquote><p>第三次握手可以携带数据，前两次握手是不可以携带数据的</p><p>一旦完成三次握手，双方都处于established状态，此时连接就已建立完成，客户端与服务器就可以互相发送数据了。</p></blockquote><h2 id="为什么TCP需要三次握手？"><a href="#为什么TCP需要三次握手？" class="headerlink" title="为什么TCP需要三次握手？"></a>为什么TCP需要三次握手？</h2><p>三次握手主要是为了防止旧的重复连接初始化造成混乱。</p><p>客户端如果连续发送了多个SYN建立连接的报文，</p><ul><li>在网络不好的情况下：“旧的SYN报文（seq &#x3D; 90）”比“新的SYN报文（seq &#x3D; 100）”早到达</li><li>此时服务器<strong>先返回一个SYN+ACK</strong>的报文给客户端，客户端收到后，发现自己期望收到的应该是（100 + 1 &#x3D; 101，而不是90 + 1），就返回RST报文。</li><li>服务器收到RST报文后就会释放连接。</li><li>等到新的SYN报文（100 + 1）到达后，服务器与客户端就可以完成三次握手了</li></ul><blockquote><p>如果只有两次握手无法防止旧的重复连接初始化。</p><p>客户端先后发了两个SYN报文，服务器收到了旧的SYN报文后，也往客户端发一个SYN+ACK的报文，如果只有两次握手，此时双方都已进入established状态，连接已建立。（因为需要浏览器这里判断ack和期望的不同，才会发送RST报文。）</p></blockquote><h2 id="TCP三次握手，在第三次握手中，客户端发送的确认包丢了怎么办？"><a href="#TCP三次握手，在第三次握手中，客户端发送的确认包丢了怎么办？" class="headerlink" title="TCP三次握手，在第三次握手中，客户端发送的确认包丢了怎么办？"></a>TCP三次握手，在第三次握手中，客户端发送的确认包丢了怎么办？</h2><p>因为第三次握手的ACK是针对第二次握手的SYN的确认报文，所以当第三次握手丢失了，如果服务器一直收不到，就会触发超时重传机制，直到收到三次握手。如果达到最大重传次数，服务器就会断开连接</p><h2 id="TCP三次握手，在第一次握手中，客户端发送SYN报文丢失了怎么办？"><a href="#TCP三次握手，在第一次握手中，客户端发送SYN报文丢失了怎么办？" class="headerlink" title="TCP三次握手，在第一次握手中，客户端发送SYN报文丢失了怎么办？"></a>TCP三次握手，在第一次握手中，客户端发送SYN报文丢失了怎么办？</h2><p>客户端想和服务器建立连接，向服务器发送SYN报文，如果客户端一直收不到服务器的响应，就会触发超时重传机制，重传SYN报文（重传的seq序列号是一样的）如果达到最大重传次数，客户端就不再发送SYN报文，随后断开TCP连接</p><h2 id="TCP三次握手，在第二次握手中，服务器的SYN-ACK报文丢失了怎么办？"><a href="#TCP三次握手，在第二次握手中，服务器的SYN-ACK报文丢失了怎么办？" class="headerlink" title="TCP三次握手，在第二次握手中，服务器的SYN + ACK报文丢失了怎么办？"></a>TCP三次握手，在第二次握手中，服务器的SYN + ACK报文丢失了怎么办？</h2><ol><li><p>因为第二次握手的ACK报文代表对第一次握手的确认，如果客户端没有收到第二次握手，会认为自己第一次握手的SYN报文丢失，客户端就会触发超时重传机制，重传SYN报文。如果达到最大重传次数，客户端就会断开连接。</p></li><li><p>如果第二次握手丢失，服务器收不到第三次握手，服务器这里也会触发超时重传机制，重传SYN+ACK报文，如果达到最大重传次数，服务器就会断开连接。</p></li></ol><h2 id="第一次握手，客户端发送SYN报文，第二次握手，服务器回复SYN-ACK报文，这个过程中服务器做了什么？"><a href="#第一次握手，客户端发送SYN报文，第二次握手，服务器回复SYN-ACK报文，这个过程中服务器做了什么？" class="headerlink" title="第一次握手，客户端发送SYN报文，第二次握手，服务器回复SYN+ACK报文，这个过程中服务器做了什么？"></a>第一次握手，客户端发送SYN报文，第二次握手，服务器回复SYN+ACK报文，这个过程中服务器做了什么？</h2><p>第二次握手：服务器收到客户端的SYN请求后，会把该连接存储到<strong>半连接队列</strong>，并向客户端发送SYN+ACK</p><p>第三次握手：客户端收到后，会发ACK报文给服务器，服务器收到第三次握手的ACK后，内核会把连接从半连接队列中移除，然后创建新的完全的连接，并添加到<strong>全连接队列</strong>，等待进程调用accept函数把连接从全连接队列中取出来。</p><blockquote><p>如果有大量的SYN数据包从客户端发往服务器，会导致服务器那边的半连接队列满了，后续在收到SYN数据包就会丢弃。</p></blockquote><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\4cd156e34d454a50bdf4d6e1ee426c76.png" alt="4cd156e34d454a50bdf4d6e1ee426c76.png"></p><ol><li>客户端主动关闭连接，发送FIN报文，代表客户端已经不会发送数据了，客户端进入FIN_WAIT_1状态</li><li>服务器收到SYN报文，回复ACK确认报文，此时服务器进入CLOSE_WAIT状态</li><li>此时服务器如果有数据要发送，就需要发送完数据才能关闭连接；如果没有数据要发送，就可以直接关闭连接。</li><li>服务器发完剩余的数据后，发送FIN报文，代表服务器也不会发送数据，此时服务器进入LAST_ACK状态</li><li>客户端收到FIN报文后，发送ACK确认报文给服务器，客户端此时进入TIME_WAIT状态</li><li>服务器收到ACK确认后，也进入CLOSE状态</li><li>客户端经过2MSL时间后，也进入CLOSE状态</li></ol><h2 id="为什么四次挥手中间两次不能变成一次？"><a href="#为什么四次挥手中间两次不能变成一次？" class="headerlink" title="为什么四次挥手中间两次不能变成一次？"></a>为什么四次挥手中间两次不能变成一次？</h2><p>因为服务器收到客户端的FIN报文时，需要立马响应ACK，但是此时服务器可能还有数据没有发完，所以不能马上发送FIN报文。因此四次挥手时，服务器的ACK和FIN一般都是分两次发送的。</p><blockquote><p>第二次和第三次挥手之间，客户端不能发送数据，但是可以接收服务器还没发完的数据</p></blockquote><h2 id="断开连接时客户端FIN包丢失（第一次挥手不成功），服务器的状态是什么？"><a href="#断开连接时客户端FIN包丢失（第一次挥手不成功），服务器的状态是什么？" class="headerlink" title="断开连接时客户端FIN包丢失（第一次挥手不成功），服务器的状态是什么？"></a>断开连接时客户端FIN包丢失（第一次挥手不成功），服务器的状态是什么？</h2><p>客户端向服务器发送FIN报文，如果发送的FIN报文丢失，客户端收不到服务器的ACK确认，就会触发超时重传机制，重传FIN报文，如果达到最大重传次数，客户端就会直接进入CLOSE状态，而服务器还是established状态。</p><h2 id="为什么四次挥手要等2MSL？"><a href="#为什么四次挥手要等2MSL？" class="headerlink" title="为什么四次挥手要等2MSL？"></a>为什么四次挥手要等2MSL？</h2><p>MSL是报文最大生存时间，超过这个时间报文会被丢弃，因为TCP报文是基于IP协议，IP头有一个TTL字段（是IP数据包可以经过的最大路由跳数）</p><blockquote><p>MSL的单位是时间，TTL是经过路由跳数，所以MSL应该大于等于TTL消耗为0的时间，保证报文已经被自然消亡。</p></blockquote><p>等待2MSL，主要是因为网络中可能存在发送方的报文，这些发送方的数据包被接收方处理后，又会向对方发送响应。（一来一回需要等待2倍时间）</p><blockquote><p>如果服务器没有收到客户端最后的ACK报文，那么就会触发服务器的超时重传，服务器会重新发送FIN报文，一来一回正好2MSL（相当于至少允许报文丢失一次）</p></blockquote><h2 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h2><ol><li>TCP面向连接，UDP无连接</li><li>TCP一条链路只能由两个端点；UDP支持一对一、一对多、多对多</li><li>TCP可靠交付数据；UDP尽最大努力交付（基于UDP传输协议实现一个可靠的传输协议：QUIC协议）</li><li>TCP有流量控制和拥塞控制；UDP没有，即使网络拥堵，也不会影响UDP的发送速率</li><li>TCP首部较长（20字节），长度不固定；UDP首部只有8字节，固定不变，开销小。</li><li>TCP是流式传输，没有边界，但是要保证顺序和可靠；UDP是一个个包发送，有边界，可能会出现丢包和乱序。</li></ol><h2 id="TCP为什么可靠传输？"><a href="#TCP为什么可靠传输？" class="headerlink" title="TCP为什么可靠传输？"></a>TCP为什么可靠传输？</h2><ol><li>连接管理：三次握手、四次挥手建立可靠连接</li><li>序列号：既能保证可靠性，又能防止数据丢失，还能避免数据重复。</li><li>确认应答：接收方收到数据后，会发送ACK确认报文，报文中也会携带此次确认的序列号，如果未发送确认报文，就会触发超时重传机制。</li><li>超时重传：<ul><li>数据包丢失：指定时间内，发送方未收到确认应答，就会启动超时重传</li><li>确认包丢失：接收方收到重复数据时丢弃，并重新回传ACK确认报文</li></ul></li><li>流量控制：根据接收方处理能力，来决定发送发的发送速度（在TCP报文首部维护一个滑动窗口实现）</li><li>拥塞控制：当网络拥堵时需要减少数据发送（通过发送端维护一个拥塞窗口实现）</li></ol><h2 id="TCP粘包问题？"><a href="#TCP粘包问题？" class="headerlink" title="TCP粘包问题？"></a>TCP粘包问题？</h2><p>粘包问题主要是不知道用户消息的边界在哪，如果知道边界在哪，就可以通过边界来划分出有效的用户信息。</p><ol><li>固定长度的消息【少用】：每个用户消息都是固定的（比如规定消息的长度是64字节，当接收方收到64个字节的数据，就会认为这个内容是一个完整的消息）</li><li>特殊字符作为边界：在两个用户的消息之间插入一个特殊字符，接收方收到数据后，读取到这个特殊字符，就认为已经读到了一个完整的消息。</li></ol><blockquote><p>如果消息里正好有这个字符，需要对消息里的字符做转义</p></blockquote><ol start="3"><li>自定义消息结构（包头 + 数据）：包头大小固定，包头里有个字段是用来说明随后的数据有多大。接收方收到包头后，先解析包头的内容，得到数据的长度，然后接下来就继续读取数据，直到读满数据长度。</li></ol><h2 id="TCP的拥塞控制？"><a href="#TCP的拥塞控制？" class="headerlink" title="TCP的拥塞控制？"></a>TCP的拥塞控制？</h2><p>在网络出现拥堵的情况，如果发送大量的数据包，会导致数据包丢失，这时TCP就会触发重传机制，导致网络的负担更重，就会进入恶性循环。</p><p>拥塞控制就是避免发送方的数据填满整个网络。</p><p>发送方会维护一个拥塞窗口，拥塞窗口会根据网络的拥塞程度动态变化。</p><p>发送窗口&#x3D; min(拥塞窗口, 接收窗口)</p><p>拥塞控制的四个算法：</p><ol><li>慢启动：发送方每收到一个ACK，拥塞窗口 + 1（指数增加）<ul><li>当拥塞窗口达到<strong>慢启动门限</strong>，就会使用拥塞避免算法</li></ul></li><li>拥塞避免：发送方每收到一个ACK，拥塞窗口 + 1&#x2F;拥塞窗口（线性增长）</li><li>拥塞发生：当网络出现拥塞时（发生数据包重传时），就会触发重传机制<ul><li>超时重传：<strong>慢启动门限</strong>设置为当前拥塞窗口的一半，拥塞窗口直接设置为1</li><li>快重传：拥塞窗口设置为原来的一半，<strong>慢启动门限</strong>等于当前拥塞窗口，进入快恢复</li></ul></li><li>快恢复（一般和快重传同时使用）</li></ol><h1 id="网络场景"><a href="#网络场景" class="headerlink" title="网络场景"></a>网络场景</h1><h2 id="打开百度首页后发生了什么"><a href="#打开百度首页后发生了什么" class="headerlink" title="打开百度首页后发生了什么"></a>打开百度首页后发生了什么</h2><ol><li><p>解析URL：检查URL中是否出现了非法字符，对非法字符进行转义后处理</p></li><li><p>缓存判断：判断请求的资源是否在缓存里，如果在缓存里且没有失效，就会直接使用；如果失效会进行DNS解析</p></li><li><p>DNS解析：如果资源不在缓存里，就进行DNS解析，先查询本地域名服务器，如果本地域名服务器能找到对应的ip地址，就返回；如果找不到，本地域名服务器就会分别迭代查询顶级域名服务器、根域名服务器、权威域名服务器，最后在权威域名服务器中找到ip地址返回</p></li><li><p>获取MAC地址：当浏览器得到ip地址后，数据传输还需要直到主机的MAC地址。</p><ul><li>因为应用层数据会往下传递给传输层</li><li>在传输层又会下发给网络层</li><li>网络层会将本机地址作为源地址，获取的ip地址作为目的地址，然后下发给数据链路层</li><li>数据链路层需要得到双方的MAC地址，本机的MAC地址作为源地址，目的MAC地址需要分两种情况：<ul><li>如果源ip地址和目的ip地址在同一个子网下，可以使用ARP协议直接获取到目的主机的MAC地址</li><li>如果源ip地址和目的ip地址不在同一个子网下，就将请求交给网关，由网关代为转发，也是通过ARP协议获取网关的MAC地址，此时目的MAC地址就是网关的MAC地址</li></ul></li></ul></li><li><p>建立TCP连接：</p><ul><li>使用目标IP地址和目标MAC地址发送SYN报文，请求建立TCP连接</li><li>然后由路由器转发到目标服务器后，目标服务器恢复SYN_ACK报文</li><li>客户端收到后，发送ACK包，表示收到服务器的确认，TCP连接建立完成</li></ul><blockquote><p>如果使用的是HTTPS协议，在TCP三次握手之前，还存在TLS的四次握手</p></blockquote></li><li><p>发送数据：浏览器会向服务器发送HTTP请求</p></li><li><p>服务器响应数据：服务器收到请求后，会根据请求的内容做处理后响应数据</p></li><li><p>浏览器结束后，主动发送FIN报文，随后进入四次挥手。</p><ul><li>浏览器主动发送FIN报文，表示要断开连接</li><li>服务器收到后，先返回ACK，表示收到浏览器的断开请求</li><li>服务器继续发送剩余的数据，发送完毕后，服务器也发送一个FIN报文，表示服务器这里也发完了，也断开连接</li><li>浏览器收到服务器的断开请求后，发送ACK报文，表示已收到，四次挥手结束。</li></ul></li></ol><h2 id="怎么判断两个服务器之间是正常连接的？"><a href="#怎么判断两个服务器之间是正常连接的？" class="headerlink" title="怎么判断两个服务器之间是正常连接的？"></a>怎么判断两个服务器之间是正常连接的？</h2><p>TCP保活机制：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP保活机制就会起作用，每个一段时间就会发送一个探测报文，如果探测报文没有得到响应，认为TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><h2 id="服务器ping不通，但是http可以请求成功是为什么？"><a href="#服务器ping不通，但是http可以请求成功是为什么？" class="headerlink" title="服务器ping不通，但是http可以请求成功是为什么？"></a>服务器ping不通，但是http可以请求成功是为什么？</h2><p>ping走的是icmp协议，http走的是tcp协议</p><p>可能是服务器的防火墙禁止icmp协议，但是没有禁止tcp协议。</p><h1 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h1><h2 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h2><p>分布式拒绝服务（DDOS）攻击是通过大规模互联网流量淹没目标服务器，以破坏目标服务器的恶意行为。</p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>如果一个用户输入了一个字符串来查找特定的用户信息，但是应用程序将这个用户的数据直接作为SQL查询的一部分，而不考虑可能的安全问题，那么攻击者可能会利用这一点来执行他们的恶意SQL查询。</p><h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p>攻击者诱导用户执行恶意操作，从而获取用户数据或执行恶意代码。通过伪造一个合法的HTTP请求来实现。</p><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>通过在web页面插入恶意脚本代码，诱使用户访问该页面，使得恶意脚本在用户浏览器中执行，从而盗取用户信息。</p><h2 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h2><p>攻击者在用户查询DNS服务器时篡改响应，将用户请求的域名映射到攻击者控制的虚假IP地址上，让用户误以为时正常的网站，实际上被重定向到攻击者操控的恶意网站。</p>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【复习】操作系统</title>
      <link href="/post/da519849.html"/>
      <url>/post/da519849.html</url>
      
        <content type="html"><![CDATA[<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><h2 id="用户态和内核态的区别？"><a href="#用户态和内核态的区别？" class="headerlink" title="用户态和内核态的区别？"></a>用户态和内核态的区别？</h2><ul><li>内核态：CPU可以执行所有的指令和访问所有的硬件资源，操作具有更高的权限，主要基于操作系统内核运行</li><li>用户态：CPU只能执行部分指令集，无法直接访问硬件资源，操作权限较低，主要用于运行用户程序</li></ul><h2 id="为什么要分为用户态和内核态？"><a href="#为什么要分为用户态和内核态？" class="headerlink" title="为什么要分为用户态和内核态？"></a>为什么要分为用户态和内核态？</h2><ol><li>安全性：通过对权限的划分，用户程序无法直接访问硬件资源，避免恶意程序对系统资源造成的破坏</li><li>稳定性：用户程序出现问题，不会影响到整个系统</li><li>隔离性：使得操作系统内核与用户程序之间有明确的边界，有利于系统的模块化和维护。</li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h2><ol><li>进程是操作系统分配<strong>资源</strong>（虚拟内存、文件句柄、信号量…）的基本单位，线程是任务调度的基本单位</li><li>进程切换会有较大的开销；线程切换开销较小</li><li>进程中如果某个线程崩溃了，可能整个进程都会崩溃</li><li>系统在运行时，会为每个进程分配资源；对线程而言，系统不会为线程分配内存，线程的资源来源于进程</li></ol><h2 id="进程、线程、协程的区别？"><a href="#进程、线程、协程的区别？" class="headerlink" title="进程、线程、协程的区别？"></a>进程、线程、协程的区别？</h2><ol><li>进程：操作系统分配资源的基本单位，拥有自己独立的内存空间，每个进程都有独立的堆和栈，不与其他进程共享。稳定性和安全性较高，但是上下文切换的开销较大</li><li>线程：CPU调度的基本单位，线程共享进程的内存空间，线程之间通信更高效，因为它们可以直接读取共享内存。线程上下文切换开销小，因为只需要保存和恢复线程的上下文。</li><li>协程：用户态的轻量级线程，调度完全由用户程序控制，不需要内核的参与。协程与其他协程共享堆内存，协程的切换开销非常小，因为只需要保存和恢复协程的上下文，无需进程内核级的上下文切换。协程在处理大量并发任务时具有非常高的效率，需要程序员显示的进行调度和管理。</li></ol><h2 id="多线程和单线程的区别？"><a href="#多线程和单线程的区别？" class="headerlink" title="多线程和单线程的区别？"></a>多线程和单线程的区别？</h2><ol><li>多线程可以提高程序的运行效率，可以充分利用多核处理器的资源，同时处理多个任务，加快程序的执行速度</li><li>但是存在多线程数据竞争的问题，需要通过锁机制来保证线程的安全，增加了加锁开销的同时还可能会出现死锁。多线程消耗系统的资源，因为每个线程都需要占用一定的内存和处理时间。</li></ol><h2 id="多线程太多会引起什么问题？"><a href="#多线程太多会引起什么问题？" class="headerlink" title="多线程太多会引起什么问题？"></a>多线程太多会引起什么问题？</h2><p>多线程不是越多越好，过多的线程也会导致一定的问题。</p><ol><li>切换开销：线程的创建和销毁会消耗系统资源，如果创建太多线程，会占用大量的系统资源，导致系统负载过高，某个线程崩溃后可能会导致进程的崩溃。</li><li>死锁问题</li></ol><h2 id="进程切换和线程切换的区别？"><a href="#进程切换和线程切换的区别？" class="headerlink" title="进程切换和线程切换的区别？"></a>进程切换和线程切换的区别？</h2><p>进程切换的开销比线程切换的开销大。</p><p>线程共享统一进程的地址空间和资源，线程切换只涉及到线程的堆栈、寄存器、程序计数器等，不涉及进程别的资源，避免了进程切换时需要切换内存映射表等大量资源的开销。</p><h2 id="线程切换的步骤"><a href="#线程切换的步骤" class="headerlink" title="线程切换的步骤"></a>线程切换的步骤</h2><ol><li>上下文保存：当一个线程切换到另一个线程时，操作系统会先保存当前线程的上下文信息（程序计数器、堆栈指针、寄存器状态）</li><li>切换调度器：操作系统将执行权切换到调度器，调度器负责选择下一个要执行的线程，并根据调度算法做出决策。</li><li>上下文恢复：调度器选择下一个要执行的线程后，他会从线程保存的上下文信息中恢复线程的执行状态。</li><li>切换到新线程：调度器将执行权切换到新线程，使其开始执行。</li></ol><blockquote><p>TCB用来管理线程的数据结构，当发生线程的切换时，通过切换TCB来保存和恢复线程的上下文</p></blockquote><h2 id="线程的状态（五种）如何切换？"><a href="#线程的状态（五种）如何切换？" class="headerlink" title="线程的状态（五种）如何切换？"></a>线程的状态（五种）如何切换？</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\884354026fa1417aaf9f200631fd3e35.jpeg" alt="884354026fa1417aaf9f200631fd3e35.jpeg"></p><h2 id="进程间的通讯方式"><a href="#进程间的通讯方式" class="headerlink" title="进程间的通讯方式"></a>进程间的通讯方式</h2><ol><li><p>管道：</p><ul><li>匿名管道：通信方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要建立两个管道，只能存在父子关系的进程通信（通过pipe系统调用创建）</li><li>命名管道：需要在文件系统中创建一个类型为p的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。（基于文件系统）</li></ul><blockquote><p>对于管道来说，进程写入的数据都是缓存在内核中，另一个进程读取数据时也是从内核中获取</p></blockquote></li><li><p>消息队列：消息队列的消息体可以是用户自定义的数据类型，要求发送方与接收方的消息体的数据类型保持一致，每次数据的写入和读取都需要经过用户态和内核态之间的拷贝过程。</p></li><li><p>共享内存：直接分配一个共享内存，每个进程都可以直接访问，不需要陷入内核态和用户态之间的数据拷贝，这是最快的进程通信方式，但是带来了一个新的问题，多进程共同竞争共享数据资源会造成数据的混乱，所以就引入了信号量</p><ul><li>信号量不仅可以实现访问的互斥性，还可以实现进程间的同步（P、V操作）</li></ul><blockquote><p>区别信号量和信号：</p><ul><li>信号：异步通信机制，用来通知接收进程有某件事要发生，可以在应用进程和内核之间直接交互，但是这个通信机制是基于一台主机，要与不同主机的进程通信只能使用Socket通信</li></ul></blockquote></li></ol><h2 id="线程间的通讯方式？"><a href="#线程间的通讯方式？" class="headerlink" title="线程间的通讯方式？"></a>线程间的通讯方式？</h2><ol><li><p>互斥锁：在访问共享资源时堆互斥量进行加锁，访问完成后释放锁。对共享资源加锁以后，其他试图对这个资源加锁的线程将会被阻塞，直到当前线程释放该互斥锁。</p></li><li><p>条件变量：一个线程等待“条件变量的条件成立”而挂起；另一个线程使“条件成立”。一般条件变量总是和互斥锁结合在一起</p></li><li><p>自旋锁：在用户态完成加锁和解锁的操作，不会主动产生线程上下文切换，相比互斥锁来说快一点。先检查锁的状态，如果锁是空闲的，就将锁设置成当前线程持有，加锁失败的线程会一直忙等，直到它拿到锁。一般会将这两个步骤合并成一条原子指令，这样就保证这两个步骤是不可分割的</p></li><li><p>信号量：信号量表示资源的数量，是一种计数器，用来控制对共享资源的访问，有两个原子操作的系统调用函数来控制信号量（P 、V操作）</p></li><li><p>读写锁：读写锁适用于能明确区分读操作和写操作的场景，在读多写少的时候能够发挥出优势。</p></li></ol><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>先来先服务、短作业优先、高响应比优先、时间片轮转、最高优先级调度、多级反馈队列</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="为什么并发执行线程需要加锁？"><a href="#为什么并发执行线程需要加锁？" class="headerlink" title="为什么并发执行线程需要加锁？"></a>为什么并发执行线程需要加锁？</h2><p>主要是为了保护共享数据，防止出现“竞态条件”。</p><p>竞态条件：多个线程同时访问和操作同一块数据时，最终结果依赖于线程的执行顺序，可能会导致数据的不一致。</p><h2 id="自旋锁是什么"><a href="#自旋锁是什么" class="headerlink" title="自旋锁是什么"></a>自旋锁是什么</h2><p>自旋锁加锁失败后，线程会忙等，直到它拿到锁。在用户态完成加锁和解锁操作，不会产生线程的上下文切换。</p><p>先查看锁的状态，如果锁是空闲，就把锁设置成当前线程独有。（把这两条操作合并成一条原子指令）</p><blockquote><p>在单核CPU上，需要不断通过时钟中断一个线程获取其他线程，否则自旋锁在单CPU上无法使用，因为一个自旋的线程永不放弃CPU</p><p>当加锁失败后，“互斥锁”用线程切换来应对；“自旋锁”用忙等来应对</p><p>如果被锁住的代码执行时间很短，就可以选用自旋锁。</p></blockquote><h2 id="死锁的条件"><a href="#死锁的条件" class="headerlink" title="死锁的条件"></a>死锁的条件</h2><p>互斥条件、不可剥夺、循环等待、请求和保持</p><blockquote><p>可以通过使用资源有序分配法来破环循环等待的条件</p><p>线程A先获取A资源再获取B资源；线程B也是同样先获取A资源再获取B资源。线程A、B都应该以相同的顺序去获取自己想要的资源</p></blockquote><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>可以有效地避免死锁。</p><p>在分配资源前，先判断如果分配完资源后，能否让这个线程执行完后释放它所占用的资源，如果可以满足，则分配资源给该线程。</p><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>乐观锁：假设多个事务之间很少发生冲突，在读取数据时不会加锁，在更新数据时检查数据的版本，如果版本匹配则执行更新操作，否则就认为发生冲突（适用于读多写少的场景，可以减少锁的竞争）</p><p>悲观锁：假设多个事务之间会频发发生冲突，在读取数据时会加上锁，防止其他事务对数据进行修改，当前事务完成操作后才会释放锁（适用于写多的场景，通过加锁保证数据的一致性）</p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="操作系统的内存管理是什么？"><a href="#操作系统的内存管理是什么？" class="headerlink" title="操作系统的内存管理是什么？"></a>操作系统的内存管理是什么？</h2><p>操作系统设置了虚拟内存，每个进程都有自己独立的虚拟内存，程序不会直接和物理内存打交道。</p><ol><li>虚拟内存可以使进程对运行内存超过物理内存的大小（因为程序的局部性原理，对于不经常使用的内存，可以把它放到磁盘上）</li><li>每个进程都有自己的页表，每个进程的虚拟内存是独立的，解决了多进程之间地址冲突的问题</li><li>页表里的页表项除了一些物理地址外，还有一些标记属性的比特（比如控制一个页的读写权限，标记该页是否存在）</li></ol><blockquote><p>虚拟地址和物理地址之间是通过<strong>页表</strong>来进行映射的</p><p>页表存储在内存里。内存管理单元（MMU）：将虚拟内存地址转化为物理内存地址</p></blockquote><h2 id="什么是虚拟内存，什么是物理内存？"><a href="#什么是虚拟内存，什么是物理内存？" class="headerlink" title="什么是虚拟内存，什么是物理内存？"></a>什么是虚拟内存，什么是物理内存？</h2><ul><li>虚拟内存：操作系统给每个运行中的程序的一段地址空间，每个内存在运行时认为自己拥有的内存就是虚拟内存，虚拟内存将程序的地址空间划分成固定大小的页，并将这些页映射到物理内存中的不同位置。</li><li>物理内存：计算机实际存在的内存。</li></ul><h2 id="什么是页表？"><a href="#什么是页表？" class="headerlink" title="什么是页表？"></a>什么是页表？</h2><p>分页是把虚拟内存和物理内存空间切成一段段固定尺寸的大小，虚拟内存和物理内存是通过页表来进行映射的。</p><p>页表存储在内存里。</p><p>内存管理单元（MMU）：将虚拟内存地址转化为物理内存地址</p><p>当进程访问的虚拟地址在页表中不存在，就会产生缺页异常，操作系统会进行调页处理。</p><p>页和页之间是紧密排列的，不会有外部碎片；但是有时程序不足一页，也会给他分配一页，所以会有内部碎片。</p><blockquote><p>虚拟内存地址转成物理内存地址的步骤：</p><ol><li>当访问一个虚拟地址时，MMU会把虚拟内存地址划分成<strong>页号 + 页内偏移量</strong></li><li>MMU会根据<strong>页号</strong>，从页表里查询对应的<strong>物理页号</strong></li><li>MMU将<strong>物理页号+偏移量</strong>结合得到物理内存地址</li></ol></blockquote><h2 id="堆和栈的区别？"><a href="#堆和栈的区别？" class="headerlink" title="堆和栈的区别？"></a>堆和栈的区别？</h2><ul><li>分配方式：堆是动态分配内存，由程序员手动申请和释放，用来存储动态数据结构和对象；栈是静态分配内存，由编译器自动分配和释放，用于存储函数的局部变量。</li><li>内存管理：堆内存需要程序员手动管理内存的分配和释放，管理不当可能会出现内存泄漏；栈由编译器自动管理内存，变量的声明周期由作用域决定</li><li>大小和速度：堆比栈内存空间较大，动态分配和释放需要时间开销；栈大小有限，内存分配和释放较快。</li></ul><h2 id="操作系统内存不足时会发生什么？"><a href="#操作系统内存不足时会发生什么？" class="headerlink" title="操作系统内存不足时会发生什么？"></a>操作系统内存不足时会发生什么？</h2><p>应用程序通过malloc函数申请内存时，实际上申请的是虚拟内存，此时不会分配物理内存。</p><ol><li>CPU去访问虚拟内存，如果虚拟内存没有映射到物理内存，就会产生缺页中断（从用户态变成内核态）</li><li>缺页中断处理函数会看是否有空闲的物理内存<ul><li>如果有：就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系</li><li>如果没有：就开始进行回收内存的工作（后台内存回收、直接内存回收）<ul><li>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，就会触发OOM机制，OOM机制会选择一个占用物理内存较高的进程杀死，直到释放足够的内存。</li></ul></li></ul></li></ol><blockquote><p>有两类内存是可以被回收的：</p><ol><li>文件页（内核缓存的磁盘数据、内核缓存的文件数据）：回收干净页的方式是直接释放内存；回收脏页的方式是先写回磁盘再释放内存<ul><li>大部分文件页都可以直接释放内存，以后有需要再从磁盘中读取即可。</li><li>被应用程序修改过，还没写回磁盘的数据，需要先写回磁盘，再进行内存释放</li></ul></li><li>匿名页：没有实际的载体，这部分内存可能还要被再次访问，不能直接释放内存，回收的机制是通过Swap机制，把不经常访问的内存写入磁盘，然后释放内存，给其他更需要的进程使用</li></ol></blockquote><p>文件页和匿名页都是基于LRU算法，优先回收不经常访问的页。</p><h2 id="页面置换算法有哪些？"><a href="#页面置换算法有哪些？" class="headerlink" title="页面置换算法有哪些？"></a>页面置换算法有哪些？</h2><p>最佳页面置换算法、先进先出置换算法、最近最久未使用（LRU）、时钟页面置换算法、最不常使用算法（LFU）</p><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="什么是中断？"><a href="#什么是中断？" class="headerlink" title="什么是中断？"></a>什么是中断？</h2><p>中断使得计算机具备应对突发事件的能力，提高了CPU的工作效率，如果没有中断，CPU只能按照原来的程序来运行，轮询查询各个外设操作，工作效率低且不能响应紧急事件。</p><p>CPU停下当前的工作，去处理其他事情，处理完后回来继续执行刚才的任务。</p><ul><li>外部中断（来源于CPU外部）<ul><li>可屏蔽中断：主要来自外部设备（硬盘、打印机、网卡…），不会影响系统运行，可以后边再处理。</li><li>不可屏蔽中断（电源掉电、硬件线路故障…）</li></ul></li><li>内部中断（来源于CPU内部）<ul><li>陷阱：有意的、故意安排的异常事件。（print函数，底层的实现中会有一条中断指令，这就是陷阱指令，接下来会使用中断进行系统调用）</li><li>故障：如果能处理这个错误，就将程序返回到引起故障的指令，不能处理就报错（缺页，将缺失的物理页从磁盘中重新调入内存，再次执行引起故障的指令便可正常运行）</li><li>终止：执行过程中发生了致命错误，不可修复。（不会将控制返回原程序，而是直接终止源程序）</li></ul></li></ul><h2 id="中断的流程？"><a href="#中断的流程？" class="headerlink" title="中断的流程？"></a>中断的流程？</h2><ol><li>发生中断：当外部设备需要处理器的响应时，就会发生中断信号，处理器在收到中断信号后，就会停止当前执行的指令，保存当前执行的现场（程序计数器、寄存器状态..），跳转到中断处理程序中执行</li><li>中断响应：处理器接收到中断信号后，会从中断向量表中找到对应中断程序入口的地址。</li><li>中断处理：处理器跳到中断程序入口地址后开始执行中断处理程序，中断处理程序会根据终端类型进行相应处理。处理完毕后回到原程序继续执行</li></ol><h1 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h1><h2 id="有什么IO模型？"><a href="#有什么IO模型？" class="headerlink" title="有什么IO模型？"></a>有什么IO模型？</h2><ul><li>阻塞IO模型：应用程序发起IO操作会被阻塞，操作完成后才返回结果</li><li>非阻塞IO模型：应用程序发起IO操作后立即返回，但是需要不断轮询来检查IO操作是否完成</li><li>IO复用模型：应用程序可以同时等待多个IO操作，当其中任何一个IO操作准备就绪时，应用程序会被通知</li><li>信号驱动IO模型：应用程序发起IO操作后，可以继续做其他事，当IO操作完成后，操作系统向应用程序发送信号来通知其完成</li><li>异步IO模型：应用程序发起IO操作后可以立即做其他事，等IO操作完成时，应用程序会得到通知</li></ul><h2 id="服务器处理并发请求有哪几种方式？"><a href="#服务器处理并发请求有哪几种方式？" class="headerlink" title="服务器处理并发请求有哪几种方式？"></a>服务器处理并发请求有哪几种方式？</h2><ol><li>单线程web服务器方式：web服务器一次处理一个请求，请求结束后读取并处理下一个请求</li><li>多进程&#x2F;线程web服务器：web服务器生成多个进程或线程并行处理用户请求，但是一旦并发请求数量达到成千上万时，会消耗大量的系统资源。</li><li>IO多路复用web服务器：web服务器可以IO多路复用，达到只用一个线程就能监听和处理多个客户端的IO事件</li><li>多路复用多线程web服务器：有多个进程，一个进程里又有多个线程，一个线程处理一个请求</li></ol><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>复用一个线程，处理多个socket中的事件，能够资源复用，防止创建过多的线程导致上下文切换的开销。</p><h2 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h2><p>传统的IO工作方式：从磁盘中读取数据，通过网卡向外发送（需要4次上下文切换，4次数据拷贝【2次由DMA完成，2次由CPU完成】）</p><p>零拷贝技术：通过一次系统调用合并了磁盘读取和网络发送的操作，降低了上下文切换次数（只需要2次上下文切换，2次数据拷贝【2次的数据拷贝都是由CPU完成】）</p>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【复习】Spring</title>
      <link href="/post/49caf527.html"/>
      <url>/post/49caf527.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring架构的核心？"><a href="#Spring架构的核心？" class="headerlink" title="Spring架构的核心？"></a>Spring架构的核心？</h2><ol><li>IOC容器：开发者只需要定义Bean和依赖关系，Spring容器就可以创建和组装对象</li><li>AOP：面向切面编程，允许开发者定义横切关注点，通过AOP可以将这些关注点模块化，提高代码的可维护性</li><li>事务管理：支持声明式和编程式，轻松的进行事务管理，无需关系具体的事务API</li><li>MVC框架：支持URL到页面控制器的映射</li></ol><blockquote><p>IOC：控制反转，创建和获取对象的思想，传统的开发需要使用new关键字来创建对象，如果使用IOC思想的话，我们可以通过IOC容器帮我们实例化对象</p><p>AOP：面向<strong>切面</strong>编程，将与业务无关的代码封装起来，减少系统的重复代码，降低模块间的耦合度。AOP的底层是动态代理，如果要代理的对象实现了某个接口，那么AOP就会使用<strong>JDK动态代理</strong>去创建代理对象；对于没有实现接口的对象，就无法使用<strong>JDK动态代理</strong>去代理了，这时候AOP就会使用<strong>Cglib</strong>生成一个被代理对象的子类来作为代理</p><ul><li>通过IOC管理容器对象的依赖关系，然后通过AOP将横切关注点统一注入需要的业务逻辑中</li><li>使用IOC容器管理Service和Mapper层的关系，通过AOP在Service实现事务管理、日志记录等横切操作。</li></ul></blockquote><h2 id="IOC和AOP是通过什么机制实现的？"><a href="#IOC和AOP是通过什么机制实现的？" class="headerlink" title="IOC和AOP是通过什么机制实现的？"></a>IOC和AOP是通过什么机制实现的？</h2><ol><li>IOC容器利用<strong>反射</strong>动态加载类、创建对象实例、调用对象方法，反射允许在运行时检查类、方法、属性等信息</li><li>AOP是<strong>依赖注入</strong>，容器负责管理应用程序组件之间的依赖关系（构造函数注入、属性注入、方法注入）</li><li>IOC容器采用<strong>工厂模式</strong>来管理对象的创建和生命周期，容器作为工厂负责实例化Bean并管理他们的生命周期，将Bean的实例化过程交给容器来管理</li><li>通常使用BeanFactory 或 ApplicationContext来管理Bean（<strong>BeanFactory</strong>是IOC容器的基本形式；<strong>ApplicationContext</strong>是BeanFactory的扩展）</li></ol><h2 id="AOP的实现机制"><a href="#AOP的实现机制" class="headerlink" title="AOP的实现机制"></a>AOP的实现机制</h2><p>AOP基于动态代理，在运行时动态生成代理对象。允许开发者在运行时指定代理对象的接口和行为。</p><p>动态代理是一种在运行时动态代理对象的机制，用于在不修改原始类的情况下对方法调用进行拦截和增强。</p><ul><li>基于JDK的动态代理：使用java.lang.reflect.Proxy类 和 java.lang.reflect.InvocationHandler接口实现，需要代理的类实现一个多或多个接口。每个动态代理都必须实现InvocationHandler接口，并且每个代理的实例都关联到一个handler。当通过代理对象调用一个方法时，这个方法的调用就会被转发为由InvocationHandler接口的invoke()方法来进行调用。</li><li>基于CGLIB的动态代理：当被代理的类没有实现接口时，会使用CGLIB生成一个被代理的子类作为代理（CGLIB是一个第三方代码生成库，通过继承方式实现代理）</li></ul><blockquote><p>AOP的目的是对面向对象思维的补充。</p><p>AOP更像是对不支持多继承的弥补，除开对象的主要特征（”强共性“）被抽象成一条继承链路，对于”弱共性“，AOP可以统一对他们进行抽象和集中处理。</p></blockquote><h2 id="怎么理解IOC？"><a href="#怎么理解IOC？" class="headerlink" title="怎么理解IOC？"></a>怎么理解IOC？</h2><p>IOC：控制反转，是一种设计思想，传统的javase是通过new的方式创建对象，是程序主动创建依赖对象</p><ul><li>创建对象：原来是new，现在是spring容器创建</li><li>初始化对象：原来是对象自己通过构造器 或 setter方法赋值，现在是spring容器自动注入</li><li>销毁对象：原来是直接给对象赋null或执行一些销毁操作，现在是spring容器管理生命周期负责销毁对象</li></ul><h2 id="AOP常用注解"><a href="#AOP常用注解" class="headerlink" title="AOP常用注解"></a>AOP常用注解</h2><ul><li>@Aspect：定义切面，标注在切面类上</li><li>@Pointcut：定义切点，标注在方法上，用于指定连接点</li><li>@Before：方法执行之前通知</li><li>@After：方法执行之后通知</li><li>@Around：方法执行前后都通知</li><li>@AfterReturning：方法执行后返回结果后通知</li><li>@AfterThrowing：方法抛出异常后通知</li><li>@Advice：通知的类型，可以替代@Befort、@After</li></ul><h2 id="什么是反射？有什么应用场景？"><a href="#什么是反射？有什么应用场景？" class="headerlink" title="什么是反射？有什么应用场景？"></a>什么是反射？有什么应用场景？</h2><p>在程序运行的状态下，任何一个类，都可以获取这个类的所有属性和方法；任何一个对象，都可以调用它的任意属性和方法。反射允许在运行时获取类的信息并动态操作对象。</p><ul><li>反射允许程序在运行时获取类的完整结构信息</li><li>通过反射API动态的创建对象实例</li><li>在运行时动态地调用对象的方法</li><li>允许运行时访问和修改对象的字段值</li></ul><blockquote><ol><li>依赖注入：开发者通过xml配置文件或注解的方式声明组件之间的依赖关系，程序启动时，spring容器会扫描这些配置或注解，利用反射来实例化Bean</li><li>动态代理的实现：AOP，允许开发者自定义切面，而不需要修改业务逻辑代码。</li></ol></blockquote><h2 id="Spring解决循环依赖"><a href="#Spring解决循环依赖" class="headerlink" title="Spring解决循环依赖"></a>Spring解决循环依赖</h2><p>三种循环依赖的情况：</p><ol><li>通过构造方法进行依赖注入时产生的循环依赖问题</li><li>通过setter方法进行依赖注入且在多例模式下产生的循环依赖问题</li><li>通过setter方法进行依赖注入切实在单例模式下产生的循环依赖问题</li></ol><blockquote><p>只有第三种循环依赖被spring解决了，其他两种在遇到循环依赖问题是，spring都会产生异常。</p></blockquote><p>实现步骤：</p><ol><li>实例化Bean：在实例化Bean时会创建一个空的Bean对象，存入一级缓存中</li><li>属性赋值：开始对Bean进行属性赋值，如果发现循环依赖，会把当前Bean对象提前暴露给后续需要依赖的Bean（通过提前暴露的方式解决循环依赖）</li><li>初始化Bean：完成属性赋值后，将Bean进行初始化，并将其放入二级缓存中</li><li>注入依赖：继续对Bean机械能依赖注入，如果发现循环依赖，就从二级缓存中获取以及完成初始化的Bean实例。</li></ol><p>使用了三级缓存解决循环依赖（三个Map）：</p><blockquote><p>一级缓存：存储完整的Bean</p><p>二级缓存：已经被实例化，但是还没完全初始化的Bean。避免在多重循环依赖（A依赖B，A依赖C）的情况下重复创建动态代理</p><p>三级缓存：</p><ul><li>缓存的是函数接口，lambda表达式把方法传进去（把Bean的实例和Bean的名字传进去）</li><li>AOP创建</li><li>不会立即调用（会在第二次getBean(A)时才会调用三级缓存&#x3D;&gt;创建动态代理），如果在实例化后立即调用BeanA，而不去管BeanA的循环依赖问题，那么所有的Bean都会在实例化的时候调用动态代理，Spring还是希望在初始化的时候创建动态代理</li></ul></blockquote><ol><li>创建BeanA，如果一级缓存中有BeanA，就直接返回</li><li>实例化BeanA，保存到三级缓存中</li><li>对BeanA属性赋值，发现依赖BeanB，就去一级缓存中找BeanB。</li><li>发现一级缓存没有BeanB，就把BeanB也加入三级缓存</li><li>对BeanB属性赋值，发现依赖BeanA，就去<strong>一级缓存</strong>中找BeanA；继续去<strong>二级缓存</strong>找，也没有；继续去<strong>三级缓存</strong>中找BeanA，发现BeanA在三级缓存中，创建动态代理，把BeanA放入二级缓存（避免重复创建）</li><li>BeanB的属性BeanA赋值成功，就把BeanB放入一级缓存中，移除掉BeanB的二三级缓存</li><li>把BeanB的完整对象返回给BeanA，BeanA里的属性BeanB就已经赋值结束，BeanA也成功返回</li></ol><h2 id="Spring的注解"><a href="#Spring的注解" class="headerlink" title="Spring的注解"></a>Spring的注解</h2><p>@Autowired、@Component、@Configuration、@Bean、@Service、@Repository、@Controller</p><h2 id="Spring的事务什么时候会失效？"><a href="#Spring的事务什么时候会失效？" class="headerlink" title="Spring的事务什么时候会失效？"></a>Spring的事务什么时候会失效？</h2><ol><li>一个事务方法发生未捕获的异常，异常未被处理或传播到事务边界之外</li><li>事务传播属性设置不当：多个事务之间存在事务嵌套，事务传播属性配置不正确，导致事务失效</li><li>多数据源的事务管理：事务管理没有正确配置或存在多个@Transactional注解时</li><li>跨方法调用事务：一个事务内部调用另一个方法，这个被调用的方法没有@Transactional注解，外层事务可能失效</li><li>事务在非public的方法中会失效</li></ol><h2 id="Bean是否单例？"><a href="#Bean是否单例？" class="headerlink" title="Bean是否单例？"></a>Bean是否单例？</h2><p>Bean默认都是单例的，每个Bean的实例只会被创建一次，并存储在Spring容器的缓存中，便于在后续的请求中重复使用。</p><p>也可以通过设置scope属性为prototype来将Bean设置为多例模式</p><blockquote><p>如果Bean单例是有状态的，可以在使用时考虑线程安全问题。</p></blockquote><h2 id="在bean加载-销毁前后，如果想要实现某些逻辑，怎么做？"><a href="#在bean加载-销毁前后，如果想要实现某些逻辑，怎么做？" class="headerlink" title="在bean加载&#x2F;销毁前后，如果想要实现某些逻辑，怎么做？"></a>在bean加载&#x2F;销毁前后，如果想要实现某些逻辑，怎么做？</h2><ol><li><p>在xml配置中，通过init-method 和 destory-method属性来指定Bean初始化后和销毁前需要调用的方法</p></li><li><p>实现InitializingBean 和 DisposableBean接口，并分别实现afterPropertiesSet()和destory()方法</p></li><li><p>使用@PostConstruct和@PreDestory注解</p></li><li><p>使用@Bean的initMethod和destoryMethod属性</p></li></ol><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="MVC分层？"><a href="#MVC分层？" class="headerlink" title="MVC分层？"></a>MVC分层？</h2><ul><li>视图（view）：为用户提供使用界面</li><li>模型（model）：代表一个存储数据的对象（pojo），可以带有逻辑，主要用于承载数据，并对用户提交请求进行计算的模块。（分为业务处理Bean【Service、Mapper】、数据承载Bean【User类】）</li><li>控制器（controller）：把用户的请求转发给model处理，并根据model的计算结果向用户提供相应响应。</li></ul><p><img src="D:\project\kaiFa\Blog\source_posts\assets\c5bd467e69d942eab1d74acdadec6495.jpeg" alt="c5bd467e69d942eab1d74acdadec6495.jpeg"></p><ol><li>用户通过view向页面服务器发请求</li><li>服务端controller收到请求后对请求进行解析，找到对应的model后，将请求交给model处理</li><li>将处理结果再交给controller</li><li>根据处理结果返回给view，页面选然后发给用户</li></ol><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><p>SpringBoot自动装配原理是基于Spring的条件话配置和@EnableAutoConfiguration注解实现的，允许开发者在项目中引入相关的依赖，根据这些以来自动配置应用程序的上下文和功能。</p><p>SpringBoot在启动时会扫描外部引用jar包中的META-INF&#x2F;spring.factories文件，将文件中的配置信息加载到Spring容器中，并执行类中的各种操作。对外部jar来说，只需要按照SpringBoot定义的标准，就能把自己的功能装配进SpringBoot</p><h2 id="SpringBoot的注解"><a href="#SpringBoot的注解" class="headerlink" title="SpringBoot的注解"></a>SpringBoot的注解</h2><p>@SpringBootApplication、@Controller、@RestController、@Service、@Repository、@Component、@Autowired、@Value、@RequestMapping、@GetMapping…、@Configuration</p><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="Mybatis里的-和-的区别？"><a href="#Mybatis里的-和-的区别？" class="headerlink" title="Mybatis里的#和$的区别？"></a>Mybatis里的#和$的区别？</h2><ul><li>处理#{}时，会创建预编译的SQL语句，将SQL中的#{}替换成?，在执行SQL时会为预编译SQL中的占位符（?）赋值，预编译的SQL语句执行效率高，也可以防止SQL注入</li><li>处理&amp;{}时，只是创建简单的SQL语句，在执行SQL语句时，先将参数直接拼到SQL里，不能防止SQL注入，因为参数是直接拼接到SQL语句中的，如果参数未经过验证，可能会产生安全问题。</li></ul><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="SpringCloud和SpringBoot的区别？"><a href="#SpringCloud和SpringBoot的区别？" class="headerlink" title="SpringCloud和SpringBoot的区别？"></a>SpringCloud和SpringBoot的区别？</h2><p>SpringBoot是用于构建单个Spring应用的框架，SpringCloud是用于构建分布式文件系统中微服务架构的工具（提供了服务注册与发现、负载均衡、断路器、网关等）</p><p>通过SpringBoot构建微服务应用，用SpringCloud来实现微服务架构中的各种功能。</p><p>常用的组件：</p><ol><li>注册中心（nacos）：解决了”如何发现新节点以及检查各节点运行状态的问题“</li><li>负载均衡：解决了”如何发现服务以及负载均衡如何实现“，微服务在调用时，先通过注册中心看看该服务拥有哪些节点，注册中心将可用的节点返回给服务调用者（服务发现）。因为服务高可用性的要求，服务调用者会接收到多个节点，必须从中进行选择，所以服务调用者必须内置负载均衡器。</li><li>服务通信：解决了”服务间如何进行消息通信的问题“，提供了Feign和RestTemplate两种技术屏蔽底层的实现细节</li><li>配置中心：解决了”如何集中管理个节点配置文件的问题“，通过部署配置中心服务器，将各节点配置文件从服务中剥离，集中转存到配置中心。</li><li>集中日志管理：解决了“如何收集个节点日志并统一管理”</li><li>服务保护：解决了“如何对系统进行链路保护，避免服务雪崩的问题”，微服务之间相互调用，如果某个微服务出现高延迟，就需要引入服务保护组件来实现微服务的快速降级。</li></ol><h2 id="如何实现一个用户的请求一直位于同一台服务器上"><a href="#如何实现一个用户的请求一直位于同一台服务器上" class="headerlink" title="如何实现一个用户的请求一直位于同一台服务器上"></a>如何实现一个用户的请求一直位于同一台服务器上</h2><p>通过“一致性哈希算法”来实现，根据请求的客户端ip通过哈希算法得到一个数值，利用该数值取模映射出对应的后端服务器，这样就能保证同一个客户端或想通参数的请求每次都使用同一台服务器。</p><h2 id="服务熔断和服务降级"><a href="#服务熔断和服务降级" class="headerlink" title="服务熔断和服务降级"></a>服务熔断和服务降级</h2><p>服务熔断：对微服务雪崩效应的一种链路保护机制。</p><blockquote><p>比如服务A调用B，B调用C。</p><p>如果C出现了问题，那么随着B发往C的请求不断增加，B也会出现问题；随着A发往B的请求不断增加，由于B无法给正确的响应，那么A也会出现问题。</p><p>所以当链路中某个微服务不可用或相应的时间太长，应该要进行服务熔断，不再有该节点微服务的调用，快速返回错误的相应信息。</p></blockquote><p>服务降级：在服务压力剧增的时候，根据业务使用情况对服务和页面有策略的不处理或采用一些简单的方式进行处理，从而<strong>释放服务器的资源以保证核心业务的正常高效运行</strong>。（舍小保大）</p><p>服务降级是从整个系统的负荷情况触发，对某些负荷比较高的情况，为了预防某些功能出现负荷过载或响应慢的情况，在内部暂时舍弃对一些非核心接口和数据的请求，而直接返回一个提前准备好的fallback处理错误信息，虽然提供的是一个有损的服务，但是却保证了整个系统的稳定性和可用性。</p>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【复习】Java集合</title>
      <link href="/post/3d566045.html"/>
      <url>/post/3d566045.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合概念"><a href="#集合概念" class="headerlink" title="集合概念"></a>集合概念</h1><h2 id="集合与数组"><a href="#集合与数组" class="headerlink" title="集合与数组"></a>集合与数组</h2><p>数组是固定长度；集合是动态长度的数据结构，需要动态增加或删除元素</p><p>数组可以包含基本数据类型和对象；集合只能包含对象</p><p>数组可以直接访问元素；集合需要通过迭代器访问元素</p><h2 id="线程安全的集合？"><a href="#线程安全的集合？" class="headerlink" title="线程安全的集合？"></a>线程安全的集合？</h2><p>java.util包：</p><ol><li>Vector：线程安全的动态数组，内部方法大部分都经过synchronized修饰</li><li>Hashtable：线程安全的哈希表，内部方法大部分都经过synchronized修饰，这样被所著的就是整个Table对象（底层是数组+链表）</li></ol><p>并发Map：</p><ol><li>ConcurrentHashMap：</li></ol><ul><li>JDK7，ConcurrentMap加的是分段锁（Segment锁），每个分段锁含有整个table的一部分，不同分段之间的并发互不影响【每个Segment都类似一个小的HashMap，对于插入、更新、删除操作时，需要先定位到具体的Segment，再在Segment上加锁】</li><li>JDK8，取消了Segment字段，直接在table元素上枷锁，实现对每一行进行加锁，进一步减少了并发冲突。主要通过volatile + CAS（乐观锁）或 synchronized（悲观锁）来实现的线程安全。</li></ul><blockquote><p>添加元素时，先判断容器是否为空：</p><ul><li>为空：直接使用volatile + CAS来初始化</li><li>不为空：根据存储的元素计算该位置是否为空<ul><li>如果存储的元素计算结果为空，利用CAS设置该节点</li><li>如果存储的元素计算结果不为空，使用synchronized，然后遍历桶中的元素，并替换或新增节点到桶中，再判断是否需要转成红黑树。（当发生hash碰撞时说明容量不够用或已经有大量线程访问，因此使用synchronized来处理hash比CAS效率高）</li></ul></li></ul></blockquote><ol start="2"><li>ConcurrentSkipListMap：实现了一个基于跳表（SkipList）算法的可排序的并发集合，通过维护多个指向其他元素的跳跃链接来实现高效查询</li></ol><p>并发Set：</p><ol><li>ConcurrentSkipListSet：线程安全的有序集合，底层是使用ConcurrentSkipListMap实现</li><li>CopyOnWriteArraySet：线程安全的HashSet</li></ol><p>并发List：</p><ol><li>CopyOnWriteArrayList：线程安全的ArrayList，底层通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以感知到；在写入新元素时，会将原来的数组拷贝一份并让原来数组的长度+1后就得到一个新数组，将元素放入新数组的最后一个位置，用新数组地址替换旧数组地址就能得到最新数据了；读操作时不加锁，一直都能读的。</li></ol><p>并发Queue：</p><ol><li>ConcurrentLinkedQueue：高并发场景下的队列，通过无锁（CAS）的方式，实现高并发状态下的高性能。</li><li>BlockingQueue：提供一种读写等待的机制，简化多线程间的数据共享。</li></ol><p>并发Deque：</p><ol><li><p>LinkedBlockingDeque：线程安全的双端队列，内部使用双向链表结构</p></li><li><p>ConcurrentLinkedQueue：基于链表节点的无限并发链表，可以安全的并发执行插入、删除、访问的操作</p></li></ol><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList是线程安全的嘛？有什么办法可以把ArrayList变成线程安全的？"><a href="#ArrayList是线程安全的嘛？有什么办法可以把ArrayList变成线程安全的？" class="headerlink" title="ArrayList是线程安全的嘛？有什么办法可以把ArrayList变成线程安全的？"></a>ArrayList是线程安全的嘛？有什么办法可以把ArrayList变成线程安全的？</h2><ol><li>使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(arrayList);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用CopyOnWriteArrayList（这是一个线程安全的List）代替ArrayList</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;String&gt; copyOnWriteArrayList = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用Vector类代替ArrayList</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(arrayList);</span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h2><p>HashMap不是线程安全的，在多线程环境下会存在以下问题：</p><ul><li>JDK7，采用数组+链表，多线程环境下，数组扩容时会存在Entry链死循环和数据丢失的问题</li><li>JDK8，采用数组+链表+红黑树，解决了Entry链死循环和数据丢失的问题，但是多线程环境下，put元素会出现覆盖的情况</li></ul><p>保证线程安全：</p><ul><li>使用Collections.synchronizedMap同步加锁的方式，还可以使用HashTable。</li><li>使用ConcurrentHashMap。（JDK7使用分段锁；JDK8使用CAS+synchronized）</li></ul><h2 id="HashMap一般用什么作为Key？为什么String适合做key？"><a href="#HashMap一般用什么作为Key？为什么String适合做key？" class="headerlink" title="HashMap一般用什么作为Key？为什么String适合做key？"></a>HashMap一般用什么作为Key？为什么String适合做key？</h2><p>用String做key，因为String对象是不可变的，一旦创建旧不能被修改，保证了key的稳定性。如果key是可变的，会导致hashCode和equals方法的不一致。</p><h2 id="为什么HashMap要用红黑树而不是平衡二叉树？"><a href="#为什么HashMap要用红黑树而不是平衡二叉树？" class="headerlink" title="为什么HashMap要用红黑树而不是平衡二叉树？"></a>为什么HashMap要用红黑树而不是平衡二叉树？</h2><p>平衡二叉树追求的是绝对平衡，导致每次在插入或删除节点时，都需要通过左旋或右旋来调整，使它再次称为一颗符合要求的平衡二叉树</p><p>红黑树不支持这种完全平衡的规则， 牺牲了一部分的查找效率，但是可以换取一部分维持平衡状态的成本。</p><h2 id="HashMap的key可以为null嘛"><a href="#HashMap的key可以为null嘛" class="headerlink" title="HashMap的key可以为null嘛"></a>HashMap的key可以为null嘛</h2><p>HashMap使用hash()方法来计算key的哈希值，当key为空时，直接设置hash值为0，不走hashCode方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : 走hashCode()后处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>null作为key只能有一个，作为value可以有多个</p></blockquote><h2 id="重写HashMap的equals和hashCode方法需要注意什么？"><a href="#重写HashMap的equals和hashCode方法需要注意什么？" class="headerlink" title="重写HashMap的equals和hashCode方法需要注意什么？"></a>重写HashMap的equals和hashCode方法需要注意什么？</h2><p>从HashMap中获取值时，这些方法也会被用到，如果这些方法没有被正确的实现，两个不同的Key可能会产生相同的hashCode()和equals()输出，HashMap会认为他们是相同的，把他们存在不同的地方。</p><h2 id="重写HashMap的equals方法不当会出现什么情况？"><a href="#重写HashMap的equals方法不当会出现什么情况？" class="headerlink" title="重写HashMap的equals方法不当会出现什么情况？"></a>重写HashMap的equals方法不当会出现什么情况？</h2><p>HashMap在比较元素时，先比较hashCode方法，如果hash值相同，再比较equals方法。</p><p>如果重写hashCode方法，但是不重写equals方法，会出现equals方法返回false，导致hashMap中存储多个一样的对象，与hashMap只有唯一的key的规范不符合。</p><h2 id="HashMap在多线程下可能出现的问题？"><a href="#HashMap在多线程下可能出现的问题？" class="headerlink" title="HashMap在多线程下可能出现的问题？"></a>HashMap在多线程下可能出现的问题？</h2><ol><li>JDK7使用头插法插入元素，多线程环境下，扩容时可能导致环形链表的出现，形成死循环。因此JDK8使用尾插法插入元素，在扩容时保持链表原本的顺序不变，不会出现环形链表的问题</li></ol><blockquote><p>因为JDK7使用头插法，对数组长度进行扩容时，如果原来是1-&gt;2-&gt;3，扩容后就会变成3-&gt;2-&gt;1</p><p>如果多个线程同时对HashMap进行扩容操作，可能会导致链表的指针混乱，形成环形链表。</p></blockquote><ol start="2"><li>多线程同时执行put操作，如果计算出来的索引位置是想通的，那会造成前一个key被后一个key覆盖，从而导致元素丢失的问题</li></ol><h2 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h2><p>在扩充HashMap时，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0</p><p>索引 &#x3D; (数组下标 - 1) &amp; 哈希值</p><p><img src="D:\project\kaiFa\Blog\source_posts\assets\873f106cbf234f6b868fdd54dc9cd3d1.jpeg" alt="873f106cbf234f6b868fdd54dc9cd3d1.jpeg"></p><ul><li>如果是0：索引没变</li><li>如果是1：索引 &#x3D; 原索引 + 旧容量</li></ul><blockquote><p>所以HashMap的大小是2的n次方，这样就不需要重新计算hash值。</p></blockquote><h2 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h2><ol><li>HashMap线程不安全，可以存储null的key和value，每次扩容成原来的2n，要保证线程安全也可以用ConcurrentHashMap。</li><li>HashTable线程安全，所有的方法都加synchronized锁，不可以有null的key和value，效率低，每次扩容为原来的2n + 1。</li></ol><h2 id="HashTable和ConcurrentHashMap的区别？"><a href="#HashTable和ConcurrentHashMap的区别？" class="headerlink" title="HashTable和ConcurrentHashMap的区别？"></a>HashTable和ConcurrentHashMap的区别？</h2><ul><li>ConcurrentHashMap是线程安全的。读操作不需要加锁，写操作需要加锁。JDK7，ConcurrentHashMap采用数组 + 链表，并发控制用分段锁；JDK8，ConcurrentHashMap采用数组 + 链表 + 红黑树，并发控制用CAS + synchronized</li><li>HashTable采用的是数组 + 链表，所有的方法都加synchronized锁</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="Set集合的特点？"><a href="#Set集合的特点？" class="headerlink" title="Set集合的特点？"></a>Set集合的特点？</h2><p>Set集合是唯一的，不会有重复的元素。</p><p>向Set集合中插入元素时，先通过hashCode确定元素的存储位置，再通过equals判断是否存在相同的元素，如果存在不会再次插入。</p><h2 id="有序Set是什么？"><a href="#有序Set是什么？" class="headerlink" title="有序Set是什么？"></a>有序Set是什么？</h2><p>有序的Set是TreeSet和LinkedHashSet</p><ul><li>TreeSet是基于红黑树来保证元素的自然顺序</li><li>LinkedHashSet是基于双向链表和哈希表的结合来保证元素添加的自然顺序（可以记录插入顺序的集合，不仅保证元素的唯一性，还可以保证元素的插入顺序）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【复习】Java基础</title>
      <link href="/post/ceeb1a09.html"/>
      <url>/post/ceeb1a09.html</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><ol><li>平台无关性：一次编译，处处运行</li><li>面向对象：封装、继承、多态</li><li>内存管理：Java有自己的垃圾回收机制，不需要手动管理内存。</li></ol><h2 id="Java为什么是跨平台的？"><a href="#Java为什么是跨平台的？" class="headerlink" title="Java为什么是跨平台的？"></a>Java为什么是跨平台的？</h2><p>JVM不同平台有不同的版本。</p><p>我们编写的Java源码，编译后会生成.class文件（字节码文件）。虚拟机就是将字节码文件翻译成指定平台下的机器码运行的。只要在不同平台上安装对应的JVM，就可以运行字节码文件。</p><p>编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，需要通过JVM翻译成机器码才能运行，不同平台下的机器码不同，但是字节码却是一样的。</p><h2 id="JVM、JDK、JRE的关系？"><a href="#JVM、JDK、JRE的关系？" class="headerlink" title="JVM、JDK、JRE的关系？"></a>JVM、JDK、JRE的关系？</h2><p>JVM：Java虚拟机，负责将字节码编译成机器码并执行程序（解释自己的指令集并映射到本地CPU指令集和OS的系统调用）</p><p>JRE：Java运行时的环境，是Java程序所需的最小环境，包含JVM和一组类库，用来支持程序的运行。（JRE不包含开发工具，只提供Java程序所需的运行环境）</p><p>JDK：Java开发工具包，包含了JVM、编译器（javac）等开发工具。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境</p><h2 id="Java的解释性和编译性"><a href="#Java的解释性和编译性" class="headerlink" title="Java的解释性和编译性"></a>Java的解释性和编译性</h2><ol><li>编译性：Java源码先被编译成字节码，JIT会把编译后的机器码保存起来，以备下次使用</li><li>解释性：JVM中的一个方法调用计数器，当累计技术大于一定值的时候，就是用JIT进行编译生成机器码文件，否则就是解释器进行解释执行。（字节码也是通过解释器进行解释运行的）</li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="八种基本的数据类型"><a href="#八种基本的数据类型" class="headerlink" title="八种基本的数据类型"></a>八种基本的数据类型</h2><ul><li>数值类型：long（8）、int（4）、short（2）、byte（1）、double（8）、float（4）</li><li>字符类型：char（2）</li><li>布尔类型：boolean（1）</li></ul><h2 id="数据类型转换的方式"><a href="#数据类型转换的方式" class="headerlink" title="数据类型转换的方式"></a>数据类型转换的方式</h2><ol><li>自动类型转换：int转long、float转double</li><li>强制类型转换：long转int、double转float</li></ol><h2 id="为什么用BigDecimal不用double？"><a href="#为什么用BigDecimal不用double？" class="headerlink" title="为什么用BigDecimal不用double？"></a>为什么用BigDecimal不用double？</h2><p>double会出现精度丢失的问题，double执行的是二进制的浮点运算，二进制有些情况下不能准确的表示一个小数。</p><p>Decimal是精确计算的，一般涉及到金钱的计算都会使用Decimal</p><blockquote><p>在创建BigDecimal对象时，需要使用字符串作为参数，而不是直接使用浮点运算作为数值，以避免浮点数精度丢失。</p></blockquote><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>装箱是基本数据类型转成对应的包装类</p><p>拆箱是包装类转成对应的基本数据类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><blockquote><p>自动装箱的问题</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">sum += i; <span class="comment">// 一直发生装箱、拆箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>基本数据类型和引用数据类型不能直接转换，必须使用包装类来实现。</p><p>int类型转成String类型：int类型先转成Integer类型；Integer类型转成String类型</p></blockquote><h2 id="Integer的缓存"><a href="#Integer的缓存" class="headerlink" title="Integer的缓存"></a>Integer的缓存</h2><p>Integer类的内部实现了一个静态缓存池，用来存储特定范围内（默认：-128~127）的整数值对应的Integer对象。</p><p>当创建一个在指定范围内的整数对象时，并不会每次都生成新的对象，而是复用缓存中的现有对象，会直接从内存中取出，不需要新建一个对象</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="怎么理解面向对象？"><a href="#怎么理解面向对象？" class="headerlink" title="怎么理解面向对象？"></a>怎么理解面向对象？</h2><p>面向对象是一种编程范式，将现实世界中的事物抽象为对象。面向对象的设计思想以对象为中心，通过对象之间的交互来完成程序的功能。</p><ul><li>封装：将对象的数据和方法结合在一起，对外隐藏对象内部的实现细节，只通过对象提供的接口与外界交互</li><li>继承：使得子类自动共享父类数据结构和方法的机制，是代码复用的重要手段，通过继承可以实现建立类和类之间的层次关系</li><li>多态：允许不同类的对象对同一个消息做出不同的响应。（编译时多态、运行时多态）<ul><li>方法重载：同一个类可以有多个同名的方法（通过参数列表来区分）</li><li>方法重写：子类可以提供对父类同名方法的具体实现</li><li>接口的使用：多个类可以实现同一个接口，并通过接口类型的引用来调用这些类的方法</li><li>向上转型和向下转型：<ul><li>向上转型：使用父类的引用指向子类对象</li><li>向下转型：将父类引用转化成子类类型（需要确认引用实际指向的对象类型）</li></ul></li></ul></li></ul><h2 id="面向对象的设计原则"><a href="#面向对象的设计原则" class="headerlink" title="面向对象的设计原则"></a>面向对象的设计原则</h2><ol><li>单一职责原则：一个类应该只有一个引起他变化的原因</li><li>开放封闭原则：软件实体应该对扩展开放，对修改封闭</li><li>里氏替换原则：子类对象应该能够替换所有的父类对象</li><li>接口隔离原则：客户端不应该依赖那些它不需要的接口</li><li>依赖倒置原则：高层模块不应该依赖底层模块</li><li>最少知识原则：一个对象应该对其他对象有最少的了解</li></ol><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><ol><li><strong>抽象类</strong>用来描述类的共同行为和特性，可以有成员变量、构造方法、具体方法；<strong>接口</strong>用来定义行为规范，可以多实现，只有常量和抽象方法</li><li>一个类可以实现（implements）多个接口，但是只能继承（extends）一个类</li><li><strong>接口</strong>中只能有定义，不能有方法的实现；<strong>抽象类</strong>中可以有定义和实现</li><li><strong>接口</strong>成员变量默认为public static final，成员方法默认为public abstract；<strong>抽象类</strong>中成员变量默认default，可以在子类中被重新定义，也可以被重新赋值，抽象类方法被abstract修饰，不能被private、static、synchronized、native修饰，必须以分号结尾。</li><li><strong>抽象类</strong>可以包含实例变量和静态遍历；<strong>接口</strong>只能包含常量</li></ol><h2 id="new子类对象的加载顺序？"><a href="#new子类对象的加载顺序？" class="headerlink" title="new子类对象的加载顺序？"></a>new子类对象的加载顺序？</h2><ul><li>父类静态成员变量、静态代码块</li><li>子类静态成员变量、静态代码块</li><li>父类构造方法</li><li>子类构造方法</li></ul><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><ul><li>浅拷贝：只创建一个新的对象，将原对象的字段值放入新对象中，两个对象指向的是同一个引用对象</li><li>深拷贝：递归复制对象内部所有引用类型的字段，生成一个全新的对象以及其内部的所有对象，实现方式如下：<ul><li>实现Cloneable接口并重写clone()方法</li><li>将对象序列化为字节流，再从字节流反序列化为对象</li><li>手动赋值</li></ul></li></ul><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="Java创建对象的方式"><a href="#Java创建对象的方式" class="headerlink" title="Java创建对象的方式"></a>Java创建对象的方式</h2><ol><li><p>使用new关键字</p></li><li><p>使用Class类的newInstance()方法【反射】</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass)Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure><ol start="3"><li>使用Constructor的newInstance()方法【反射】</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure><ol start="4"><li>使用clone方法：如果类实现了Cloneable接口，可以使用clone()方法复制对象</li><li>使用反序列化：将对象序列化到文件中，再使用反序列化创建对象</li></ol><h2 id="new出的对象什么时候回收？"><a href="#new出的对象什么时候回收？" class="headerlink" title="new出的对象什么时候回收？"></a>new出的对象什么时候回收？</h2><p>通过new创建出的对象，是由gc负责回收的，再程序运行过程中自动进行的，它会周期性检查不再被引用的对象，将其回收释放内存。gc主要是根据一些算法来决定的，主要有：</p><ol><li>可达计数器：某个对象的引用计数器为0，表示该对象可以被回收</li><li>可达分析算法：从GC Root出发，一层层找所引用的对象，如果被找到就是存活对象，其他不可达的对象就是垃圾对象，垃圾对象就会被回收</li><li>终结器（Finalizer）：如果对象重写了finalize()方法，gc会在回收该对象之前调用finalize()方法，对象可以在finalize()方法中进行一些清理操作。【不推荐】</li></ol><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>在运行过程中，任意一个类，都能够知道这个类的所有属性和方法，任意一个对象，都能调用它的任意一个方法和属性。</p><ol><li>允许在运行时获取类的完整结构信息</li><li>可以使用反射API动态创建对象实例</li><li>可以在运行时动态调用对象的方法</li><li>允许在运行时访问和修改对象的字段值（包括私有的）</li></ol><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="Java注解的原理"><a href="#Java注解的原理" class="headerlink" title="Java注解的原理"></a>Java注解的原理</h2><p>注解本质是继承了Annotation的特殊接口，具体实现类是Java运行时生成的动态代理类。</p><p>通过反射获取注解，其实返回的是Java运行时生成的动态代理对象，通过代理对象调用自定义注解的的方法，最后会调用invoke方法。</p><h2 id="注解的作用域"><a href="#注解的作用域" class="headerlink" title="注解的作用域"></a>注解的作用域</h2><ol><li>类级别作用域：描述类的注解，放在类上，用来指定类的一些属性</li><li>方法级别作用域：描述方法的注解，放在方法定义上，用来指定方法的一些属性</li><li>字段级别作用域：用来描述字段的注解，放在字段上，用来指定字段的一些属性</li></ol><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><h2 id="与-equals的区别？"><a href="#与-equals的区别？" class="headerlink" title="&#x3D;&#x3D; 与 equals的区别？"></a>&#x3D;&#x3D; 与 equals的区别？</h2><ol><li>功能不同：&#x3D;&#x3D;是操作符，用于比较两个变量或对象的引用地址是否相同；equals是一个方法，用于比较两个对象的内容是否相同，他是Object类中的一个方法，子类可以重写这个方法。</li><li>比较对象不同：&#x3D;&#x3D;适用于基本数据类型（比较值是否相同）和对象引用（比较引用地址是否相同）；equals适合于对象内容的比较，对于基本数据类型不能直接用equals，但是可以包装成对应的包装类对象，再使用equals比较</li><li>默认行为不同：equals对于未重写equals方法的子类来说，equals方法的行为与&#x3D;&#x3D;相同，只有在类里重写了equals方法后，才会根据重写的方法逻辑进行比较</li><li>性能不同：&#x3D;&#x3D;速度比较快，equals速度比较慢</li></ol><h2 id="String、StringBuffer、StringBuilder的区别？"><a href="#String、StringBuffer、StringBuilder的区别？" class="headerlink" title="String、StringBuffer、StringBuilder的区别？"></a>String、StringBuffer、StringBuilder的区别？</h2><ol><li>String是不可变的字符串，因为他的不可变性，在拼接字符串的时候就会产生很多无用的中间对象（线程安全）</li><li>StringBuffer就是为了解决String在拼接字符串的时候产生大量中间对象而提供的类。它是可变的，是线程安全的。</li><li>StringBuilder和StringBuffer本质上没什么区别，但是它是线程不安全的，减少了开销。</li></ol><blockquote><p>速度：String &lt; StringBuffer &lt; StringBuilder</p><p>适用场景：</p><ul><li>String：操作少量数据</li><li>StringBuffer：多线程操作大量数据</li><li>StringBuilder：单线程操作大量数据</li></ul></blockquote><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><h2 id="怎么把一个对象从一个jvm转移到另一个jvm"><a href="#怎么把一个对象从一个jvm转移到另一个jvm" class="headerlink" title="怎么把一个对象从一个jvm转移到另一个jvm"></a>怎么把一个对象从一个jvm转移到另一个jvm</h2><ol><li>使用序列化和反序列化：将一个对象序列化为字节流，并将其发送到另一个JVM，在另一个JVM进行反序列化恢复对象。</li><li>使用消息队列</li><li>使用远程方法调用（RPC）：在分布式系统中调用远程JVM上对象的方法</li><li>使用共享数据库或缓存：将对象存储在共享数据库或共享缓存中，让不同的JVM可以访问这些共享数据。</li></ol><h1 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="Java怎么实现网络IO高并发编程"><a href="#Java怎么实现网络IO高并发编程" class="headerlink" title="Java怎么实现网络IO高并发编程"></a>Java怎么实现网络IO高并发编程</h2><p>传统的BIO：如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读取到的数据，如果BIO想要并发处理多个客户端的IO，只能使用多线程模式，一个线程专门处理一个客户端io，随着客户端越来越多，所需要的线程也会增多，会消耗系统的性能。</p><p>Java NIO：同步非阻塞的I&#x2F;O模型，基于IO多路复用，可以用一个线程处理多个客户端IO</p><blockquote><ul><li>BIO：传统的java.io包，基于流模型实现，在读写动作完成之前，线程会阻塞。代码比较直观，但是IO的效率和扩展性差</li><li>NIO：java.nio包，提供了Channel、Selector、Buffer等抽象，同步非阻塞的IO程序，同时提供了更接近操作系统底层高性能的数据操作方式</li><li>AIO：是NIO的升级版，提供了异步非阻塞的IO，应用操作后会直接返回，不会阻塞在那里，当后台处理完成后，操作系统会通知响应的线程进行后续的操作。</li></ul></blockquote><h2 id="NIO是怎么实现的？"><a href="#NIO是怎么实现的？" class="headerlink" title="NIO是怎么实现的？"></a>NIO是怎么实现的？</h2><p>NIO：同步非阻塞的IO模型。</p><ul><li><p>同步：线程不断轮询IO事件是否就绪</p></li><li><p>非阻塞：线程在等待IO的时候可以同时做其他任务</p></li></ul><p>同步的核心是Selector，Selector代替线程本身的IO实践，避免了阻塞同时减少了不必要的线程消耗</p><p>非阻塞的核心是通道和缓冲区，当IO事件就绪时，可以通过写到缓冲区保证IO的成功，而无需线程阻塞式等待</p><p>NIO由一个专门的线程处理所有的IO事件，负责并发。</p><blockquote><p>Netty的IO模型式基于非阻塞IO实现的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/post/bae4ff13.html"/>
      <url>/post/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><h2 id="搭建主从集群"><a href="#搭建主从集群" class="headerlink" title="搭建主从集群"></a>搭建主从集群</h2><p>单节点Redis的并发能力有上限（上万），要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\66db656fc83f44cea5de7851231046a4.png" alt="66db656fc83f44cea5de7851231046a4.png"></p><blockquote><p>主节点会把数据同步给从节点，让每个从节点的数据和主节点一样。</p></blockquote><ol><li>启动多个Redis实例</li><li>建立集群</li></ol><p>在<code>从节点</code>通过命令配置主从关系：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p><p><img src="D:\project\kaiFa\Blog\source_posts\assets\111ed55062314e94a05125c86b72e65c.png" alt="111ed55062314e94a05125c86b72e65c.png"><br><code>info replication</code>：查看节点状态</p><ul><li>临时：在控制台输入slaveof命令</li><li>永久：在redis.conf文件中利用slaveof命令指定master节点</li></ul><p>成功后，进入主节点，输入<code>info replication</code>可以看到两个slave，并且在主节点写入后，在从节点可以读取到。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3106dcadee9a4ac8a182dd40e0c64e50.png" alt="3106dcadee9a4ac8a182dd40e0c64e50.png"></p><h2 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h2><p>当主从第一次同步连接或断开重连时，从节点都会发送psync请求，尝试数据同步<br>【全量同步】：执行bgsave命令，将完整的内存数据生成RDB文件，把RDB文件写到磁盘中，再通过网络传送到slave（效率超级低）<br>【增量同步】：通过repl_backlog缓冲区，对比主从节点之间的命令差异，发送slave未同步的命令给slave<br><img src="D:\project\kaiFa\Blog\source_posts\assets\fbc7ac70555b4452a114ae2134ae7bb4.png" alt="fbc7ac70555b4452a114ae2134ae7bb4.png"></p><ul><li>replicationID：每个master节点都有自己唯一的id，主从节点建立连接后，主从节点的replid都保持一致，从节点请主节点时会携带replid，如果replid和主节点的replid一致，说明从节点<code>不是第一次来同步</code>；否则replid就是<code>第一次来同步</code>。</li><li>offset：repl_backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致。</li></ul><blockquote><p>【问题】repl_backlog是一个缓冲区，用来记录slave和master建立连接后，master中的写命令，但是这个缓冲区的大小默认只有1M。<br>【解决】repl_backlog是一个环形数组，但是如果slave宕机了很长时间，缓冲区slave还没同步的数据又被master覆盖了，此时slave只能做全量同步（效率低）。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\5ca365d39a8e4b8d965887c1b5f4147f.png" alt="5ca365d39a8e4b8d965887c1b5f4147f.png"></p></blockquote><p>【执行全量同步的时机】：slave节点第一次连接master节点；slave节点断开时间太久，repl_backlog中的offset已经被覆盖。<br>【执行增量同步的时机】：slave节点断开又恢复，并在repl_backlog中能找到offset时。</p><h3 id="全量同步效率低的解决"><a href="#全量同步效率低的解决" class="headerlink" title="全量同步效率低的解决"></a>全量同步效率低的解决</h3><ol><li>在master中配置<code>repl-diskless-sync: yes</code>启动无磁盘复制，避免全量同步时的磁盘IO。</li><li>redis单节点上的<code>内存占用</code>不要太大，减少RDB导致的过多磁盘IO。</li><li>适当<code>提高repl_backlog的大小</code>，发现slave宕机时尽快实现故障恢复，尽量避免全量同步。</li><li>限制一个master上的slave节点数量，如果实在太多slave，可以采用<code>主-从-从链式结构</code>，减少master压力。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2a10c30b0cb84feca850e86e3fd4bf0b.png" alt="2a10c30b0cb84feca850e86e3fd4bf0b.png"></li></ol><h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><p>哨兵Sentinel机制来实现主从集群的自动故障恢复。哨兵的作用：</p><ol><li>监控：Sentinel会不断检查master和slave是否按预期工作。</li><li>自动故障恢复：如果master故障，sentinel会将一个slave提升为master。当故障恢复后也以新的master为主。</li><li>通知：当集群发生故障转移时，sentinel会将最新节点角色信息推送给新的redis客户端。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\f2d2d164338b4706ae56e12e1881fe3f.png" alt="f2d2d164338b4706ae56e12e1881fe3f.png"></li></ol><h3 id="1-服务状态监控"><a href="#1-服务状态监控" class="headerlink" title="1. 服务状态监控"></a>1. 服务状态监控</h3><p>sentinel基于心跳机制检测服务状态，每隔1s向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某个sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li><li>客观下线：如果超过指定数量（quorum）的sentinel都认为该实例主管下线，则该实例客观下线。quorum的值最好超过sentinel实力数量的一半。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\7fae77907e384b33b0c15820bec927d0.png" alt="7fae77907e384b33b0c15820bec927d0.png"></li></ul><h3 id="2-选举新的master"><a href="#2-选举新的master" class="headerlink" title="2. 选举新的master"></a>2. 选举新的master</h3><p>一旦发现master故障，sentinel需要在slave中选择一个作为新的mater，选择依据：</p><ol><li>首先判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点。</li><li>然后判断slave节点的slave-priority值，值越小优先级越高。（如果是0则用不参与选举，默认是0）</li><li>如果slave-priority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高。</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ol><h3 id="3-故障转移"><a href="#3-故障转移" class="headerlink" title="3. 故障转移"></a>3. 故障转移</h3><p>当选中其中一个slave为新的master后，故障转移的步骤：</p><ol><li>sentinel给备选的slave节点发送<code>slaveof no one</code>命令，让该节点成为master。</li><li>sentinel给所有其他slave发送<code>slaveof 192.168.140.101 7002</code>命令，让这些slave成为新的master的从节点，开始从新的master上同步数据。</li><li>最后sentinel将故障节点标记为slave（修改故障节点的配置文件redis.conf），当故障节点恢复后，会自动成为新的master的slave节点。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\80663f3b72124173890fba2b64eed1de.png" alt="80663f3b72124173890fba2b64eed1de.png"></li></ol><h2 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h2><p>哨兵的配置文件sentinel.conf：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel announce-ip &quot;192.168.140.101&quot;</span><br><span class="line">sentinel monitor hmaster 192.168.140.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds hmaster 5000</span><br><span class="line">sentinel failover-timeout hmaster 60000</span><br></pre></td></tr></table></figure><ul><li><code>sentinel announce-ip</code>：当前sentinel的ip</li><li><code>sentinel monitor hmaster 192.168.140.101 7001 2</code>：sentinel monitor 主节点名 主节点ip 主节点端口 认定master下线的quorum值（sentinel监控配置）</li><li><code>sentinel down-after-milliseconds hmaster 5000</code>：哨兵ping节点，超过5s就算超时</li><li><code>sentinel failover-timeout hmaster 60000</code>：哨兵监测到主节点宕机后做故障恢复，如果故障恢复又失败了， 再过60s再次做故障恢复。</li></ul><h1 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h1><h2 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h2><p>【问题】主从和哨兵可以解决高可用、高并发度的问题，但是还存在两个问题：海量数据存储问题；高并发写的问题。</p><p>【解决】使用分片集群可以解决，分片集群的特征：</p><ul><li>集群中有多个master，每个master保存不同数据；</li><li>每个master可以有多个slave节点；</li><li>master之间可以通过ping检测彼此健康状态<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2cf7e7f9866548598f10533a0d970172.png" alt="2cf7e7f9866548598f10533a0d970172.png"></li></ul><blockquote><p>分片集群可以理解成有多个主从集群组合成的，且不需要哨兵节点，master之间可以通过ping来判断是否下线。</p></blockquote><ol><li>使用docker-compose部署，新建docker-compose.yaml文件：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7001&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7002&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r3</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7003&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r4:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r4</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7004&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r5:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r5</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7005&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r6:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r6</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7006&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br></pre></td></tr></table></figure><p>输入<code>docker compose up -d</code>启动redis集群</p><ol start="2"><li>使用命令创建集群：</li></ol><p>进入任意节点容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it r1 bash</span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 \</span><br><span class="line">192.168.140.101:7001 192.168.140.101:7002 192.168.140.101:7003 \</span><br><span class="line">192.168.140.101:7004 192.168.140.101:7005 192.168.140.101:7006</span><br></pre></td></tr></table></figure><blockquote><p><code>1</code>：表示副本数量，一个主、一个从<br>redis会默认前三个是主节点，后三个是从节点<br><img src="D:\project\kaiFa\Blog\source_posts\assets\edb3f8133b594b16a50abca9476e7e34.png" alt="edb3f8133b594b16a50abca9476e7e34.png"></p></blockquote><h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><p>在redis集群中，共有16384个hash slots，集群中每个redis节点都会分配一定数量的hash slots：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\709832dae3e84408b91b43c99283a092.png" alt="709832dae3e84408b91b43c99283a092.png"></p><blockquote><p>redis数据不是与节点绑定，而是与插槽slot绑定。当读写数据时，Redis基于CRC16算法对key做hash运算，将得到的结果与16384取余，就计算出这个key的slot值。</p></blockquote><p>redis在计算key的hash值又分成两种情况：</p><ol><li>key中包含{}，根据{}之间的字符串计算hash slot</li><li>key中不包含{}，根据整个key字符串计算hash slot<br><img src="D:\project\kaiFa\Blog\source_posts\assets\9a753d16a60d428189bd6c3742460235.png" alt="9a753d16a60d428189bd6c3742460235.png"></li></ol><blockquote><p>user这个key计算出的hash值时5474，如果按照之前的方式建立连接，那么在集群1（范围：0-5460）中插入hash值为5474的key，会报错。<br>解决办法：集群模式下建立连接时，应该加上-c参数：<code> redis-cli -c -p 7001</code><br><img src="D:\project\kaiFa\Blog\source_posts\assets\808278ba1e104af9855f6744bed3d14a.png" alt="808278ba1e104af9855f6744bed3d14a.png"></p></blockquote><h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>redis中任意数据类型的键和值都会被封装成一个RedisObject，也叫Redis对象<br><img src="D:\project\kaiFa\Blog\source_posts\assets\19fdf51eda244686b6b0537c512d54d6.png" alt="19fdf51eda244686b6b0537c512d54d6.png"><br>type：数据类型（string、hash、list、set、zset）<br>encoding：数据在内存中的存储方式<br>lru：对象最近一次被访问的时间（太久没被访问的key会在内存不足时淘汰）<br>refcount：当前对象如果被别人引用了，这个值就会+1，如果为0也会被回收<br>*ptr：指向实际存放数据的内存地址</p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>跳表，首先是链表，与传统链表的差异：</p><ul><li>元素按照升序排列</li><li>节点可以包含多个指针，指针跨度不同<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3a0d6da1191a414e86bad97082b9328d.png" alt="3a0d6da1191a414e86bad97082b9328d.png"></li></ul><blockquote><p>跳表是一个有序的双向链表，每个节点可以包含多层指针（最多允许32层），层级越高，跨度越大，增删改查效率和红黑树基本一致，实现更简单，但是空间复杂度更高</p></blockquote><h2 id="SortedSet（zset）"><a href="#SortedSet（zset）" class="headerlink" title="SortedSet（zset）"></a>SortedSet（zset）</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\068249c114bb4b4bbc1f0864bfee4316.png" alt="068249c114bb4b4bbc1f0864bfee4316.png"><br>特点：</p><ul><li>每组数据都包含score和member</li><li>member唯一</li><li>可根据score排序</li></ul><p><img src="D:\project\kaiFa\Blog\source_posts\assets\c84b6f4e18434842b8d8e65e7391a1e9.png" alt="c84b6f4e18434842b8d8e65e7391a1e9.png"><br>dict：hashtable（存储score、member；member为键，score为值。可以满足member唯一性）<br>zsl：skiplist（存储score、member，在排序时根据score排序）</p><p>根据member得到score：去查hash表<br>直到某个元素的score排名：去hashtable里，根据member查到score，再去skiplist里根据score得到排名</p><h1 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h1><h2 id="内存过期处理"><a href="#内存过期处理" class="headerlink" title="内存过期处理"></a>内存过期处理</h2><p>redis提供了expire命令，可以给key设置TTL（存活时间）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\8902e444d8be4a5aae2f8105fc804404.png" alt="8902e444d8be4a5aae2f8105fc804404.png"></p><h3 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h3><p>redis的本质还是键值型数据库，所有的数据都存储在redisDB的结构中，其中包含<code>两个哈希表</code>：</p><ul><li>dict：保存redis中所有键值对</li><li>expires：保存redis中所有设置了过期时间的key，以及到期时间（写入时间+TTL）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\d919a1dbee3848f4a6362f5f9ae1d0bd.png" alt="d919a1dbee3848f4a6362f5f9ae1d0bd.png"></li></ul><blockquote><p>redis不会实时检测key的过期时间，它不会在key过期后立刻删除。而是采用两种延迟删除的策略：</p><ol><li><strong>惰性删除</strong>：当有命令需要一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</li><li><strong>周期删除</strong>：通过一个定时任务，周期性的抽样部分有TTL的key，如果过期则执行删除。</li></ol></blockquote><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>内存淘汰：当Redis内存达到设置的阈值时，Redis就会主动挑选部分key删除以释放更多的内存。</p><p>Redis在每次处理客户端命令时，都会对内存使用情况判断，如果必要，则执行内存淘汰。内存淘汰的策略有：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\d4b471ece59342e191080ce6c6a29842.png" alt="d4b471ece59342e191080ce6c6a29842.png"></p><ol><li>前缀：<ul><li>allkeys：对所有的key进行淘汰，从dict的哈希表中挑选</li><li>volatile：只对设置了TTL的key进行淘汰，从expires的哈希表中挑选</li></ul></li><li>后缀：<ul><li>ttl：淘汰ttl小的</li><li>random：随机挑选</li><li>lru：基于LRU算法</li><li>lfu：基于LFU算法</li></ul></li></ol><blockquote><p><strong>LRU（最近最少使用）</strong>：用当前时间 - 最后一次访问时间，值越大越先被淘汰（越久没被访问到的越先淘汰）<br><strong>LFU（最少频率使用）</strong>：统计每个key的访问频率，值越小越先被淘汰</p></blockquote><p>那么redis怎么直到最近一次访问时间（LRU）或 访问次数（LFU）呢？<br><img src="D:\project\kaiFa\Blog\source_posts\assets\684cd1388ccd4ed9abb7b1f2bd3cbfec.png" alt="684cd1388ccd4ed9abb7b1f2bd3cbfec.png"><br>在redisObject这个数据结构里：</p><ul><li>当使用LRU策略时，lru这个变量存储的是以<strong>秒</strong>为单位的最近一次访问时间。</li><li>当使用LFU策略时，lru这个变量：<ul><li>高16位以<strong>分钟</strong>为单位的最近一次访问时间。</li><li>低8位记录<code>逻辑访问次数</code>。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\6158b8696e0c4833b44698d044c712f3.png" alt="6158b8696e0c4833b44698d044c712f3.png"></li></ul></li></ul><h1 id="Redis缓存问题"><a href="#Redis缓存问题" class="headerlink" title="Redis缓存问题"></a>Redis缓存问题</h1><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>保证缓存一致性主要有三种模式：</p><ul><li><code>Cache Aside Pattern</code>（常用）</li><li>Read &#x2F; Write Through Pattern</li><li>Write Behind Caching Pattern</li></ul><h3 id="Cache-Aside模式"><a href="#Cache-Aside模式" class="headerlink" title="Cache Aside模式"></a>Cache Aside模式</h3><p>由<strong>业务的开发者</strong>在更新数据库的同时更新缓存。有一定的业务侵入，但是一致性更好<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1c529edfa8d24a589fce4615753e0dc7.png" alt="1c529edfa8d24a589fce4615753e0dc7.png"></p><blockquote><p>【注1】：<strong>如何保证redis与数据库的一致性？</strong><br>从数据库中<code>查</code>一条数据，可以直接把这条数据存到redis缓存中；<br>但是如果需要做<code>增删改</code>操作时，redis中可以直接删除，没必要对redis中的数据也做同样的增删改操作。<br>【注2】：<strong>在做增删改操作时，应该先删除redis再改数据库，还是先改数据库再删redis？</strong><br>如果先删redis，再改数据库：当有一个线程A需要删除数据时，它先将redis中的数据删除，来到数据库，此时又有一个线程B来查询同一条数据，先去查询redis未命中，也来到数据库中，此时如果是线程B先执行了查询操作，线程B将查询后的结果又存入redis中，线程A后把这条数据删除。但是redis中却存在线程B的数据，就出现了数据的不一致性，所以需要先删除数据库再改redis。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\af64533d4bd94a308465efed673d092c.png" alt="af64533d4bd94a308465efed673d092c.png"></p></blockquote><h3 id="Read-Write-Through模式"><a href="#Read-Write-Through模式" class="headerlink" title="Read &#x2F; Write Through模式"></a>Read &#x2F; Write Through模式</h3><p><strong>缓存与数据库整合为一个服务</strong>（没有现成的哈哈哈哈哈），由服务来维护一致性。业务开发者直接调用该服务接口，无需关心一致性问题。</p><h3 id="Write-Behind-Caching模式"><a href="#Write-Behind-Caching模式" class="headerlink" title="Write Behind Caching模式"></a>Write Behind Caching模式</h3><p>增删改查业务直接基于缓存，由<strong>其他线程异步调用</strong>的将缓存数据持久化到数据库，保证最终一致性。（高性能，弱 &#x2F; 最终一致性）</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透：客户请求的数据在数据库中不存在，就不会写入缓存，这将导致每次查询这个该数据都会去访问数据库，可能导致数据库挂掉。</p><blockquote><p>只要用户请求的是不存在的数据，那么每次请求都会发到数据库中</p></blockquote><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>实现简单，维护方便，但是会有额外的内存消耗。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ad33c54f8ce74687944135f1d0e62c56.png" alt="ad33c54f8ce74687944135f1d0e62c56.png"></p><h3 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h3><p>请求过来会先经过布隆过滤器，布隆过滤器先判断数据库中是否存在这条数据，如果不存在，就会拒绝这个请求。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\0315493ba18b4ce2ab9d011a2923baf4.png" alt="0315493ba18b4ce2ab9d011a2923baf4.png"><br><img src="D:\project\kaiFa\Blog\source_posts\assets\998c53e9816049ae86b5aa1b3e7dac8c.png" alt="998c53e9816049ae86b5aa1b3e7dac8c.png"></p><blockquote><p>注意，布隆过滤器判断一个元素不存在时，它绝对不存在；但是如果它判断一个元素存在，这个元素可能会不存在。</p></blockquote><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩：在同一时段，<strong>大量的缓存key同时失效</strong>，或<strong>redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\58f67820c2344ef9b48cbc50f05c4d14.png" alt="58f67820c2344ef9b48cbc50f05c4d14.png"><br>解决：</p><ol><li>给不同的key的TTL添加随机值（避免大量的缓存key同时失效）</li><li>利用redis集群提高服务的可用性（避免服务宕机）</li><li>给缓存业务添加降级限流策略（防止大量的请求过来）</li><li>给业务添加多级缓存（建立nginx缓存、JVM本地缓存…）</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿（热点Key问题）：<strong>一个被高并发访问</strong>并<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ed0ff38605e5432ebb34f785fab4ba41.png" alt="ed0ff38605e5432ebb34f785fab4ba41.png"><br>解决方案：</p><ol><li><p>互斥锁：一个线程查询数据库的时候加锁，此时其他线程都无法访问。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\d2cf3b7587014dc59423214cf6876b35.png" alt="d2cf3b7587014dc59423214cf6876b35.png"></p></li><li><p>逻辑过期：线程1第一次来查询这个数据，发现数据过期，就先获取互斥锁，（此时会开启一个新的线程，线程1暂时返回过期数据）。<br>开启的新线程（线程2）就重新查询数据，写入缓存，最后释放锁。<br>在新线程（线程2）写入缓存这一过程中，如果还有别的线程（线程3、4）要访问，它先去获取互斥锁，发现互斥锁之前已经被别的线程获取了，此时它也直接返回过期的数据。直到数据被更新为止。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\c83e886175ad41618751575aed38d436.png" alt="c83e886175ad41618751575aed38d436.png"></p></li></ol><p><img src="D:\project\kaiFa\Blog\source_posts\assets\2c4b0d118e284dd8838876d48a0256d6.png" alt="2c4b0d118e284dd8838876d48a0256d6.png"></p><blockquote><p>穿透就是毫无攻击性直达数据库，因为是不存在的缓存，雪崩就是同时过期或宕机，击穿就是有攻击性因为是存在的缓存跟它战斗然后击穿。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> springcloud </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenFeign远程调用返回的是List＜T＞类型的数据</title>
      <link href="/post/1fab5f71.html"/>
      <url>/post/1fab5f71.html</url>
      
        <content type="html"><![CDATA[<p>在使用 OpenFeign 进行远程调用时，如果接口返回的是 List<T> 类型的数据，可以通过以下方式处理：</p><h1 id="直接定义返回类型为List"><a href="#直接定义返回类型为List" class="headerlink" title="直接定义返回类型为List"></a>直接定义返回类型为List<T></h1><p>Feign 默认支持 JSON 序列化&#x2F;反序列化，如果服务端返回的是 List<T>的JSON格式数据，可以直接在 Feign 接口中定义返回类型为 List<T>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;Item&gt; <span class="title function_">getItems</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用ResponseResult包装返回类型"><a href="#使用ResponseResult包装返回类型" class="headerlink" title="使用ResponseResult包装返回类型"></a>使用ResponseResult包装返回类型</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    ResponseResult&lt;List&lt;Item&gt;&gt; <span class="title function_">getItems</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 ResponseResult包装返回类型时，调用 Feign 客户端获取数据时，需要先将data转成JSON字符串，再将JSON字符串解析为<code>List&lt;Item&gt;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResponseResult</span> <span class="variable">responseResult</span> <span class="operator">=</span> itemClient.getItems();</span><br><span class="line"><span class="type">String</span> <span class="variable">itemsJson</span> <span class="operator">=</span> JSON.toJSONString(responseResult.getData());</span><br><span class="line">List&lt;Item&gt; items = JSON.parseArray(itemsJson, Item.class);</span><br></pre></td></tr></table></figure><blockquote><p>直接强制转换<code>List&lt;Map&lt;String, Object&gt;&gt;</code>到<code>List&lt;WmChannel&gt;</code>是不安全的，因为Java的泛型在运行时会被擦除，编译器无法检查具体的类型是否匹配。而JSON会根据目标类的定义，逐个字段地将数据映射到对象中，从而确保类型安全。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\73e307defc934cad959410e3440eab0e.png" alt="73e307defc934cad959410e3440eab0e.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> openfeign </tag>
            
            <tag> 泛型擦除 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql事务</title>
      <link href="/post/bbab8a36.html"/>
      <url>/post/bbab8a36.html</url>
      
        <content type="html"><![CDATA[<h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><p>MyISAM不能完整支撑ACID特性。</p><h2 id="原子性（A）："><a href="#原子性（A）：" class="headerlink" title="原子性（A）："></a>原子性（A）：</h2><p>事务中的每个操作要像原子一样不可分割，要么全部成功，要么全部失败。<br>提供了<code>undo log</code>日志，一行数据的一次改动对应一条undo log日志，如果有操作异常则会触发回滚，反向执行undo log日志，将数据恢复到这些操作之前。</p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>在原子性 + 隔离性 + 持久性都完成的基础上，一致性也就完成了</p><h2 id="隔离性（I）"><a href="#隔离性（I）" class="headerlink" title="隔离性（I）"></a>隔离性（I）</h2><p>事务之间不能相互干扰，不能查看彼此提交的数据<br>写-写隔离（锁）、写-读隔离（MVCC）</p><h3 id="三大问题"><a href="#三大问题" class="headerlink" title="三大问题"></a>三大问题</h3><ol><li><strong>脏读</strong>：A事务读到B事务还没有提交的数据<br><img src="D:\project\kaiFa\Blog\source_posts\assets\b2c6b98821304382ba979d7b4e40fd4e.png" alt="b2c6b98821304382ba979d7b4e40fd4e.png"></li><li><strong>不可重复读</strong>：A事务执行过程中，对同一条事务进行两次读取，在第一次读和第二次读之间，B事务修改了这条数据并提交，A事务的两次读取读到了两个不同的数据<br><img src="D:\project\kaiFa\Blog\source_posts\assets\5643f7b9429948cc9d97954192eb90ef.png" alt="5643f7b9429948cc9d97954192eb90ef.png"></li><li><strong>幻读</strong>：A事务执行过程中，对同一个集合进行两次读取，在第一次读和第二次读之间，B事务增加或删除了部分数据，A事务两次读取读到数量不一致的行数据<br><img src="D:\project\kaiFa\Blog\source_posts\assets\0158cced197b4153acc847121842f9f6.png" alt="0158cced197b4153acc847121842f9f6.png"></li></ol><h3 id="四种隔离级别（解决三大问题）"><a href="#四种隔离级别（解决三大问题）" class="headerlink" title="四种隔离级别（解决三大问题）"></a>四种隔离级别（解决三大问题）</h3><ol><li>读未提交：会出现脏读、不可重复读、幻读</li><li>读已提交：解决脏读问题</li><li>可重复读：解决脏读、不可重复读问题</li><li>串行读：解决脏读、不可重复读、幻读<br><img src="D:\project\kaiFa\Blog\source_posts\assets\f5ce755c28fe41e1815d3a29f86e6124.png" alt="f5ce755c28fe41e1815d3a29f86e6124.png"></li></ol><h2 id="持久性（D）"><a href="#持久性（D）" class="headerlink" title="持久性（D）"></a>持久性（D）</h2><p>事务一旦提交，就不会因为意外的发生而丢失。<br>通过<code>redo log</code>机制来保证故障后，内存中丢失的数据会恢复磁盘中。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 事务 </tag>
            
            <tag> ACID </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/post/9a7d5a13.html"/>
      <url>/post/9a7d5a13.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\052e404382634514803ed61659236e47.png" alt="052e404382634514803ed61659236e47.png"><br><img src="D:\project\kaiFa\Blog\source_posts\assets\620a47301cb3463ebbaef396a16cb20e.png" alt="620a47301cb3463ebbaef396a16cb20e.png"></p><ul><li>producer：发布消息的对象（主题生产者）</li><li>topic：kafka将消息分门别类，每一类消息称为一个主题</li><li>consumer：订阅消息并处理发布的消息的对象成为主题消费者</li><li>broker：已发布的消息保存在一组服务器中，成为kafka集群。集群中每个服务器都是一个代理（Broker）。消费者可以订阅一个或多个主题（topic），并从broker拉取数据，从而消费这些已发布的消息。</li></ul><h1 id="安装kafka"><a href="#安装kafka" class="headerlink" title="安装kafka"></a>安装kafka</h1><p>kafka对于zookeeper是强依赖，保存kafka相关的节点数据，所以安装kafka之前必须先安装zookeeper</p><h2 id="1-安装zookeeper"><a href="#1-安装zookeeper" class="headerlink" title="1. 安装zookeeper"></a>1. 安装zookeeper</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name zookeeper \</span><br><span class="line">--restart always \</span><br><span class="line">-p 2181:2181 \</span><br><span class="line">zookeeper:3.4.14</span><br></pre></td></tr></table></figure><h2 id="2-安装kafka"><a href="#2-安装kafka" class="headerlink" title="2. 安装kafka"></a>2. 安装kafka</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d --name kafka \</span><br><span class="line">--restart always \</span><br><span class="line">--env KAFKA_ADVERTISED_HOST_NAME=192.168.140.102 \</span><br><span class="line">--env KAFKA_ZOOKEEPER_CONNECT=192.168.140.102:2181 \</span><br><span class="line">--env KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://192.168.140.102:9092 \</span><br><span class="line">--env KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092 \</span><br><span class="line">--env KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms256M&quot; \</span><br><span class="line">--net=host \</span><br><span class="line">wurstmeister/kafka:2.12-2.3.1</span><br></pre></td></tr></table></figure><blockquote><p><code>--net=host</code>：直接使用容器宿主机的网络命名空间，没有独立的网络环境。使用宿主机的ip和端口，也可以使用<code>-p 9092:9092</code>代替</p></blockquote><h2 id="3-项目集成kafka"><a href="#3-项目集成kafka" class="headerlink" title="3. 项目集成kafka"></a>3. 项目集成kafka</h2><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>生产者：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerQuickStart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. kafka的连接配置信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// kafka的连接地址</span></span><br><span class="line">        prop.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.140.102:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// key的序列化</span></span><br><span class="line">        prop.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        <span class="comment">// value的序列化</span></span><br><span class="line">        prop.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 创建kafka生产者对象</span></span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>(prop);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 发送消息</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数：topic</span></span><br><span class="line"><span class="comment">         * 第二个参数：消息的key</span></span><br><span class="line"><span class="comment">         * 第三个参数：消息的value</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic-first&quot;</span>, <span class="string">&quot;key-001&quot;</span>, <span class="string">&quot;hello kafka&quot;</span>);</span><br><span class="line">        producer.send(record);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 关闭消息通道，必须要关闭，否则消息发送不成功</span></span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>消费者：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerQuickStart</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. kafka的连接配置信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// kafka的连接地址</span></span><br><span class="line">        prop.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.140.102:9092&quot;</span>);</span><br><span class="line">        <span class="comment">// key的反序列化</span></span><br><span class="line">        prop.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        <span class="comment">// value的反序列化</span></span><br><span class="line">        prop.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置消费者组</span></span><br><span class="line">        prop.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;group1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建kafka消费者对象</span></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 订阅主题</span></span><br><span class="line">        consumer.subscribe(Collections.singletonList(<span class="string">&quot;topic-first&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 拉取消息</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 让当前线程一直处于监听的状态</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofMillis(<span class="number">1000</span>)); <span class="comment">// 每秒钟拉取一次</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> consumerRecord.key();</span><br><span class="line">                <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> consumerRecord.value();</span><br><span class="line">                System.out.println(key + <span class="string">&quot;:&quot;</span> + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果两个消费者在<code>同一个消费者组</code>内，此时就算只有多个消费者，那么只能有一个消费者收到消息（一对一）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3e7edd71c57a42f0ac05d969eea0d276.png" alt="3e7edd71c57a42f0ac05d969eea0d276.png"><br>如果两个消费者在<code>不同消费组</code>内，此时所有消费者都可以收到消息（一对多）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\242a212fdf394431aed386d613686efb.png" alt="242a212fdf394431aed386d613686efb.png"></p></blockquote><h1 id="分区机制"><a href="#分区机制" class="headerlink" title="分区机制"></a>分区机制</h1><p>kafka的分区机制是将每个主题（topic）划分成多个分区（Partition）<br>作用：这样就可以把数据存储到不同的机器上，并且机器上可以指定不同的分区。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\7606f76bda97483797be6e6e33721eea.png" alt="7606f76bda97483797be6e6e33721eea.png"><br>每一个分区都是一个顺序的、不可变的消息队列， 并且可以持续的添加。每个分区下都维护了一个连续自增的数值，用来标记消息在什么位置【偏移量(offset)】。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1b07401b8c9e47c5b88209aa9a07286d.png" alt="1b07401b8c9e47c5b88209aa9a07286d.png"><br>在发送消息的时候可以指定分区：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic-first&quot;</span>, <span class="number">0</span>, <span class="string">&quot;key-001&quot;</span>, <span class="string">&quot;hello kafka&quot;</span>); <span class="comment">// 分区0</span></span><br></pre></td></tr></table></figure><h2 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\32b71eecb1c14494892df71f61c37f39.png" alt="32b71eecb1c14494892df71f61c37f39.png"><br>不指定分区，默认是轮询，也可以指定分区进行存储。</p><h1 id="Kafka的高可用设计"><a href="#Kafka的高可用设计" class="headerlink" title="Kafka的高可用设计"></a>Kafka的高可用设计</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Kafka的服务器由broker服务的进程构成，一个kafka集群由多个broker组成。<br>如果集群中某一台机器宕机了，其他机器上的broker也能够对外提供服务。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\6bf86645577146469b64d4f2086f19c3.png" alt="6bf86645577146469b64d4f2086f19c3.png"></p><h2 id="备份机制"><a href="#备份机制" class="headerlink" title="备份机制"></a>备份机制</h2><p>kafka中消息的备份又叫做副本（Replica）<br>领导者副本：Leader Replica<br>追随者副本：Follower Replica</p><ul><li>ISR：同步备份，leader保存数据后，会立即同步到ISR中</li><li>普通：异步备份<br><img src="D:\project\kaiFa\Blog\source_posts\assets\129513be9e444e9696111ea4cf0e6612.png" alt="129513be9e444e9696111ea4cf0e6612.png"></li></ul><blockquote><p>leader挂了之后，会选出新的leader，会优先从ISR中选；如果ISR的副本都不行了，就从普通副本里选<br>【极端情况】：所有副本都失效了<br>【解决方案】：<br>方案1：等待ISR中的第一个醒过来，选为Leader，数据可靠，但是活过来的时间不确定<br>方案2：选择第一个活过来的副本，不一定是ISR中的，选为Leader，这样可以最快速度恢复可用性，但不一定数据完整。</p></blockquote><h1 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h1><h2 id="发送类型"><a href="#发送类型" class="headerlink" title="发送类型"></a>发送类型</h2><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>使用send()方法发送，会返回一个Future对象，调用get()方法进行等待就知道消息是否发送成功。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic-first&quot;</span>, <span class="number">0</span>, <span class="string">&quot;key-001&quot;</span>, <span class="string">&quot;hello kafka&quot;</span>);</span><br><span class="line"><span class="comment">// 同步发送消息</span></span><br><span class="line"><span class="type">RecordMetadata</span> <span class="variable">recordMetadata</span> <span class="operator">=</span> producer.send(record).get();</span><br><span class="line">System.out.println(recordMetadata.offset());</span><br></pre></td></tr></table></figure><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>调用send()方法，并指定一个回调函数，服务器在返回响应时调用函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(<span class="string">&quot;topic-first&quot;</span>, <span class="number">0</span>, <span class="string">&quot;key-001&quot;</span>, <span class="string">&quot;hello kafka&quot;</span>);</span><br><span class="line"><span class="comment">// 异步发送消息</span></span><br><span class="line">producer.send(record, <span class="keyword">new</span> <span class="title class_">Callback</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;记录一次信息到日志表中&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(recordMetadata.offset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="连接参数配置信息"><a href="#连接参数配置信息" class="headerlink" title="连接参数配置信息"></a>连接参数配置信息</h2><h3 id="必须配置的连接参数"><a href="#必须配置的连接参数" class="headerlink" title="必须配置的连接参数"></a>必须配置的连接参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// kafka的连接地址</span></span><br><span class="line">prop.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.140.102:9092&quot;</span>);</span><br><span class="line"><span class="comment">// key的序列化</span></span><br><span class="line">prop.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// value的序列化</span></span><br><span class="line">prop.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="ack消息确认机制"><a href="#ack消息确认机制" class="headerlink" title="ack消息确认机制"></a>ack消息确认机制</h3><p><img src="D:\project\kaiFa\Blog\source_posts\assets\3a850408829847c88bbb843fa6b35fd3.png" alt="3a850408829847c88bbb843fa6b35fd3.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.put(ProducerConfig.ACKS_CONFIG, <span class="string">&quot;all&quot;</span>); <span class="comment">// 确认机制</span></span><br></pre></td></tr></table></figure><blockquote><p>一般开发中不会设置ack的值，使用默认值。</p></blockquote><h3 id="retries消息重试机制"><a href="#retries消息重试机制" class="headerlink" title="retries消息重试机制"></a>retries消息重试机制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.put(ProducerConfig.RETRIES_CONFIG, <span class="number">10</span>); <span class="comment">// 重试机制：重试次数10次</span></span><br></pre></td></tr></table></figure><h3 id="compression消息压缩"><a href="#compression消息压缩" class="headerlink" title="compression消息压缩"></a>compression消息压缩</h3><p><img src="D:\project\kaiFa\Blog\source_posts\assets\53a42f69a9d541eeb259bb7505980ab1.png" alt="53a42f69a9d541eeb259bb7505980ab1.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">prop.put(ProducerConfig.COMPRESSION_TYPE_CONFIG,<span class="string">&quot;snappy&quot;</span>); <span class="comment">// 数据压缩</span></span><br></pre></td></tr></table></figure><blockquote><p>使用压缩可以降低网络传输开销和存储开销，这个往往是kafka发送消息的瓶颈所在。</p></blockquote><h1 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h1><h2 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h2><p>消费者组：由一个或多个消费者组成的群体<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ec96f780d3d64df698eff4da84432b23.png" alt="ec96f780d3d64df698eff4da84432b23.png"><br>一个发布在topic上的消息被分发到消费者组中的一个消费者</p><ul><li>queue模型：所有消费者都在一个组里</li><li>发布-订阅模型：所有消费者都在不同的组中</li></ul><h2 id="消息的有序性"><a href="#消息的有序性" class="headerlink" title="消息的有序性"></a>消息的有序性</h2><p>应用场景：</p><ol><li>即时消息中的一对一聊天和群聊，保证发送方消息的发送顺序与接收方的接收顺序一致。</li><li>充值转账两个渠道在同一个时间进行余额变更，短信通知必须要有顺序。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1cd07554d2c34611b93953e2fadd7da0.png" alt="1cd07554d2c34611b93953e2fadd7da0.png"><br>topic分区中的消息只能由消费者组中唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。<br>但是只能保证topic的一个分区顺序处理，不能保证跨分区的消息先后处理。如果想要顺序的处理topic的所有消息，就只能提供一个分区。</li></ol><h2 id="提交和偏移量"><a href="#提交和偏移量" class="headerlink" title="提交和偏移量"></a>提交和偏移量</h2><p>kafka不会像其他消息队列一样需要等到消费者的确认，消费者可以使用kafka来追踪消息在分区的位置（偏移量），消费者会往<code>_consumer_offeset</code>的特殊主题发送消息，消息里边包含了每个分区的偏移量。如果消费者发送崩溃，或又有新的消费者加入群组，就会触发<code>再均衡</code>。<br>偏移量（Offset） 是消费者消费消息的核心机制之一，它记录了消费者在分区（Partition）中的消费进度，没有这个kafka不知道消费到哪里，也是在同一个分区下消息的消费会有顺序的原因</p><blockquote><p>最开始的时候，消费者1、2、3各自负责各自的分区<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3000c74db99d42ce9ac1b01b316671b9.png" alt="3000c74db99d42ce9ac1b01b316671b9.png"><br>此时如果消费者2发生了故障<br><img src="D:\project\kaiFa\Blog\source_posts\assets\a4841da9007d4411829cc9c4b87a5099.png" alt="a4841da9007d4411829cc9c4b87a5099.png"><br>分区3、4没有消费者管理，此时就会触发<code>再均衡</code>，由消费者1和3分别接管这两个分区<br><img src="D:\project\kaiFa\Blog\source_posts\assets\4ada15f23cdf4098b5faf176432dd6cb.png" alt="4ada15f23cdf4098b5faf176432dd6cb.png"><br>【存在的问题】：</p><ol><li>如果<code>提交的偏移量 &lt; 客户端处理的最后一个消息的偏移量</code>，那么处于两个偏移量之间的消息就会被重复处理<br> <img src="D:\project\kaiFa\Blog\source_posts\assets\4c3b717bad1a408d9c528a8abab645ce.png" alt="4c3b717bad1a408d9c528a8abab645ce.png"></li><li>如果<code>提交的偏移量 &gt; 客户端的最后一个消息的偏移量</code>，那么处于两个偏移量之间的消息将会消失。（kafka默认情况下是拉取完数据就提交，实际上当获取到数据的时候，offset就提交了。但是业务还没有处理到offset的位置，就发生了故障。所以再均衡的时候，这部分数据就会发生丢失）<br> <img src="D:\project\kaiFa\Blog\source_posts\assets\a2ddb87729964e80a981f828d78a60e3.png" alt="a2ddb87729964e80a981f828d78a60e3.png"></li></ol></blockquote><h2 id="偏移量的提交方式"><a href="#偏移量的提交方式" class="headerlink" title="偏移量的提交方式"></a>偏移量的提交方式</h2><h3 id="自动提交偏移量"><a href="#自动提交偏移量" class="headerlink" title="自动提交偏移量"></a>自动提交偏移量</h3><p>当enable.auto.commit被设置为true，提交方式就是让消费者自动提交偏移量，每隔5s消费者会自动把从poll()方法接收到的最大偏移量提交上去</p><h3 id="手动提交偏移量"><a href="#手动提交偏移量" class="headerlink" title="手动提交偏移量"></a>手动提交偏移量</h3><p>当enable.auto.commit被设置成false，此时可以改成以下三种提交方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">// ...其他配置</span></span><br><span class="line"><span class="comment">// 开启手动提交偏移量的方式</span></span><br><span class="line">prop.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ol><li>提交当前偏移量（同步提交）<code>commitSync</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拉取消息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 让当前线程一直处于监听的状态</span></span><br><span class="line">    ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofMillis(<span class="number">1000</span>)); <span class="comment">// 每秒钟拉取一次</span></span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123;</span><br><span class="line">        System.out.println(consumerRecord.key() + <span class="string">&quot;:&quot;</span> + consumerRecord.value());</span><br><span class="line">        System.out.println(<span class="string">&quot;偏移量：&quot;</span> + consumerRecord.offset());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 同步提交偏移量</span></span><br><span class="line">            consumer.commitSync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;记录提交失败的异常：&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>阻塞操作，等待Broker确认提交结果。性能较低，但能确保提交成功或抛出异常。（如果失败了，他会一直重试直到成功）</p></blockquote><ol start="2"><li>异步提交<code>commitAsync</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拉取消息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 让当前线程一直处于监听的状态</span></span><br><span class="line">    ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofMillis(<span class="number">1000</span>)); <span class="comment">// 每秒钟拉取一次</span></span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123;</span><br><span class="line">        System.out.println(consumerRecord.key() + <span class="string">&quot;:&quot;</span> + consumerRecord.value());</span><br><span class="line">        System.out.println(<span class="string">&quot;偏移量：&quot;</span> + consumerRecord.offset());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步提交偏移量(在for循环外提交)</span></span><br><span class="line">    consumer.commitAsync(<span class="keyword">new</span> <span class="title class_">OffsetCommitCallback</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; map, Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;记录错误提交的偏移量：&quot;</span> + map + <span class="string">&quot;异常信息为：&quot;</span> + e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>非阻塞操作，提交后立即返回，不等待Broker确认。性能更高，但无法保证提交成功（如果服务器返回提交失败后，异步提交不会进行重试）<br>【常见问题】：</p><ol><li>同时有多个异步提交，可能会导致偏移量offset的覆盖。</li><li>消费者崩溃，最后一次异步提交可能未完成，导致偏移量未更新。</li><li>若Broker返回提交错误（如CommitFailedException），异步提交无法直接处理（需通过回调）。</li></ol></blockquote><ol start="3"><li>同步和异步组合提交</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拉取消息</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// 让当前线程一直处于监听的状态</span></span><br><span class="line">        ConsumerRecords&lt;String, String&gt; consumerRecords = consumer.poll(Duration.ofMillis(<span class="number">1000</span>)); <span class="comment">// 每秒钟拉取一次</span></span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; consumerRecord : consumerRecords) &#123;</span><br><span class="line">            <span class="comment">// 处理消息...</span></span><br><span class="line">            System.out.println(consumerRecord.key() + <span class="string">&quot;:&quot;</span> + consumerRecord.value());</span><br><span class="line">            System.out.println(<span class="string">&quot;偏移量：&quot;</span> + consumerRecord.offset());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 异步提交（正常流程、在for循环外提交）</span></span><br><span class="line">        consumer.commitAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理提交失败异常（如消费者组已失效）</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    System.out.println(<span class="string">&quot;记录错误的信息:&quot;</span> + e);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        consumer.commitSync(); <span class="comment">// 同步提交（确保最终提交成功）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        consumer.close(); <span class="comment">// 关闭消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>会先进行异步提交，如果提交失败了，就记录日志，然后再进行同步的提交。<br>【正常流程中使用异步提交】：在消息处理循环中，优先使用commitAsync以提高吞吐量。即使某次提交失败，后续提交可能成功，避免阻塞处理。<br>【退出时使用同步提交】：在消费者关闭前（如finally块），使用commitSync确保最后一次提交成功。因为此时消费者即将终止，必须保证偏移量的正确性，避免重复消费。</p></blockquote><h1 id="SpringBoot集成kafka收发消息"><a href="#SpringBoot集成kafka收发消息" class="headerlink" title="SpringBoot集成kafka收发消息"></a>SpringBoot集成kafka收发消息</h1><h2 id="传递普通类型的消息"><a href="#传递普通类型的消息" class="headerlink" title="传递普通类型的消息"></a>传递普通类型的消息</h2><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- kafkfa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置kafka信息：</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kafka-demo</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:9092</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="comment"># 重试次数</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># key、value的序列化器</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="comment"># 消费组</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">$&#123;spring.application.name&#125;-test</span></span><br><span class="line">      <span class="comment"># key、value的反序列化器</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br></pre></td></tr></table></figure><ol start="3"><li>消息生产者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个参数：topic</span></span><br><span class="line"><span class="comment"> * 第二个参数：消息内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    kafkaTemplate.send(<span class="string">&quot;name-topic&quot;</span>,<span class="string">&quot;xiaolin0333&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>消息消费者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloListener</span> &#123;</span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;name-topic&quot;)</span> <span class="comment">// 和消息生产者的topic对应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span>&#123; <span class="comment">// message表示监听到的消息</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(message))&#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递对象类型的消息"><a href="#传递对象类型的消息" class="headerlink" title="传递对象类型的消息"></a>传递对象类型的消息</h2><p>目前springboot整合后的kafka，因为序列化器是StringSerializer，此时如果需要传递对象有两种方式：<br>方式1：自定义序列化器（但是对象类型众多，通用性不强）<br>方式2：把要传递的对象转成json字符串，接收消息后再转为对象</p><ol><li>添加json序列化依赖：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>消息生产者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;xiaolin&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    kafkaTemplate.send(<span class="string">&quot;user-topic&quot;</span>, JSON.toJSONString(user));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>消息消费者</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@KafkaListener(topics = &quot;user-topic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessageUser</span><span class="params">(String userJson)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(userJson)) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(userJson, User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Kafka实战——自媒体文章上下架"><a href="#Kafka实战——自媒体文章上下架" class="headerlink" title="Kafka实战——自媒体文章上下架"></a>Kafka实战——自媒体文章上下架</h1><h2 id="Kafka和OpenFeign"><a href="#Kafka和OpenFeign" class="headerlink" title="Kafka和OpenFeign"></a>Kafka和OpenFeign</h2><p>当<code>自媒体微服务</code>中的文章需要上架或下架时，需要通知<code>文章微服务</code></p><p>【使用OpenFeign的问题】：</p><ul><li>同步阻塞：OpenFeign 是基于 HTTP 的同步远程调用，自媒体微服务必须等待文章微服务的响应才能继续后续逻辑。</li><li>性能瓶颈：如果文章微服务响应慢或不可用，自媒体微服务会被阻塞，导致接口延迟甚至超时。</li><li>耦合性高：两个服务直接依赖，任何一方的故障都可能影响对方。</li></ul><p>【改进方案】：自媒体微服务不再通过OpenFeign调用文章微服务，而是将文章上下架事件发送到 Kafka 消息队列，由文章微服务异步消费处理。从而达到系统的解耦。</p><p>【适用场景】：</p><ol><li>适合 Kafka 的场景：<ul><li>不需要实时响应的操作（如状态同步、日志记录、通知）。</li><li>高并发、高吞吐量的场景（如秒杀活动、批量任务）。</li></ul></li><li>适合 OpenFeign 的场景：<ul><li>需要实时获取结果的场景（如支付确认、查询订单状态）。</li></ul></li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>【需求】：已发表且已下架的文章可以上架；已发表且已上架的文章可以下架。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\217a675a5ed74c1db7bb8e414cffa7ab.png" alt="217a675a5ed74c1db7bb8e414cffa7ab.png"><br>自媒体微服务是生产者，文章微服务是消费者，自媒体微服务向kafka发送修改文章状态的任务，文章微服务从kafka里取出任务后消费。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> kafka </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java动态代理</title>
      <link href="/post/abd111cb.html"/>
      <url>/post/abd111cb.html</url>
      
        <content type="html"><![CDATA[<ul><li>为什么需要代理？对象如果嫌自己的事太多了，可以通过代理来转移部分职责。</li><li>代理长什么样？对象有什么方法想被代理，代理就一定要有对应的方法。但是方法做的事不同，代理是去调对象的方法。</li><li>中介如何知道要派唱歌、跳舞方法的代理？通过继承接口<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3995398eb18f44c7b28332d46a55f20a.png" alt="3995398eb18f44c7b28332d46a55f20a.png"></li></ul><hr><p>实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    String <span class="title function_">sing</span><span class="params">(String name)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigStart</span> <span class="keyword">implements</span> <span class="title class_">Star</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sing</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;唱歌：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;唱完了，谢谢&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dance</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot;跳舞&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Star <span class="title function_">createProxy</span><span class="params">(BigStart bigStart)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ClassLoader loader：用于指定一个类加载器（一般是固定的）</span></span><br><span class="line"><span class="comment">         * Class&lt;?&gt;[] interfaces：指定生成的代理长什么样（有哪些方法）</span></span><br><span class="line"><span class="comment">         * InvocationHandler h：指定生成的代理对象要干什么事</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 一般会通过以下的方式去调用代理对象的方法</span></span><br><span class="line"><span class="comment">         * Star starProxy = ProxyUtil.createProxy(s);</span></span><br><span class="line"><span class="comment">         * starProxy.sing(); // 调用唱歌</span></span><br><span class="line"><span class="comment">         * star.Proxy.dance(); // 调用跳舞</span></span><br><span class="line"><span class="comment">         * 当调用sing()、dance()方法时，都默认会去调用invoke方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">starProxy</span> <span class="operator">=</span> (Star) Proxy.newProxyInstance(ProxyUtil.class.getClassLoader(), <span class="comment">// 默认的</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Star.class&#125;, <span class="comment">// 接口数组</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 回调方法</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        <span class="comment">// 代理对象做的事</span></span><br><span class="line">                        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;sing&quot;</span>)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备话筒，收钱&quot;</span>); <span class="comment">// 代理做的事</span></span><br><span class="line">                            <span class="comment">// return method.invoke(bigStart, args); // 调用方法、返回（有返回值就返回方法的返回值）</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;dance&quot;</span>)) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;准备场地，收钱&quot;</span>); <span class="comment">// 代理做的事</span></span><br><span class="line">                            <span class="comment">// return method.invoke(bigStart, args); // 调用方法、返回（无返回值就直接返回）</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// else &#123;</span></span><br><span class="line">                        <span class="comment">// return method.invoke(bigStart, args); // 直接调用方法</span></span><br><span class="line">                        <span class="comment">// &#125;</span></span><br><span class="line">                        <span class="keyword">return</span> method.invoke(bigStart, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> starProxy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigStart</span> <span class="variable">bigStart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigStart</span>(<span class="string">&quot;杨超越&quot;</span>);</span><br><span class="line">        <span class="type">Star</span> <span class="variable">proxy</span> <span class="operator">=</span> ProxyUtil.createProxy(bigStart);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> proxy.sing(<span class="string">&quot;好日子&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line"></span><br><span class="line">        proxy.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>代理模式的主要目的是在客户端和目标对象之间添加一个中间层，以便在访问目标对象时执行额外的操作。<br>在方法执行前后记录日志信息，记录方法的执行时间、参数、返回值等。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> java </tag>
            
            <tag> 动态代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Virtual Machine（JVM）</title>
      <link href="/post/81c3ce59.html"/>
      <url>/post/81c3ce59.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM跨平台原理"><a href="#JVM跨平台原理" class="headerlink" title="JVM跨平台原理"></a>JVM跨平台原理</h1><p>跨平台：一次编译，到处运行<br>本质：不同操作系统上运行的JVM不一样，只需要把java程序编译成一份字节码文件，JVM执行不同的字节码文件。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\abe44f9e44e44a508d520c8ff4c794b3.png" alt="abe44f9e44e44a508d520c8ff4c794b3.png"></p><blockquote><p>Java是高级语言，提前编译一下（变成字节码文件），再执行起来就会快一点</p></blockquote><p><img src="D:\project\kaiFa\Blog\source_posts\assets\93237c9fb4f64f9194a8d468a324e6d9.png" alt="93237c9fb4f64f9194a8d468a324e6d9.png"></p><h1 id="JVM整体结构"><a href="#JVM整体结构" class="headerlink" title="JVM整体结构"></a>JVM整体结构</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\63c4a9afe7634a5aaba9f6378d46ba43.png" alt="63c4a9afe7634a5aaba9f6378d46ba43.png"></p><blockquote><p><code>解释器</code>：执行方法区中存储的字节码指令<br><code>垃圾回收器</code>：回收垃圾对象<br><code>JIT编译器</code>：处理一些热点的字节码指令。【字节码里可能存在一些热点指令，这些热点指令翻译过一次，就把他们缓存起来，下一次再执行热点指令，就去缓存中取。从而提高执行效率】<br><code>方法区</code>：类加载子系统把字节码加载到方法区中<br><code>堆</code>：执行过程中产生的对象<br><code>Java方法栈</code>：当前线程执行到某个java里的方法，就会放入这里<br><code>本地方法栈</code>：当前线程执行native方法，就会放入这里（用Java语言以外的语言编写的方法）<br><code>程序计数器</code>：记录下一条指令的地址</p></blockquote><h1 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\25073388d60b4c97abb2ea47033b187e.png" alt="25073388d60b4c97abb2ea47033b187e.png"></p><ol><li><p>加载：把字节码文件，加载到方法区的内存空间中。</p></li><li><p>链接：(static int i &#x3D; 10)</p></li></ol><ul><li>验证：检查字节码文件的格式</li><li>准备：先给i变量赋值为0（<code>先赋值0</code>）</li><li>解析：将符号引用解析为直接引用</li></ul><blockquote><p>符号引用可以理解为类的名字（一般由包名 + 类名确定一个类）<br>直接引用可以理解为这个类在方法区中对应的地址<br>符号引用解析为直接引用：类的名字解析为这个类在方法区对应的地址</p></blockquote><ol start="3"><li>初始化：给类里边的static属性赋值（<code>后赋值为10</code>）</li></ol><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\1c1b22acf10e47aaa2bc4f03e19ef835.png" alt="1c1b22acf10e47aaa2bc4f03e19ef835.png"></p><ol><li>引导类加载器（BootStrapClassLoader）（用c++写的）</li><li>自定义类加载器（继承自ExtClassLoader 或 AppClassLoader）</li></ol><blockquote><p>ExtClassLoader 和 AppClassLoader都继承自ClassLoader类<br>BootStrapClassLoader：加载jre&#x2F;lib目录下的类<br>ExtClassLoader：jre&#x2F;lib&#x2F;ext目录下的类<br>AppClassLoader：classpath（自己指定的）类加载的路径<br>WebAppClassLoader：Tomcat自定义的类加载器</p></blockquote><h2 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h2><p>作用：避免类的重复加载，防止核心API被篡改<br><img src="D:\project\kaiFa\Blog\source_posts\assets\93ed91909ec644169bf6a6608c8a123a.png" alt="93ed91909ec644169bf6a6608c8a123a.png"></p><blockquote><p>当加载一个类的时候，先从应用加载器加载，这个时候应用加载器会在已加载过的库里面查看是否加载过该类，如果没有就往上调，使用父加载器，也就是扩展类加载器来加载。</p><ol><li>先判断当前类是否被加载过</li><li>被加载过，直接返回</li><li>没有被加载过，<br>- 查看<strong>AppClassLoader</strong>对象的parent属性是否为空，<br>- 如果<code>不为空</code>，直接用parent属性加载（AppClassLoader对象的parent属性就是<strong>ExtClassLoader</strong>的对象）<br>- 如果<code>为空</code>，则利用<strong>BootStrapClassLoader</strong>加载<br>    - BootStrapClassLoader如果加载到，就直接结束<br>    - 如果加载不到，返回ExtClassLoader，如果还是加载不到，就退回AppClassLoader，由它自己去加载当前类。</li></ol></blockquote><h2 id="为什么Tomcat要自定义类加载器？"><a href="#为什么Tomcat要自定义类加载器？" class="headerlink" title="为什么Tomcat要自定义类加载器？"></a>为什么Tomcat要自定义类加载器？</h2><p>为了进行类的隔离，如果tomcat直接使用AppClassLoader类加载器，那么会出现以下情况：</p><ol><li>应用A中有个com.xiaolin.Hello.class</li><li>应用B中也有个com.xiaolin.Hello.class</li><li>虽然都叫Hello.class，但是这两个类的方法、属性可能不一样</li><li>如果AppClassLoader先加载了应用A中的Hello.class文件，那么应用B就不能被加载了，因为这两个类的名字一样</li><li>所以就需要针对应用A、B设置单独的类加载器，也就是WebAppClassLoader，这样两个应用中的Hello.class都会被各自的类加载器加载到，不会产生冲突。</li></ol><blockquote><p>JVM中判断一个类是否被加载到的逻辑：类名 + 对应的类加载器实例</p></blockquote><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\84c4c35b9bf9409d942268b6d5f1cc80.png" alt="84c4c35b9bf9409d942268b6d5f1cc80.png"></p><blockquote><p>方法区、堆区：多个线程共享<br>Java方法栈、本地方法栈、程序计数器：每个线程都有一个</p></blockquote><h2 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h2><p>是物理寄存器的抽象实现的，用来记录待执行的下一条指令的地址，是程序控制流的指示器（for、if else…都依赖它完成）。<br>解释器工作时，就是通过程序计数器获取下一条需要执行新的字节码指令，是JVM规范中没有规定任何OutOfMemoryError情况的区域。</p><h2 id="虚拟机栈（Java栈、本地方法栈）"><a href="#虚拟机栈（Java栈、本地方法栈）" class="headerlink" title="虚拟机栈（Java栈、本地方法栈）"></a>虚拟机栈（Java栈、本地方法栈）</h2><p>虚拟机栈是线程私有的，一个方法开始执行栈帧入栈，方法执行完后，对应的栈帧就出栈，因此不需要进行垃圾回收。</p><p>虚拟机栈存在OutOfMemoryError（内存不够）、StackOverflowError（栈溢出）</p><ol><li>线程太多了，就可能会出现OutOfMemoryError，线程创建时没有足够的空间去创建虚拟机栈了。</li><li>方法调用的层数太多，就可能会出现StackOverflowError<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2ca52891fbe94e04a393595612f41bc5.png" alt="2ca52891fbe94e04a393595612f41bc5.png"><br>栈帧：<ul><li>操作数栈：执行字节码指令过程中用来辅助计算的</li><li>局部变量表：记录方法里的每个变量的值<br><img src="D:\project\kaiFa\Blog\source_posts\assets\8aabe8461fbb4d36b1f3eb497c4257c4.png" alt="8aabe8461fbb4d36b1f3eb497c4257c4.png"></li></ul></li></ol><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\31028771326d4f3e888081b23ad1746a.png" alt="31028771326d4f3e888081b23ad1746a.png"><br>所有的对象和数组都应该存放在堆区，在执行字节码指令的时候，会把创建的对象存入堆区， 对象对应的引用地址放入虚拟机栈的栈帧中。</p><blockquote><p>方法执行完之后，创建的对象不会立马被回收，而是等JVM后台执行GC后，对象才会被回收。</p></blockquote><p>Eden：新对象都会先放入Eden区（除非对象的大小都超过Eden区，那么就放入老年代）<br>S0：也叫做from区<br>S1：也叫做to区<br>S0、S1都是用来存放MinorGC（YGC）后存在的对象<br>如果一个对象经过15次垃圾回收（YGC）后都没有被回收掉，那么就会被放入老年代里</p><blockquote><p>默认：<br>新生代 : 老年代 &#x3D; 1 : 2<br>Eden : S0区 : S1区 &#x3D; 8 : 1 : 1</p></blockquote><p><img src="D:\project\kaiFa\Blog\source_posts\assets\c27afc8798a6453f903d2710d26f4a23.png" alt="c27afc8798a6453f903d2710d26f4a23.png"><br>Yong GC &#x2F; Minor GC：负责堆新生代进行垃圾回收<br>Old GC &#x2F; Major GC：负责堆老年代进行垃圾回收（目前只有CMS垃圾回收器会单独对老年代进行垃圾收集，其他垃圾收集器基本都是整堆回收的时候堆老年代进行垃圾收集）<br>Full GC：整堆回收，也会对方法区进行垃圾收集</p><h1 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h1><h2 id="为什么要进行垃圾回收？"><a href="#为什么要进行垃圾回收？" class="headerlink" title="为什么要进行垃圾回收？"></a>为什么要进行垃圾回收？</h2><p>垃圾是指在JVM中没有任何指向它的对象，如果不清理这些垃圾，他们就会一直占用内存，而不能给其他对象，最终垃圾对象会越来越多从而出现内存溢出。</p><h2 id="如何标记垃圾对象？"><a href="#如何标记垃圾对象？" class="headerlink" title="如何标记垃圾对象？"></a>如何标记垃圾对象？</h2><ol><li>引用计数器：每个对象都保存一个引用计数器属性，用户记录对象被引用的次数。<ul><li>优点：实现简单，计数为0表示是垃圾对象</li><li>缺点：需要额外的空间来存储引用计数，需要额外的时间来维护引用计数，无法处理<code>循环引用</code>的问题<br><img src="D:\project\kaiFa\Blog\source_posts\assets\9d311255155744b78dca656c6486bf81.png" alt="9d311255155744b78dca656c6486bf81.png"></li></ul></li><li><code>可达性分析法</code>：以GC Root作为起始点，然后一层一层找到所引用的对象，被找到的对象就是存活对象，其他不可达的对象就是垃圾对象。（找到可达对象）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\87de527e1d73484aabe92edfe6edb52a.png" alt="87de527e1d73484aabe92edfe6edb52a.png"></li></ol><blockquote><p>GC Root是一组引用，包括：</p><ul><li>线程中虚拟机栈 &#x2F; 本地方法栈中正在执行的方法中的方法参数、局部变量所对应的对象引用</li><li>方法区中保存的类的信息中的静态 &#x2F; 常量属性所对应的对象引用</li></ul></blockquote><h2 id="怎么回收垃圾对象？"><a href="#怎么回收垃圾对象？" class="headerlink" title="怎么回收垃圾对象？"></a>怎么回收垃圾对象？</h2><ol><li>标记 - 清除算法：如果可用内存不够，就会暂停用户线程的执行，然后执行算法进行垃圾回收<ul><li><code>标记阶段</code>：从GC Roots开始遍历，找到可达对象，并在对象头中进行标记</li><li><code>清除阶段</code>：堆内存空间进行线性遍历，如果发现对象头中没有记录是可达，就回收他<br><img src="D:\project\kaiFa\Blog\source_posts\assets\c76633f97a1d438a83dfad712bbf15fe.png" alt="c76633f97a1d438a83dfad712bbf15fe.png"></li></ul></li></ol><blockquote><p>缺点：效率不高，会产生内存碎片<br>优点：易实现<br><img src="D:\project\kaiFa\Blog\source_posts\assets\65a68069d4414d5c8c7d5641091d5527.png" alt="65a68069d4414d5c8c7d5641091d5527.png"><br>只遍历一次，如果可达就直接转移。比较适合垃圾对象比较多的场景（复制成本低、例如：新生代）<br>优点：没有标记和清除阶段，不会出现内存碎片<br>缺点：</p><ul><li>需要更多的内存，始终有一半内存空闲；</li><li>对象复制后，对象存放的内存地址发生了变化，需要额外时间修改栈帧中记录的引用地址</li><li>可达对象比较多，垃圾对象比较少，复制算法的效率低</li></ul></blockquote><ol start="3"><li>标记 - 整理阶段<ul><li><code>标记阶段</code>：标记可达对象</li><li><code>移动阶段</code>：将所有存活的对象移动到内存的一端</li><li><code>整理阶段</code>：清除边界外所有空间<br><img src="D:\project\kaiFa\Blog\source_posts\assets\99105e63f11e4096aff2371033a5b913.png" alt="99105e63f11e4096aff2371033a5b913.png"></li></ul></li></ol><p>总结：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\803b3f54f8a1467aa6caa0266ecbd912.png" alt="803b3f54f8a1467aa6caa0266ecbd912.png"><br>新生代中的对象存活时间比较短，可以利用<code>复制算法</code>（适合垃圾对象比较多的情况）</p><p>老年代中的对象存货时间比较长，可以用<code>标记 - 清除</code> 或 <code>标记 - 整理算法</code>，比如：</p><ul><li>CMS垃圾收集器采用的就是 标记 - 清除算法</li><li>Serial Old垃圾收集器采用的就是 标记 - 整理算法</li></ul><h1 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h1><p><img src="D:\project\kaiFa\Blog\source_posts\assets\32eaf8f3e2fd4c2091fa7f703c2b418e.png" alt="32eaf8f3e2fd4c2091fa7f703c2b418e.png"></p><ol><li>Serial GC（新生代）和 Serial Old GC（老年代）：工作线程暂停，只有一个线程进行垃圾回收</li><li>Parallel GC（新生代）和 Parallel Old GC（老年代）：工作线程暂停，开启多个线程进行垃圾回收<br><img src="D:\project\kaiFa\Blog\source_posts\assets\c129919a2f6247fbbd77b9184471981a.png" alt="c129919a2f6247fbbd77b9184471981a.png"></li><li>CMS GC（老年代）：整个收集的过程更长，暂停的时间变短，而且在垃圾收集过程中大部分用户线程也还在执行，所以用户体验更好，但是吞吐量更低（单位时间内执行的用户时间更少了）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\51937747111b4fcd9ca87c7b979450b7.png" alt="51937747111b4fcd9ca87c7b979450b7.png"></li></ol><blockquote><ul><li><code>初始标记</code>：暂停所有工作线程，标记处所有GC Roots能<code>直接可达的对象</code>，标记完后恢复工作线程。（初始标记只找到直接可达对象，不需要找到所有可达对象，只找了一层）</li><li><code>并发标记</code>：垃圾回收线程和用户线程一起工作，垃圾回收线程也会去<code>剩余的可达对象</code>（初始标记中没有找到的可达对象，但是也会存在误差）</li><li><code>重新标记</code>：并发标记阶段可能会产生一些误差，需要进行修正</li><li><code>并发清理</code>：垃圾回收线程和用户线程一起工作，删除垃圾对象（可能新生成的垃圾对象没有被清除掉）</li><li><code>并发重置</code>：重置一下，方便下一次垃圾回收</li></ul></blockquote><p>初始标记、并发标记、重新标记，这三个阶段都是在找垃圾对象，其实最费时的是并发标记阶段，因为这个阶段需要找出大量的垃圾对象，但是在最费时的阶段里，用户线程也在工作。</p><ol start="4"><li>G1（整堆）：<br>每一个方块叫做region，堆内存会分为2048个region，还是分成了Eden区、S0区、S1区、老年代，只不过空间是不连续的。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\fa7d12852e8d47b885e905c5f148594a.png" alt="fa7d12852e8d47b885e905c5f148594a.png"></li></ol><blockquote><p>Humongous区：专门用来存放大对象（一个对象的大小超过一个region的50%）</p></blockquote><p><img src="D:\project\kaiFa\Blog\source_posts\assets\e4dbbe16a9964e5e9e62fea48695b816.png" alt="e4dbbe16a9964e5e9e62fea48695b816.png"></p><blockquote><p><code>初始标记</code>、<code>并发标记</code>、<code>最终标记</code>：同CMS<br><code>筛选回收</code>：提前设置一个时间t(默认200ms)，按照指定这个的时间t来做筛选回收（不一定会回收掉所有的垃圾）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> jvm </tag>
            
            <tag> 敏感词过滤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-Butterfly搭建博客</title>
      <link href="/post/3eb40baf.html"/>
      <url>/post/3eb40baf.html</url>
      
        <content type="html"><![CDATA[<p>Hexo‌是一个基于Node.js的静态网站生成器，主要用于快速搭建博客和个人网站。它使用Markdown语法编写文章，能够迅速生成静态页面并部署到服务器上。</p><hr><h1 id="配置node"><a href="#配置node" class="headerlink" title="配置node"></a>配置node</h1><ol><li>使用nvm安装node(v20.9.0)后配置镜像</li></ol><p>安装并使用node：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install 20.9.0</span><br><span class="line">nvm use 20.9.0</span><br></pre></td></tr></table></figure><p>查看当前node版本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>配置镜像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>可以通过以下命令查看镜像是否配置成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><ol start="2"><li>配置node</li></ol><p>下载express：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install express -g</span><br></pre></td></tr></table></figure><p>安装hexo本地环境：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h1 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h1><p>生成ssh：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\428eb5501c4e43d398945703a3fc0462.png" alt="428eb5501c4e43d398945703a3fc0462.png"></p><blockquote><p>所有要输入的地方都按回车，使用默认值</p></blockquote><p>把密钥添加到github账户中：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\0a7d0f60f6934594916624a781e96f86.png" alt="0a7d0f60f6934594916624a781e96f86.png"><br>测试ssh是否绑定成功：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>输入<code>ssh -T git@github.com</code>报错：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\9fb7118c1e2c4438bf5896a80a15627c.png" alt="9fb7118c1e2c4438bf5896a80a15627c.png"></p><blockquote><ol><li>说明无法通过22端口与github进行ssh连接，将ssh连接端口修改为443后测试：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\6f527c945a4f473f846164c3b55b9c5a.png" alt="6f527c945a4f473f846164c3b55b9c5a.png"></p><ol start="2"><li>说明443端口可以访问，但是github不提供shell权限。<br>  在.ssh文件夹下新建config文件（没有后缀）<br>  <img src="D:\project\kaiFa\Blog\source_posts\assets\d694daf978cf4b61b780191ad4500156.png" alt="d694daf978cf4b61b780191ad4500156.png"><br>  config文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Host github.com</span><br><span class="line">&gt;Hostname ssh.github.com</span><br><span class="line">&gt;Port 443</span><br></pre></td></tr></table></figure><ol start="3"><li>重新输入<code>sssh -T git@github.com</code>测试：<br>  <img src="D:\project\kaiFa\Blog\source_posts\assets\519dead45be747e28d424684810728bf.png" alt="519dead45be747e28d424684810728bf.png"></li></ol></blockquote><h1 id="本地创建Blog"><a href="#本地创建Blog" class="headerlink" title="本地创建Blog"></a>本地创建Blog</h1><ol><li>创建Blog文件夹，初始化hexo</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\b79ceafcafd14cd4bfe183f9c0d39920.png" alt="b79ceafcafd14cd4bfe183f9c0d39920.png"><br>成功后显示：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2beca5c864b848d990cb29bb28b267cf.png" alt="2beca5c864b848d990cb29bb28b267cf.png"></p><blockquote><ul><li>_config.yml：站点配置文件<br> node_modules：存储hexo插件的文件</li></ul></blockquote><ol start="2"><li>生成本地的hexo页面：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\a684891485164de68a15a7279a60893f.png" alt="a684891485164de68a15a7279a60893f.png"><br>在浏览器输入<code>http://localhost:4000</code>即可访问<br><img src="D:\project\kaiFa\Blog\source_posts\assets\46e81fbe60874ffa9f6fa824035dba8a.png" alt="46e81fbe60874ffa9f6fa824035dba8a.png"></p><h1 id="上传Blog到GitHub"><a href="#上传Blog到GitHub" class="headerlink" title="上传Blog到GitHub"></a>上传Blog到GitHub</h1><ol><li>新建仓库：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\bc87e499b2f54b5381138cbb2bed66f4.png" alt="bc87e499b2f54b5381138cbb2bed66f4.png"></li></ol><blockquote><p>仓库格式：<strong>用户名.github.io</strong><br>一定要是用户名！！不然后边会报404<br>这个仓库名将作为github博客的访问地址</p></blockquote><ol start="2"><li>修改_config.yml文件：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3bf9fabbbe9e4f9cb8b45a8754db9c50.png" alt="3bf9fabbbe9e4f9cb8b45a8754db9c50.png"></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/xiaolin0333/xiaolin0333.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><ol start="3"><li>安装hexo-deployer-git自动部署发布工具：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="4"><li>生成页面：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\dae7fa1696c14838a23191be161e5a8f.png" alt="dae7fa1696c14838a23191be161e5a8f.png"></p><ol start="5"><li>本地文件上传到Github网页：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>上传成功：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\25be4b4f3f014321806513067664e8cc.png" alt="25be4b4f3f014321806513067664e8cc.png"></p><h1 id="Butterfly主题"><a href="#Butterfly主题" class="headerlink" title="Butterfly主题"></a>Butterfly主题</h1><p>更改主题后，可以使用<code>hexo clean &amp; hexo g &amp; hexo s</code>在本地测试<br>需要传到github上，可以使用<code>hexo clean &amp; hexo g &amp; hexo d</code>传到GitHub上</p><h2 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h2><ol><li>在Blog根目录下下载：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><ol start="2"><li>安装pug和stylus渲染器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><ol start="3"><li>修改Blog根目录下的_config.yml开启butterfly主题</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><ol start="4"><li>在根目录新建_config.butterfly.yml，复制butterfly目录下的_config.yml文件到该文件中。</li></ol><blockquote><p>和博客网址关联度较高的设置在Blog根目录下的_config.yml文件中；<br>和主题样式关联度较高的设置在Blog根目录下的_config.butterfly.ym文件中。</p></blockquote><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><ol><li>安装插件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><ol start="2"><li>输入命令：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;新建博客的文章名&quot;</span><br></pre></td></tr></table></figure><h2 id="设置博客个人资料"><a href="#设置博客个人资料" class="headerlink" title="设置博客个人资料"></a>设置博客个人资料</h2><p>在_config.yml中设置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">xiaolin0333</span> <span class="comment">#标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;欢迎来到小林的博客&#x27;</span><span class="comment">#副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="comment">#个性签名</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">小林</span><span class="comment">#作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span><span class="comment">#语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span>    <span class="comment">#中国的时区</span></span><br></pre></td></tr></table></figure><h2 id="设置导航菜单"><a href="#设置导航菜单" class="headerlink" title="设置导航菜单"></a>设置导航菜单</h2><p>在_config.butterfly.yml中设置：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="comment"># Home: / || fas fa-home</span></span><br><span class="line">  <span class="comment"># List||fas fa-list:</span></span><br><span class="line">  <span class="comment">#   Music: /music/ || fas fa-music</span></span><br><span class="line">  <span class="comment">#   Movie: /movies/ || fas fa-video</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="string">分类:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">归档:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span> </span><br><span class="line">  <span class="string">留言板:</span> <span class="string">/comment/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-paper-plane</span></span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\8d8f2c20c9ad498c9857d2cbf0bd4ca2.png" alt="8d8f2c20c9ad498c9857d2cbf0bd4ca2.png"></p><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>根据前面设置的导航菜单创建文件夹</p><ol><li>标签</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><ol start="2"><li>分类</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><ol start="3"><li>归档</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page archives</span><br></pre></td></tr></table></figure><ol start="4"><li>关于</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><ol start="5"><li>留言板</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page comment</span><br></pre></td></tr></table></figure><p><img src="D:\project\kaiFa\Blog\source_posts\assets\8000c67c26a441869a2eedc013750510.png" alt="8000c67c26a441869a2eedc013750510.png"><br>….</p><blockquote><p>完成啦：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2e409fc8561d4fcf8e3e8b614efac22b.png" alt="2e409fc8561d4fcf8e3e8b614efac22b.png"><br><a href="https://xiaolin0333.github.io/">我的博客地址</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>704. 二分查找</title>
      <link href="/post/41f30363.html"/>
      <url>/post/41f30363.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\14a281266fd24602a7d759ee421e7c5d.png" alt="14a281266fd24602a7d759ee421e7c5d.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/binary-search/description/">704. 二分查找</a><br>左闭右闭区间<code>[l, r]</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123; <span class="comment">// 因为边界条件：[1, 1]时，l = r</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>; <span class="comment">// 因为是左闭右闭，nums[mid]已经不满足了，所以r = mid - 1（跳过mid）</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(logn)</li><li>空间复杂度: O(1)</li></ul><p>左闭右开区间[l, r)：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123; <span class="comment">// 因为边界条件：[1, 1)，不包含l = r的情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid; <span class="comment">// 因为是左闭右开，右边是开区间，所以nums[mid]不在这个区间中</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二分查找 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>560. 和为 K 的子数组</title>
      <link href="/post/4d9c5692.html"/>
      <url>/post/4d9c5692.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\9e3525036ef14eb3b73812b98272298f.png" alt="9e3525036ef14eb3b73812b98272298f.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked">560. 和为 K 的子数组</a><br>方法1. 前缀和</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preSum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 下标从1开始存储</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            preSum[i + <span class="number">1</span>] = preSum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(preSum[j] - preSum[i] == k) &#123; <span class="comment">// i 到 j 的和</span></span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>使用preSum数组来存储nums的前缀和，preSum[i] &#x3D; nums[0] + nums[1] + … + nums[i - 1]，这里一定要注意，存储的时候必须要从preSum[1]开始存，因为后边计算前缀和的时候，利用的是preSum[j] - preSum[i]，得从preSum[1]开始存相减的时候才能不丢失num[i]的值。</p></blockquote><p>方法2. 前缀和 + 哈希表</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; preSumCnt; <span class="comment">// 前缀和为key的个数有value个</span></span><br><span class="line">        preSumCnt[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 对于下标为0的元素，前缀和为0，个数为1</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cur += nums[i];</span><br><span class="line">            <span class="comment">// 统计cur - k的个数</span></span><br><span class="line">            <span class="keyword">if</span>(preSumCnt.<span class="built_in">find</span>(cur - k) != preSumCnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res += preSumCnt[cur - k];</span><br><span class="line">            &#125;</span><br><span class="line">            preSumCnt[cur]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>使用preSumCnt的map计算前缀和为key的个数有value个。<br>对于下标为0之前的元素，前缀和为0，个数有1个，这个需要赋初值，后边相加的时候都需要以这个开始。<br>在遍历的时候，如果找到一个前缀和为cur - k时，说明从之前的某个位置到当前位置的子数组和为k。如果遍历到i时，前缀和为cur，而题目要求找到和为k的子数组。如果存在一个位置j(j &lt; i)，其前缀和为cur - k，那么从位置j到位置i的子数组和为k。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1c4363eb6d8f4cc28581a15ad204f6df.png" alt="1c4363eb6d8f4cc28581a15ad204f6df.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543. 二叉树的直径</title>
      <link href="/post/340f36c0.html"/>
      <url>/post/340f36c0.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\d498da353d474109b33324b606cf611d.png" alt="d498da353d474109b33324b606cf611d.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">543. 二叉树的直径</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 求节点的最大深度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">help</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">help</span>(root-&gt;left); <span class="comment">// 左儿子为根的最大子树深度</span></span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">help</span>(root-&gt;right); <span class="comment">// 右儿子为根的最大子数深度</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, l + r); <span class="comment">// 更新res</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>; <span class="comment">// 返回节点的最大深度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>这题要求树的最大直径，其实也就是求树中某一个节点的左右子树的深度之和最大。那么就可以把这个问题拆解成一个个相同子问题：求某一个节点的最大深度。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56. 合并区间</title>
      <link href="/post/2e0786fe.html"/>
      <url>/post/2e0786fe.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\cc62f6f730054da994ae467715a030c2.png" alt="cc62f6f730054da994ae467715a030c2.png"><br>【题目】：<a href="https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked">56. 合并区间</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">    <span class="comment">// 按照左端点排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), [&amp;](vector&lt;<span class="type">int</span>&gt; lhs, vector&lt;<span class="type">int</span>&gt; rhs) &#123;</span><br><span class="line">            <span class="keyword">return</span> lhs[<span class="number">0</span>] &lt; rhs[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; interval[<span class="number">0</span>] &lt;= res.<span class="built_in">back</span>()[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(interval[<span class="number">1</span>], res.<span class="built_in">back</span>()[<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(interval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(nlogn)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>先把数组按照左端点排序，这样可以保证可以合并的区间是连续在一起的。<br>再遍历数组，如果<code>已加入结果数组的最后一个元素的右端点</code>&gt;&#x3D;<code>当前遍历数组元素的左端点</code>，就进行合并（合并的时候也要注意判断这两个元素的右端点的大小）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54. 螺旋矩阵</title>
      <link href="/post/e2205fc0.html"/>
      <url>/post/e2205fc0.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\fb86a25fba0c4696a4a93f0fe3c6fe6d.png" alt="fb86a25fba0c4696a4a93f0fe3c6fe6d.png"><br>【题目】：<a href="https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked">54. 螺旋矩阵</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 起始坐标</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">min</span>(m, n) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 填充边缘</span></span><br><span class="line">        <span class="keyword">while</span>(count--) &#123;</span><br><span class="line">            <span class="comment">// 向右</span></span><br><span class="line">            <span class="keyword">for</span>(j = startx; j &lt; n - offset; ++j) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[startx][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向下</span></span><br><span class="line">            <span class="keyword">for</span>(i = starty; i &lt; m - offset; ++i) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向左</span></span><br><span class="line">            <span class="keyword">for</span>(; j &gt; starty; --j) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向上</span></span><br><span class="line">            <span class="keyword">for</span>(; i &gt; startx; --i) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++offset;</span><br><span class="line">            ++startx;</span><br><span class="line">            ++starty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑只剩一行的情况</span></span><br><span class="line">        <span class="keyword">if</span>(m &lt;= n &amp;&amp; m % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(; starty &lt;= n - offset; ++starty) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[startx][starty]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑只剩一列的情况</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; m &amp;&amp; n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(; startx &lt;= m - offset; ++startx) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[startx][starty]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题主要是要抓住循环不变量，每次一圈循环都应该遵循左闭右开的原则。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\498811d5936948cab45002fbc6a1e84e.png" alt="498811d5936948cab45002fbc6a1e84e.png"><br>由于题目不一定是个正方形，所以最后要考虑<code>只剩一行</code>或<code>只剩一列</code>的情况<br><img src="D:\project\kaiFa\Blog\source_posts\assets\e989b2988f544c72bda25fafe68b8a57.png" alt="e989b2988f544c72bda25fafe68b8a57.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 矩阵 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>438. 找到字符串中所有字母异位词</title>
      <link href="/post/6d74f8b3.html"/>
      <url>/post/6d74f8b3.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\3cd645c44bb24ac2a35b83001d37e5ec.png" alt="3cd645c44bb24ac2a35b83001d37e5ec.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked">438. 找到字符串中所有字母异位词</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">curVec</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 统计p中字母出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : p) &#123;</span><br><span class="line">            curVec[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            curVec[s[r] - <span class="string">&#x27;a&#x27;</span>]--; <span class="comment">// 右侧字母进入滑窗</span></span><br><span class="line">            <span class="comment">// 如果某个字母正好满足要求，并且此时窗口长度 = p.size()，说明此时滑窗内是p的异位词</span></span><br><span class="line">            <span class="keyword">if</span>(curVec[s[r] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span> &amp;&amp; r - l + <span class="number">1</span> == p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(l);</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                curVec[s[l++] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果某个字母没有出现过，或 滑窗内出现次数&gt;p中字母出现的次数，缩小滑窗</span></span><br><span class="line">            <span class="keyword">while</span>(curVec[s[r] - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                curVec[s[l++] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>这题要求字符串中的字母异位词，首先先用curVec存储字符串p中字母出现的次数，当滑窗扩大时，左侧字母进入滑窗，curVec[s[r] - ‘a’]–，有两种情况需要讨论：</p><ol><li>此时curVec[s[r] - ‘a’] &#x3D;&#x3D; 0：这时候说明s[r]这个字母的出现次数 &#x3D; p中s[r]字母出现的次数，如果滑窗的长度 &#x3D; p的长度，说明滑窗内的字符串是p的异位词，此时可以缩小窗口，记录结果。</li><li>此时 curVec[s[r] - ‘a’] &lt; 0：这时候又分为两种情况：<ul><li>情况1. s[r]没有出现过</li><li>情况2. s[r]在滑窗内出现的次数 &gt; p中s[r]出现的次数<br>   无论是哪种情况，只要缩小窗口，直到curVec[s[r] - ‘a’] &#x3D;&#x3D; 0即可。</li></ul></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53. 最大子数组和</title>
      <link href="/post/460c78a0.html"/>
      <url>/post/460c78a0.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\b089caea6ec24aca941d82facdc026a0.png" alt="b089caea6ec24aca941d82facdc026a0.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked">53. 最大子数组和</a><br>方法1. 前缀和</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preSum</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            preSum[i + <span class="number">1</span>] = nums[i] + preSum[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, preSum[j] - preSum[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>用preSum维护前缀和，然后循环preSum， preSum[j] - preSum[i]就是子数组i到j的和。但是这个方法会超时&#x3D;。&#x3D;</p></blockquote><p>方法2. 动态规划</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>; <span class="comment">// dp[i]表示以 nums[i] 结尾的连续子数组的最大和</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// max(dp[i - 1] + nums[i], nums[i])</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法3. </p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">0</span>) &#123; <span class="comment">// 正数&gt;&gt;整数对结果是促进作用</span></span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">// 负数&gt;&gt;负数对结果是抑制的作用，直接重新开始算</span></span><br><span class="line">                sum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如果sum是正数，说明sum + nums[i]对结果是促进作用；<br>如果sum是负数，说明sum + nums[i]对结果是抑制作用，直接丢弃前边累加的结果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48. 旋转图像</title>
      <link href="/post/a5384297.html"/>
      <url>/post/a5384297.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\e1b58fb755b84a7da3790998f7557451.png" alt="e1b58fb755b84a7da3790998f7557451.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked">48. 旋转图像</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123; <span class="comment">// 奇数的话，要向下取整</span></span><br><span class="line">                <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题如果直接以行为单位进行旋转，有一部分值会被覆盖。所以我们应该一次旋转一个数字，找到这些数字的关系。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\f0f2303277e3402d9dbf4ea6d854af67.png" alt="f0f2303277e3402d9dbf4ea6d854af67.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>238. 除自身以外数组的乘积</title>
      <link href="/post/21d84a23.html"/>
      <url>/post/21d84a23.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:/project/kaiFa/Blog/source/_posts/assets/50eb507a8dee4a5dab9d1f93273ebbf3.png" alt="50eb507a8dee4a5dab9d1f93273ebbf3.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked">238. 除自身以外数组的乘积</a><br>方法1. 前后缀分解 + 两个数组存放前后缀的乘积</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[i] = 当前数字的左边数乘积 * 当前数字的右边数乘积</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// nums[i]左边数乘积</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n, <span class="number">1</span>)</span></span>; <span class="comment">// nums[i]右边数乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] * nums[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(left[i] * right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>这题的难点在于，不能用乘法。<br>所以使用前后缀分解，用两个数组分别求nums[i]所有左边数的乘积 和 nums[i]所有右边数的乘积，求结果的时候，res[i] &#x3D; 当前数字的左边数乘积 * 当前数字的右边数乘积</p></blockquote><p>方法2. 前后缀分解 + O(1)的空间复杂度</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// res[i] = 当前数字的左边数乘积 * 当前数字的右边数乘积</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i] = nums[i - <span class="number">1</span>] * res[i - <span class="number">1</span>]; <span class="comment">// res[i] 先存储nums[i]所有左边数的乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">1</span>; <span class="comment">// right存储nums[i]所有右边数的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            right = right * nums[i + <span class="number">1</span>];</span><br><span class="line">            res[i] = right * res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>先用res[i]来存放nums[i]所有左边数的乘积，再用一个常数right来存储nums[i]所有右边数的乘积，一边更新right的值，一边更新到res[i]中</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前后缀分解 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25. K 个一组翻转链表</title>
      <link href="/post/290cb30.html"/>
      <url>/post/290cb30.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\241763e249634a51ad3b5a21504cd2d0.png" alt="241763e249634a51ad3b5a21504cd2d0.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked">25. K 个一组翻转链表</a></p><p><code>while(cur &amp;&amp; kk--)</code></p><p>分类讨论：退出循环有两种情况，</p><ol><li><code>kk == 0</code>：此时说明仍然有k个元素可以进行反转，可以直接将反转后的结果和尾部相连</li><li><code>cur == nullptr</code>：此时如果kk &gt; 0，说明链表中已经不足k个了，此时不应该反转，但是我之前已经将链表反转过了，所以需要再进行二次反转。这样最多只需要再遍历k-1次，比<strong>事先判断是否满足k个再进行反转</strong>的效率相对也会高点。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = res;</span><br><span class="line">            res = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* tail = res;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            ListNode* tailTemp = cur; <span class="comment">// 反转前的头节点</span></span><br><span class="line">            <span class="comment">// 反转k个</span></span><br><span class="line">            <span class="type">int</span> kk = k;</span><br><span class="line">            ListNode* reverseHead = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// 反转</span></span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; kk--) &#123;</span><br><span class="line">                ListNode* temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = reverseHead;</span><br><span class="line">                reverseHead = cur;</span><br><span class="line">                cur = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(kk &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 二次反转reverseHead后再接到尾部（不足k个）</span></span><br><span class="line">                tail-&gt;next = <span class="built_in">reverse</span>(reverseHead);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接把反转的接到尾部（k个）</span></span><br><span class="line">                tail-&gt;next = reverseHead;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tailTemp; <span class="comment">// 更新尾部（反转之前的头部就是tail）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题的难点在于：</p><ol><li>如果最后不足k个要怎么处理？可以进行二次反转</li><li>res链表的尾部怎么更新？res链表的尾部，相当于反转前那个链表的头部（在反转前需要提前记录）</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24. 两两交换链表中的节点</title>
      <link href="/post/ea8dbaa4.html"/>
      <url>/post/ea8dbaa4.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:/project/kaiFa/Blog/source/_posts/assets/3ab8350bf17c4cfcb454abe3be8041c4.png" alt="3ab8350bf17c4cfcb454abe3be8041c4.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/?envType=study-plan-v2&envId=top-100-liked">24. 两两交换链表中的节点</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="comment">// c、a、b（她们仨的相对顺序）</span></span><br><span class="line">        ListNode *a = head, *b = head-&gt;next, *c = pre;</span><br><span class="line">        <span class="keyword">while</span>(b) &#123;</span><br><span class="line">…            b = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><p><img src="D:/project/kaiFa/Blog/source/_posts/assets/7da52351f9834381ab35dba8c9ba1fe4.png" alt="7da52351f9834381ab35dba8c9ba1fe4.png"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236. 二叉树的最近公共祖先</title>
      <link href="/post/f3c9e58f.html"/>
      <url>/post/f3c9e58f.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\a64590c3341743d0bf0304e71db9ec62.png" alt="a64590c3341743d0bf0304e71db9ec62.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked">236. 二叉树的最近公共祖先</a></p><p><strong>终止条件：</strong></p><ul><li>当root到叶节点终止</li><li>当root是p或q终止（因为要求的是公共祖先，如果遍历到p，就算q还在p的下边，他们的公共祖先还是p）</li></ul><blockquote><p>这也说明了：如果返回的是nullptr，说明p、q不在这棵树中</p></blockquote><p><strong>返回情况：</strong></p><ol><li>left &#x3D;&#x3D; nullptr &amp;&amp; right &#x3D;&#x3D; nullptr：说明root的左右子树都没有p、q，直接返回nullptr</li><li>left !&#x3D; nullptr &amp;&amp; right &#x3D;&#x3D; nullptr：说明p、q在root的左子树中，那么只需要返回left（因为前面只要遇到p或q就会终止，所以此时left就是p、q中相对上边的节点）</li><li>right !&#x3D; nullptr &amp;&amp; left &#x3D;&#x3D; nullptr：说明p、q在root的右子树中，那么只要返回right即可（原因同上）</li><li>right !&#x3D; nullptr &amp;&amp; left !&#x3D; nullptr：说明p、q分散在root的左右子树中，此时root就是他们的最近公共祖先节点</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果root是p 或 q 或 nullptr，就不需要再往下遍历了</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果root不是p 或 q，就继续遍历root的左右子树</span></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123;<span class="comment">// 如果p 和 q都没找到，更不可能有公共祖先了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span>) &#123;<span class="comment">// 如果左子树没有p也没有q，那就返回右子树</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) &#123;<span class="comment">// 如果右子树没有p也没有q，那就返回左子树</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">// 如果p和q分别在左右子树中，那就返回root</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189. 轮转数组</title>
      <link href="/post/5e2556a3.html"/>
      <url>/post/5e2556a3.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\4ff7c04ea2444474a29c3b16a368cff8.png" alt="4ff7c04ea2444474a29c3b16a368cff8.png"><br>【题目】：<a href="https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked">189. 轮转数组</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = begin, j = end; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)<br><img src="D:\project\kaiFa\Blog\source_posts\assets\074a88e5956949eca09251d4b5d947eb.png" alt="074a88e5956949eca09251d4b5d947eb.png"></li></ul><blockquote><p>如图所示，这题可以进行三次反转，先把数组全部反转，再反转前半部分，反转后半部分，即可得到结果。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160. 相交链表</title>
      <link href="/post/f6a6c904.html"/>
      <url>/post/f6a6c904.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:/project/kaiFa/Blog/source/_posts/assets/f638e856d0c74c649797ac1a13d0725e.png" alt="f638e856d0c74c649797ac1a13d0725e.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/?envType=study-plan-v2&envId=top-100-liked">160. 相交链表</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* a = headA, *b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b) &#123;</span><br><span class="line">            a = (a != <span class="literal">NULL</span> ? a-&gt;next : headB);</span><br><span class="line">            b = (b != <span class="literal">NULL</span> ? b-&gt;next : headA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(a + b)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题可以将headA遍历完后遍历headB，把headB遍历完后遍历headA，这样就相当于走了同样的距离。<br><img src="D:/project/kaiFa/Blog/source/_posts/assets/4e66344a6a854294bfc8b17519675fee.png" alt="4e66344a6a854294bfc8b17519675fee.png"><br>不管什么情况，都会退出循环，且都只会遍历（a+b）次，不会有死循环的情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>146. LRU 缓存</title>
      <link href="/post/f17b06ae.html"/>
      <url>/post/f17b06ae.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\47efb427e5be4ca3b429939c5ba578f3.png" alt="47efb427e5be4ca3b429939c5ba578f3.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/lru-cache/?envType=study-plan-v2&envId=top-100-liked">146. LRU 缓存</a></p><p>LRU：最近最少未使用，很少被请求的数据才会被淘汰掉</p><p>本质：让不经常访问的数据往下排，经常访问的数据往上排。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\146740cbbbf944178b8b39d4f003aeb8.png" alt="146740cbbbf944178b8b39d4f003aeb8.png"><br>这样会导致：冷门数据在最下边，热门数据在最上边。<br>如果<code>访问的数据缓存中没有</code>且<code>缓存已经满了</code>：把最下边的数据淘汰掉，再把刚访问的数据放到上边（换页）</p><blockquote><p>分析：</p><ol><li>选用什么数据结构？<br>  数组：添加一个节点，所有节点都要往后移动，时间复杂度O(n)<br>  链表：添加节点、删除节点只需要改变节点指向，时间复杂度O(1)。只需要改变指针的指向即可。由于不仅要直到节点的下一位，还需要直到节点的上一位，所以使用<code>双向链表</code>。</li><li>怎么找到链表的某个节点？<br>  正常查询链表的某个节点，需要逐个遍历链表元素，时间复杂度O(n)。那有没有办法优化到O(1)的时间复杂度呢？</li></ol><blockquote><p>hashMap的查询时间复杂度是O(1)，可以用<code>hashMap</code>来存储链表节点。</p></blockquote><p>最后选择数据结构如下：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2610c61555f54318b69ede27d108c2a6.png" alt="2610c61555f54318b69ede27d108c2a6.png"></p></blockquote><ol><li>双向链表数据结构</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node *pre;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> key, <span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    Node *head; <span class="comment">// 头节点（哨兵）</span></span><br><span class="line">    Node *tail; <span class="comment">// 尾节点（哨兵）</span></span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; mp; <span class="comment">// map</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化双向链表</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(key) == mp.<span class="built_in">end</span>()) &#123; <span class="comment">// 未找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *node = mp[key];</span><br><span class="line">        <span class="built_in">deleteNodeAndInsertHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(key) == mp.<span class="built_in">end</span>()) &#123; <span class="comment">// 缓存中没有</span></span><br><span class="line">            <span class="keyword">if</span>(size == capacity) &#123; <span class="comment">// 缓存已满，调页</span></span><br><span class="line">                Node *delNode = tail-&gt;pre; <span class="comment">// 要调出的节点</span></span><br><span class="line">                <span class="built_in">deleteNode</span>(delNode); <span class="comment">// 调出</span></span><br><span class="line">                mp.<span class="built_in">erase</span>(delNode-&gt;key);<span class="comment">// 更新map</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 缓存未满 - 直接提到头部</span></span><br><span class="line">                ++size; <span class="comment">//更新size</span></span><br><span class="line">            &#125;</span><br><span class="line">            Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            <span class="built_in">insertHead</span>(node); <span class="comment">// 提到头部</span></span><br><span class="line">            mp[key] = node; <span class="comment">// 更新map</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存中有 - 更新 - 提到头部</span></span><br><span class="line">            Node *node = mp[key];</span><br><span class="line">            node-&gt;value = value; <span class="comment">// 更新node</span></span><br><span class="line">            mp[key] = node; <span class="comment">// 更新map</span></span><br><span class="line">            <span class="built_in">deleteNodeAndInsertHead</span>(node); <span class="comment">// 提到头部</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入头部</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertHead</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        head-&gt;next-&gt;pre = node;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;pre = head;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除节点插入头部的连续操作(正常访问一个节点，都需要做这两步操作)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNodeAndInsertHead</span><span class="params">(Node *node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deleteNode</span>(node);</span><br><span class="line">        <span class="built_in">insertHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LRU </tag>
            
            <tag> 双向链表 </tag>
            
            <tag> 哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>142. 环形链表 II</title>
      <link href="/post/2eb6e620.html"/>
      <url>/post/2eb6e620.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\b0b0260fc2c94784b284d6674c964d71.png" alt="b0b0260fc2c94784b284d6674c964d71.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&envId=top-100-liked">142. 环形链表 II</a></p><p>如图所示，如果有环，fast 和 slow必会相遇，此时fast走n圈，slow走一圈。由于：</p><ol><li>n &#x3D; 1：a &#x3D; c</li><li>n &gt; 1：a &#x3D; c + (n - 1)(b + 1)<br>所以可以进行两次遍历，<br>第一次遍历找到相遇点；<br>第二次遍历时，一个指针从相遇点开始遍历，一个指针从head处开始遍历，当这两个指针相遇时，就是到达题目所求节点。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\005b5b4182254e2cbf0e08a445433be9.png" alt="005b5b4182254e2cbf0e08a445433be9.png"></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;<span class="comment">// 不相遇 - 无环</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;<span class="comment">// 相遇 - 有环</span></span><br><span class="line">                ListNode *a = slow, *b = head;</span><br><span class="line">                <span class="keyword">while</span>(a != b) &#123;</span><br><span class="line">                    a = a-&gt;next;</span><br><span class="line">                    b = b-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>为什么slow无法走两圈？<br>极端情况：fast进入环时，fast &#x3D; slow + 1，此时fast以相对速度1远离slow，fast需要走（环长 - 1）步才能与slow相遇，所以慢指针移动的距离 &lt; 环长。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>124. 二叉树中的最大路径和</title>
      <link href="/post/d794b48b.html"/>
      <url>/post/d794b48b.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\0bf4ec81c97e4d4eb476f537c2593593.png" alt="0bf4ec81c97e4d4eb476f537c2593593.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked">124. 二叉树中的最大路径和</a></p><p>这题有两个关键点：</p><ol><li>更新res：<code>res = max(l + r + root-&gt;val, res)</code>，左子树最大链长 + 右子树最大链长 + 根节点的值其实也可以当成一条链</li><li>子树root的最大链长：<code>max(max(l, r) + root-&gt;val, 0)</code>，由于一个子树的链长只能取左子树的最大链长或右子树的最大链长，所以这里先<code>max(l, r)</code>，也别忘了<code>+root-&gt;val</code>，由于这个值可能比0还小，如果比0小那要你还有什么用？直接舍弃好了（0表示什么都不取）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ac69788e56a54247af5d4c3c2abd327f.png" alt="ac69788e56a54247af5d4c3c2abd327f.png"></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">help</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">help</span>(root-&gt;left); <span class="comment">// 左子树的最大链和</span></span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">help</span>(root-&gt;right); <span class="comment">// 右子树的最大链和</span></span><br><span class="line">        res = <span class="built_in">max</span>(l + r + root-&gt;val, res); <span class="comment">// l + r + root-&gt;val：左右子树的联合可以拼成一条链</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(l, r) + root-&gt;val, <span class="number">0</span>); <span class="comment">// 当前子树的联和：max(l, r) + root-&gt;val，因为是链，所以左右子树只能取一条</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>114. 二叉树展开为链表</title>
      <link href="/post/adb4e3e5.html"/>
      <url>/post/adb4e3e5.html</url>
      
        <content type="html"><![CDATA[<p><img src="D:\project\kaiFa\Blog\source_posts\assets\f79fcfec248f4140bc55802b639d9de2.png" alt="f79fcfec248f4140bc55802b639d9de2.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/?envType=study-plan-v2&envId=top-100-liked">114. 二叉树展开为链表</a><br>这题要将一个二叉树转成单链表，且展开后的单链表应该和二叉树的先序遍历相同。<br>如果直接<strong>正向思考</strong>：能不能先序遍历，先处理当前节点（把当前遍历到的节点插入到单链表中），但是这样存在一个问题，此时当前节点的右孩子还没有被遍历到，这样会出现孩子丢失的情况。</p><p>考虑<strong>逆向思考</strong>：题目要求先序遍历（根左右）的结果，那能不能用<code>后序遍历</code>（左右根）呢？这样就不会出现孩子丢失的问题，因为当去更新当前的右指针时，已经遍历过他的右节点了。</p><p>但是如果是后序遍历的话，结点的顺序应该怎么处理呢？目前节点的顺序是和题目所求的节点顺序相反，因此可以考虑<code>头插法</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;right);</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">help</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 根(头插法)</span></span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;right = res;</span><br><span class="line">        res = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">help</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108. 将有序数组转换为二叉搜索树</title>
      <link href="/post/17237f5b.html"/>
      <url>/post/17237f5b.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/c541675fe78149a4827c4f767adde530.png" alt="c541675fe78149a4827c4f767adde530.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked">108. 将有序数组转换为二叉搜索树</a><br>二叉搜索树的特征：左 &lt; 根 &lt; 右<br>所以可以将数组最中间的数作为根节点，依次把根左边的数组和根右边的数组作为左右节点即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">help</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="comment">// [l, r)</span></span><br><span class="line">        <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        node-&gt;left = <span class="built_in">help</span>(nums, l, mid); <span class="comment">// [l, mid)</span></span><br><span class="line">        node-&gt;right = <span class="built_in">help</span>(nums, mid + <span class="number">1</span>, r); <span class="comment">// [mid + 1, r)</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">help</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>注意，[l, r)是左闭右开的情况，所以在后边划分区间的时候，也要始终保持左闭右开。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102. 二叉树的层序遍历</title>
      <link href="/post/ddbff69.html"/>
      <url>/post/ddbff69.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/6d38201234a545f1a0b043ec8db0d5c6.png" alt="6d38201234a545f1a0b043ec8db0d5c6.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked">102. 二叉树的层序遍历</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tempVec; <span class="comment">// 存储一整行的数据</span></span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// 遍历q队列（此时q队列中存储一层的数据 -&gt; 全部出队）</span></span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 入队</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                tempVec.<span class="built_in">push_back</span>(node-&gt;val); </span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tempVec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>这题的难点在于，题目要求是要返回一个二维数组，那怎么去记录每一层的节点呢？在每一次循环的时候，当前队列中的节点就是这一层的节点，因此可以用一个tempVec来存储当前队列中的数据，在每一轮的循环结束时，把tempVec插入结果数组中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命周期&amp;数据共享</title>
      <link href="/post/567bfae1.html"/>
      <url>/post/567bfae1.html</url>
      
        <content type="html"><![CDATA[<h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><h2 id="生命周期-生命周期函数"><a href="#生命周期-生命周期函数" class="headerlink" title="生命周期&amp;生命周期函数"></a>生命周期&amp;生命周期函数</h2><ul><li>生命周期：指一个组件从<strong>创建 -&gt; 运行 -&gt; 销毁</strong>的整个阶段，强调的是一个<strong>时间段</strong>。</li><li>生命周期函数：由vue框架提供的<strong>内置函数</strong>，会伴随着组件的生命周期，自动<strong>按序执行</strong>。</li></ul><h2 id="生命周期函数的分类"><a href="#生命周期函数的分类" class="headerlink" title="生命周期函数的分类"></a>生命周期函数的分类</h2><p>如果没有声明这些函数，运行的时候也会执行这些函数，只是函数体为空。<br><img src="/assets/7a1cc381946d47dd9631da27ce20eced.png" alt="7a1cc381946d47dd9631da27ce20eced.png"></p><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><ol><li>创建阶段（只执行1次）：</li></ol><ul><li>beforeCreate()：基本不用，啥也做不了。</li><li><strong>created()：</strong><ul><li>调用methods中的方法来发起ajax请求服务器中的数据。</li><li>把请求到的数据转存到data中，供template模板使用。</li><li>在created方法里不能操作DOM元素。</li></ul></li><li>beforeMount()：没什么意义，也不能操作DOM元素。</li><li><strong>mounted()：</strong>内存中的DOM结构被渲染到页面上，可以操作DOM结构。</li></ul><ol start="2"><li>运行阶段（用户和组件会产生交互、最少执行0次、最多执行N次）：</li></ol><ul><li>beforeUpdate()：<ul><li>数据发生变化后触发。</li><li>data数据是新的，UI结构是旧的。（新数据还没有渲染到页面中）</li></ul></li><li><strong>updated()：</strong><ul><li>data数据是新的，UI结构也是最新的。</li><li>当数据变化后，为了能够操作到最新的DOM，把代码写到updated里。</li></ul></li></ul><ol start="3"><li>销毁阶段（只执行一次）：</li></ol><ul><li>beforeDestroy()：此时组件仍处于工作状态，尚未销毁。</li><li>destroyed()：组件在浏览器中对应的DOM结构已被完全移除。<br><img src="/assets/22eb9458008f49259e5e46623c7918b7.png" alt="22eb9458008f49259e5e46623c7918b7.png"></li></ul><h1 id="组件之间的数据共享"><a href="#组件之间的数据共享" class="headerlink" title="组件之间的数据共享"></a>组件之间的数据共享</h1><h2 id="组件之间常见的关系"><a href="#组件之间常见的关系" class="headerlink" title="组件之间常见的关系"></a>组件之间常见的关系</h2><ul><li>父子关系</li><li>兄弟关系<br><img src="/assets/77eb444a57fb499783bd0e7fe76cb8c6.png" alt="77eb444a57fb499783bd0e7fe76cb8c6.png"></li></ul><h2 id="父子组件之间的数据共享"><a href="#父子组件之间的数据共享" class="headerlink" title="父子组件之间的数据共享"></a>父子组件之间的数据共享</h2><ol><li>父组件向子组件的数据共享</li></ol><ul><li>需要使用自定义属性props。</li><li>要使用v-bind！</li><li>不要直接去修改props里面的数据。<br><img src="/assets/3fb529ec80c64850a98deeaa047ac767.png" alt="3fb529ec80c64850a98deeaa047ac767.png"></li></ul><ol start="2"><li>子组件向父组件的数据共享</li></ol><ul><li>使用自定义事件</li><li>在子组件中调用$emit来自定义事件</li><li>在父组件中，使用@+在子组件中自定义的事件，来绑定事件，此时的形参就是传递的值。<br><img src="/assets/c78e880e71c043f2b54921d7a4ded8a6.png" alt="c78e880e71c043f2b54921d7a4ded8a6.png"></li></ul><h2 id="兄弟组件之间的数据共享"><a href="#兄弟组件之间的数据共享" class="headerlink" title="兄弟组件之间的数据共享"></a>兄弟组件之间的数据共享</h2><ul><li>兄弟组件之间数据共享的方案是EventBus</li><li>步骤：<ul><li>创建<strong>eventBus.js</strong>模块，并向外共享一个Vue实例对象</li><li>在<strong>数据发送方</strong>，调用<strong>bus.$emit</strong>(‘事件名称’,要发送的数据)方法<strong>触发自定义事件</strong></li><li>在<strong>数据接收方</strong>，在created()中调用<strong>bus.$on</strong>(‘事件名称’,事件处理函数)方法<strong>注册一个自定义事件</strong><br><img src="/assets/ba947b2b158647e2a933ed8f3cdb5bb1.png" alt="ba947b2b158647e2a933ed8f3cdb5bb1.png"></li></ul></li></ul><blockquote><p>如果两个组件之间嵌套关系比较深的话，也可以认为是兄弟组件之间的数据共享。</p></blockquote><h1 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h1><ul><li>jQuery：简化了程序员操作DOM的过程</li><li>vue优势：MVVM 在vue中，程序员不需要操作DOM，只需要把数据维护好即可（数据驱动视图）<ul><li>结论：在vue项目中，强烈不建议安装和使用jQuery</li></ul></li><li>假设：在vue中，需要操作DOM，需要拿到页面上某个DOM元素的应用，此时怎么办？？？<ul><li>vue给程序员提供了ref，可以让程序员在不调用DOM API的前提下，拿到DOM元素的引用。</li></ul></li></ul><hr><h2 id="什么是ref引用"><a href="#什么是ref引用" class="headerlink" title="什么是ref引用"></a>什么是ref引用</h2><p>用来辅助开发者在不依赖于jQuery的情况下，获取DOM元素或组件的引用。</p><ul><li>每个vue组件实例上，都包含一个 $ref 对象，里面存储着对应的DOM元素或组件的引用。</li><li>默认情况：组件的 $ref 指向一个空对象。</li></ul><h2 id="使用ref引用DOM元素"><a href="#使用ref引用DOM元素" class="headerlink" title="使用ref引用DOM元素"></a>使用ref引用DOM元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;div ref=<span class="string">&quot;divRef&quot;</span>&gt;helloworld&lt;/div&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">    change() &#123;</span><br><span class="line">        <span class="built_in">this</span>.$ref.divRef.style.color = <span class="string">&quot;blue&quot;</span>;<span class="comment">//操作DOM元素  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ref引用组件实例"><a href="#使用ref引用组件实例" class="headerlink" title="使用ref引用组件实例"></a>使用ref引用组件实例</h2><p><img src="/assets/ee246a5055834471b7f2f8a7e236b67e.png" alt="ee246a5055834471b7f2f8a7e236b67e.png"></p><blockquote><p>使用场景：在父组件中要调用子组件中的方法，最方便的就是用ref<br>让文本框自动获得焦点：当文本框显示出来之后，如果希望它立刻获得焦点，则可以为文本框添加ref引用，并调用原生DOM对象的.focus()方法即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> 数据共享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装和配置Vant组件库</title>
      <link href="/post/c29e9402.html"/>
      <url>/post/c29e9402.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装和配置Vant组件库"><a href="#安装和配置Vant组件库" class="headerlink" title="安装和配置Vant组件库"></a>安装和配置Vant组件库</h1><p>vant官网：<a href="https://vant-ui.github.io/vant/v2/#/zh-CN/">vant2</a></p><ol><li>执行：<code>npm i vant@latest-v2</code>    安装组件库</li><li>在<strong>开发阶段</strong>，直接导入所有组件，不用考虑体积问题（怎么快怎么来）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vant</span> <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span> <span class="comment">//导入所有组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.css&#x27;</span> <span class="comment">//导入所有组件对应的样式</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vant</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>在<strong>发布阶段</strong>，再进行项目体积的优化。</li></ol><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><ul><li>某个属性的值如果是true，可以简写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;van-nav-bar title=<span class="string">&quot;黑马头条&quot;</span> :fixed=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//以上代码可以简写成：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">van-nav-bar</span> <span class="attr">title</span>=<span class="string">&quot;黑马头条&quot;</span> <span class="attr">fixed</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>覆盖第三方组件样式时，如果直接覆盖不生效，可以考虑在样式前面加上<code>/deep/</code></li></ul><h1 id="Vant定制主题"><a href="#Vant定制主题" class="headerlink" title="Vant定制主题"></a>Vant定制主题</h1><p>核心：less变量的覆盖<br>为了能够覆盖默认的less变量，一定要在main.js文件中把后缀名改成.less<br><code>import &#39;vant/lib/index.less&#39;</code><br>方法1：直接覆盖样式变量（不用）</p><ol><li>新建：vue.config.js文件</li></ol><ul><li>vue.config.js文件是vue-cli创建出来的配置文件</li><li>在vue.config.js这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</li></ul><ol start="2"><li>在文件中把官方文档中的代码复制过去</li></ol><blockquote><p>缺点：每次修改都需要重启服务器</p></blockquote><p>方法2：less文件覆盖</p><ol><li>在src目录下创建theme.less文件<br><img src="/assets/4ecff25ab3a64f7a8da784cc92617b6a.png" alt="4ecff25ab3a64f7a8da784cc92617b6a.png"></li><li>在theme.less文件中，覆盖Vant官方的Less变量值<br><img src="/assets/2ee311095cd34d4db82360c2de8adcc5.png" alt="2ee311095cd34d4db82360c2de8adcc5.png"></li><li>把主题文件的绝对路径填充到vue.config.js中的一个地方：在vue.config.js配置文件中，导入node.js中的核心模块path，来进行绝对路径的拼接</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">// __dirname表示：vue.config.js所在项目根目录</span></span><br><span class="line"><span class="keyword">const</span> themePath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/theme.less&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/assets/1b42f6d364ad4c19a59d960f02d392af.png" alt="1b42f6d364ad4c19a59d960f02d392af.png"></p>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> Vant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的方法</title>
      <link href="/post/36579f38.html"/>
      <url>/post/36579f38.html</url>
      
        <content type="html"><![CDATA[<h1 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h1><ul><li>一旦开始，无法在中间被停止</li><li>效率低</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;工藤新一&#x27;</span>,<span class="string">&#x27;服部平次&#x27;</span>,<span class="string">&#x27;怪盗基德&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;  <span class="comment">//循环3次，return也不会起效果</span></span><br><span class="line">    <span class="keyword">if</span>(item==<span class="string">&#x27;工藤新一&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(index);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="some循环"><a href="#some循环" class="headerlink" title="some循环"></a>some循环</h1><ul><li>从数组里找元素，用some循环比较合适</li><li>找到对应的项后，通过return true来终止some循环</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;工藤新一&#x27;</span>,<span class="string">&#x27;服部平次&#x27;</span>,<span class="string">&#x27;怪盗基德&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;   <span class="comment">//循环2次</span></span><br><span class="line">    <span class="keyword">if</span>(item==<span class="string">&#x27;工藤新一&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//固定写法  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="every循环"><a href="#every循环" class="headerlink" title="every循环"></a>every循环</h1><ul><li>判断每一项是否满足需求</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;西瓜&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;榴莲&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;草莓&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//需求：判断数组中水果是否被全选</span></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">state</span>)</span><br><span class="line"><span class="comment">//括号里是个箭头函数，其实就是判断的简写</span></span><br><span class="line"><span class="comment">//括号里相当于   arr.every(item =&gt; item.state===true)</span></span><br><span class="line"><span class="comment">//如果每一项的state都是true，返回true；只要有一个是false，返回false。</span></span><br></pre></td></tr></table></figure><h1 id="reduce循环"><a href="#reduce循环" class="headerlink" title="reduce循环"></a>reduce循环</h1><ul><li>把每次循环的结果累加起来（累加器）</li><li>格式：reduce( (累加结果, 当前循环项)&#x3D;&gt;{} , 初始值 )</li><li>每次循环，都要返回当前的累加结果，作为累加结果</li><li>返回最后一次循环的累加结果</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;西瓜&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>,<span class="attr">price</span>:<span class="number">10</span>,<span class="attr">count</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;榴莲&#x27;</span>,<span class="attr">state</span>:<span class="literal">false</span>,<span class="attr">price</span>:<span class="number">80</span>,<span class="attr">count</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;草莓&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>,<span class="attr">price</span>:<span class="number">20</span>,<span class="attr">count</span>:<span class="number">3</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//需求：把购物车数组中，已勾选的水果，总价累加出来。</span></span><br><span class="line"><span class="keyword">let</span> sum=<span class="number">0</span>;<span class="comment">//总价</span></span><br><span class="line">arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">state</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    sum += item.<span class="property">price</span> * item.<span class="property">count</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce循环</span></span><br><span class="line"><span class="comment">//arr.filter(item =&gt; item.state)：返回state=true的结果（数组形式）</span></span><br><span class="line"><span class="comment">//reduce( (累加结果, 当前循环项)=&gt;&#123;&#125; , 初始值 )</span></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">state</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">totalprice,item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//第一次循环 totalprice = 0</span></span><br><span class="line">    <span class="comment">//第二次循环 totalprice = 返回的结果值</span></span><br><span class="line">    <span class="keyword">return</span> totalprice += item.<span class="property">price</span> * item.<span class="property">count</span>;</span><br><span class="line">&#125;,<span class="number">0</span>) <span class="comment">//初始值为0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态组件&amp;插槽&amp;自定义指令&amp;ESLint&amp;axios补充</title>
      <link href="/post/704e3643.html"/>
      <url>/post/704e3643.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><h2 id="什么是动态组件"><a href="#什么是动态组件" class="headerlink" title="什么是动态组件"></a>什么是动态组件</h2><p>动态切换组件的显示与隐藏</p><h2 id="如何实现动态组件渲染——component组件"><a href="#如何实现动态组件渲染——component组件" class="headerlink" title="如何实现动态组件渲染——component组件"></a>如何实现动态组件渲染——component组件</h2><p>vue提供了一个内置的component组件，专门用来实现动态组件的渲染。</p><ul><li>component组件类似于占位符</li></ul><h3 id="is属性的值"><a href="#is属性的值" class="headerlink" title="is属性的值"></a>is属性的值</h3><ul><li>表示要渲染组件的名字</li><li>组件在components节点下的注册名称。</li></ul><h3 id="keep-alive标签"><a href="#keep-alive标签" class="headerlink" title="keep-alive标签"></a>keep-alive标签</h3><ul><li>可以把内部的组件进行缓存，而不是销毁组件。</li><li>可以保留之前在这个组件上的操作。</li><li>对应的生命周期函数：<ul><li>当组件<strong>被缓存</strong>时，会自动触发组件的<strong>deactivated</strong>生命周期函数</li><li>当组件<strong>被激活</strong>时，会自动触发组件的<strong>activated</strong>生命周期函数</li><li>当组件<strong>第一次被创建</strong>的时候，即执行created也会执行activated</li><li>当组件<strong>被激活</strong>时，只会触发activated，不再触发created，因为组件没有被创建。</li></ul></li></ul><blockquote><p>可以使用include指定哪些组件需要被缓存，或者使用exclude属性指定哪些组件不需要被缓存，但是<strong>不要同时使用include和exclude这两个属性。</strong><br>include属性：只有<strong>名称匹配</strong>的组件<strong>会被缓存</strong>、多个组件之间使用逗号分割<br>exclude属性：只有<strong>名称匹配</strong>的组件<strong>不会被缓存</strong></p></blockquote><blockquote><p>如果在声明组件的时候，没有为组件指定 name 名称，则组件的名称默认为注册时候的名称。当提供了name属性之后，组件的名称就是name属性的值。</p><ol><li>组件的<strong>注册名称</strong>（在components节点下）的主要应用场景是：<br>以标签的形式，把注册好的组件，渲染和使用到页面结构中。</li><li>组件<strong>声明</strong>（定义组件的时候）时候的“name”名称的主要应用场景是：<br>结合keep-alive标签实现组件的缓存功能<br>在调试工具中看到组件的name名称</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;Left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">comName</span>:<span class="string">&#x27;Left&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>插槽（slot）是vue为组件的封装者提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望由用户指定的部分</strong>定义为插槽。<br><img src="/assets/bccfb8a88b7246fda48ee533f905426f.png" alt="bccfb8a88b7246fda48ee533f905426f.png"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><img src="/assets/67b6c08cac6b4f0d8c545d333e2da0f6.png" alt="67b6c08cac6b4f0d8c545d333e2da0f6.png"></p><h2 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h2><h3 id="slot标签"><a href="#slot标签" class="headerlink" title="slot标签"></a>slot标签</h3><p>vue官方规定，每一个slot插槽，都要有一个name名称；如果省略了slot的name属性，则有一个默认的名称叫做default。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure><p>如果只有一个插槽，一般也会省略name名称。<br>默认情况下，在使用组件的时候，提供的内容都会被填充到名字为default的插槽之中。</p><h3 id="v-slot属性"><a href="#v-slot属性" class="headerlink" title="v-slot属性"></a>v-slot属性</h3><p>v-slot只能用于template元素上。</p><ul><li>如果要把内容填充到指定名称的插槽中，需要使用v-slot: 这个指令</li><li>v-slot: 后面要跟上插槽的名字</li><li>v-slot: 指令不能直接用在元素身上，必须用在template标签上，或者用在一个组件上。</li><li>template这个标签是一个虚拟的标签，只起到包裹性质的作用，但是不会被渲染为任何实质性的html元素。</li><li>v-slot: 指令的简写形式是：**#**</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Left</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h2><p>封装组件时，可以为预留的<slot>插槽提供后备内容。<br>如果使用者没有为插槽提供任何内容，则后备内容会生效。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot&gt;后备内容&lt;/slot&gt;</span><br></pre></td></tr></table></figure><h2 id="具名插槽、作用域插槽"><a href="#具名插槽、作用域插槽" class="headerlink" title="具名插槽、作用域插槽"></a>具名插槽、作用域插槽</h2><p><strong>具名插槽：</strong>为slot插槽指定了name值。<br><strong>作用域插槽：</strong>在封装组件时，为预留的slot标签提供属性对应的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Left组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content-box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">msg</span>=<span class="string">&quot;helloworld.js&quot;</span> <span class="attr">:user</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">userinfo</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">20</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Left组件</span></span><br><span class="line">&lt;<span class="title class_">Left</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content-box</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>content-box的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;scope.msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;scope.user.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content-box</span>=<span class="string">&quot;&#123;msg,user&#125;&quot;</span>&gt;</span>   //解构赋值</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>content-box的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>content的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>约定：一般用一个叫做scope的对象来接收传送过来的值，也可以使用解构赋值来传值。</p></blockquote><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p>vue官方提供了v-tex、v-for、v-model、v-if等常用指令，此外，vue还允许开发者自定义指令。</p><h2 id="自定义指令分类"><a href="#自定义指令分类" class="headerlink" title="自定义指令分类"></a>自定义指令分类</h2><h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><ul><li>每个vue组件中，可以在<strong>directives</strong>节点下声明私有自定义指令。</li><li>指令定义的时候不加 v-xxx ，但是使用的时候，需要加上v-xxx<br><code>&lt;div v-xxx&gt;&lt;/div&gt;</code></li></ul><h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><p>当指令<strong>第一次</strong>被绑定到元素上时，就会立即触发<strong>bind函数</strong>。</p><ul><li>bind的形参：<ul><li>第一个形参el：表示当前指令所绑定到的那个DOM对象</li><li>第二个形参binding（一般叫做binding）：获取指令绑定的值。<ul><li>在binding对象中：value是程序员可以使用的值，expression的值是用户在等号后写的表达式。</li></ul></li></ul></li><li>bind函数缺点：只在元素第一次绑定到元素上时才会触发，如果DOM更新时，bind函数不会重新执行。</li></ul><h4 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a>update函数</h4><p>第一次绑定元素不会调用，但是会在每次<strong>DOM更新</strong>时被调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-color=<span class="string">&quot;color&quot;</span>&gt;<span class="number">12</span>&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-color</span>=<span class="string">&quot;&#x27;red&#x27;&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">color</span>:blue    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">directives</span>:&#123;</span><br><span class="line">    <span class="attr">color</span>:&#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">            <span class="comment">//binding对象中：value是程序员可以使用的值，expression的值是用户在等号后写的表达式</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;        </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//在DOM更新时调用</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">             el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;         </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数简写：如果bind和update函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上代码相当于：</span></span><br><span class="line"><span class="attr">directives</span>:&#123;</span><br><span class="line">    <span class="title function_">color</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><ul><li>全局共享的自定义指令需要通过Vue.directive()进行声明</li><li>全局自定义指令要放到main.js文件中<br><img src="/assets/03b1e683ca50430abb7abe0c1c348264.png" alt="03b1e683ca50430abb7abe0c1c348264.png"></li></ul><blockquote><p>一般来说，定义自定义指令，都是定义全局自定义指令。</p></blockquote><h1 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h1><p><img src="/assets/10561f37113b44cd9d5f2e0cdfb31ac8.png" alt="10561f37113b44cd9d5f2e0cdfb31ac8.png"><br>规则搜索网址：<a href="https://eslint.nodejs.cn/docs/latest/">ESLint中文文档</a></p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p><img src="/assets/443a9135317a47868603d5df4c920c8f.png" alt="443a9135317a47868603d5df4c920c8f.png"><br><img src="/assets/43b6cc86c5e54b408f92fe0a441d9b73.png" alt="43b6cc86c5e54b408f92fe0a441d9b73.png"></p><h2 id="很好用的插件"><a href="#很好用的插件" class="headerlink" title="很好用的插件"></a>很好用的插件</h2><p><img src="/assets/6d7676d4bfaa42559c2dfa4770bae1e6.png" alt="6d7676d4bfaa42559c2dfa4770bae1e6.png"><br>配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ESLint插件的配置</span></span><br><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="/assets/93d54fb8eef5475cb0e6caf6e80515b7.png" alt="93d54fb8eef5475cb0e6caf6e80515b7.png"><br>配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;prettier.configPath&quot;</span>: <span class="string">&quot;C:\\Users\\林诗涵\\.prettierrc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 每行文字个数超出此限制将会被迫换行</span></span><br><span class="line">    <span class="string">&quot;prettier.printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="comment">// 使用单引号替换双引号</span></span><br><span class="line">    <span class="string">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">    <span class="comment">// 设置 .vue 文件中，HTML代码的格式化插件</span></span><br><span class="line">    <span class="string">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>,</span><br><span class="line">    <span class="comment">// 忽略项目中的警告和弹窗</span></span><br><span class="line">    <span class="string">&quot;vetur.ignoreProjectWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;wrap_attributes&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line">            <span class="string">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">            <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// ESLint插件的配置</span></span><br><span class="line">    <span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//导入文件时是否携带文件的扩展名</span></span><br><span class="line">    <span class="string">&quot;path-autocomplete.extensionOnImport&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//配置@的路径提示</span></span><br><span class="line">    <span class="string">&quot;path-autocomplete.pathMappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@&quot;</span>: <span class="string">&quot;$&#123;folder&#125;/src&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;editor.tabSize&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;[vue]&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="挂在axios"><a href="#挂在axios" class="headerlink" title="挂在axios"></a>挂在axios</h1><p>如果很多.vue组件中要发起请求，每次导入axios会很麻烦，此时可以<strong>把axios挂载到Vue的原型上，并配置请求根路径。</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在main.js文件中：</p><ol><li>引入axios：import axios from ‘axios’</li><li>全局配置axios的请求根路径：axios.defaults.baseURL &#x3D; ‘请求根路径’</li><li>把axios挂载到Vue原型上，供每个.vue组件的实例直接调用：Vue.prototype.$http &#x3D; axios</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在某个.vue组件中需要使用axios，就不需要导入，直接调用this.$http.xxx</li><li>在某个发送axios请求的组件中就不需要写完整的请求地址了。<br><code>例：this.$http.get(&#39;/top/get&#39;);</code></li></ul><blockquote><p>好处：在vue的组件中，使用this.$http就可以发起请求<br>坏处：不利于API接口的复用</p></blockquote><p>在实际开发中，封装一个request.js模块，创建小axios，并共享出去<br><img src="/assets/7079b9d967044d43965164cccf23c051.png" alt="7079b9d967044d43965164cccf23c051.png"><br><img src="/assets/e5c3299d3a504ed2a62c8e430c9f3b5b.png" alt="e5c3299d3a504ed2a62c8e430c9f3b5b.png"><br>request.js内容：<br><img src="/assets/97d317e3d1394b4b8f5d5056f9cde071.png" alt="97d317e3d1394b4b8f5d5056f9cde071.png"><br>今后如果要调接口，就导入utils&#x2F;request.js，就可以得到request实例，也不需要指定根路径，填URL地址即可。（封装API步骤如下）</p><h3 id="封装API"><a href="#封装API" class="headerlink" title="封装API"></a>封装API</h3><ol><li>在src目录下新建一个api文件夹，在下面存放封装的api接口<br><img src="/assets/6964f4e813e0415fa2034a6b9410242d.png" alt="6964f4e813e0415fa2034a6b9410242d.png"></li></ol><ul><li>因为API需要发送请求，所以先导入上面封装的utils&#x2F;request.js<br><img src="/assets/3ae5be252f074e94bc3af1ef5edcd935.png" alt="3ae5be252f074e94bc3af1ef5edcd935.png"></li><li>向外导出API函数，调用request.xxx方法</li><li>一定要把Promise的返回值return出去</li></ul><ol start="2"><li>如果需要使用API的话：先导入API，再调用方法（注意点：传参、await、async）<br><img src="/assets/ca83c91e152a46249e7f880f1d9182d2.png" alt="ca83c91e152a46249e7f880f1d9182d2.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue2 </tag>
            
            <tag> 动态组件 </tag>
            
            <tag> 插槽 </tag>
            
            <tag> 自定义指令 </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2-vue基础入门（二）</title>
      <link href="/post/fdb563fa.html"/>
      <url>/post/fdb563fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h1><h2 id="什么是watch侦听器"><a href="#什么是watch侦听器" class="headerlink" title="什么是watch侦听器"></a>什么是watch侦听器</h2><p>允许开发者监视数据的变化，从而针对数据的变化做特定的操作。</p><ul><li>数据值发生变化，就会自动触发侦听器。 </li><li>所有侦听器都被定义到watch节点下。</li><li>侦听器本质是个函数，要监视哪个数据的变化，就把数据名作为方法名即可。 </li><li>侦听器的参数是新值在前，旧值在后。</li><li>典型应用场景：判断用户名是否被占用。</li></ul><h2 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h2><h3 id="方法格式的侦听器（先考虑）"><a href="#方法格式的侦听器（先考虑）" class="headerlink" title="方法格式的侦听器（先考虑）"></a>方法格式的侦听器（先考虑）</h3><ul><li>缺点1：无法在刚进入页面的时候立即触发。</li><li>缺点2：如果真听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器。<ul><li>如果要侦听的是对象子属性的变化，可以使用该方法，但是注意：必须包裹一层单引号。</li></ul></li></ul><h3 id="对象格式的侦听器"><a href="#对象格式的侦听器" class="headerlink" title="对象格式的侦听器"></a>对象格式的侦听器</h3><ul><li>好处1：可以通过<strong>immediate</strong>选项，让侦听器自动触发。<ul><li>immediate作用：控制侦听器是否自动触发一次。</li><li>默认值是false，true表示一进入页面就会触发一次侦听器。</li></ul></li><li>好处2：可以通过<strong>deep</strong>选项，让侦听器深度侦听对象中每个属性的变化。<ul><li>deep作用：只要对象中任何一个属性变化了，都会触发“对象的侦听器”。</li><li>默认值是false。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法格式的侦听器</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;<span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="comment">//newVal:变化后的新值，oldVal:变化前的旧值</span></span><br><span class="line">        <span class="comment">//监听username值的变化</span></span><br><span class="line">        <span class="title function_">username</span>(<span class="params">newVal,oldVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象格式的侦听器</span></span><br><span class="line"><span class="comment">//（immediate）</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>:&#123;</span><br><span class="line">        <span class="comment">//侦听器的处理函数(只要监视到username值的变化，就会触发该函数)</span></span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal);                            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//immediate选项的默认值是false，true表示一进入页面就会触发一次侦听器。</span></span><br><span class="line">        <span class="comment">//作用：控制侦听器是否自动触发一次。</span></span><br><span class="line">        <span class="attr">immediate</span>:<span class="literal">true</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（deep）</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;info.username&quot;</span>/&gt;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&#x27;admin&#x27;</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal.<span class="property">username</span>);        </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//开启深度监听，只要对象中任何一个属性变化了，都会触发“对象的侦听器”</span></span><br><span class="line">        <span class="attr">deep</span>:<span class="literal">true</span>,    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果只监听username，也可以用如下代码</span></span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span> (newVal) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal); <span class="comment">//得到的就是info对象里的username值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或：</span></span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span>:&#123;</span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal);     </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>计算属性指<strong>通过一系列运算</strong>后，最终得到一个<strong>属性值</strong>，这个<strong>动态计算出来的属性值</strong>可以被模板结构或methods方法使用。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>定义的时候，要被定义成“方法”</li><li>使用的时候，当普通属性使用即可。</li><li>被定义到computed节点下。</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>实现了代码的复用。</li><li>当计算属性所依赖的数据源发生变化，计算属性会自动重新求值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;rgb&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="title function_">rgb</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`rgb&#123;$(this.r),$(this.g),$(this.b)&#125;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios是一个专注于数据请求的库。</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>调用axios方法得到的返回值result是个Promise对象【axios在请求到数据之后，在真正的数据之外套了一层壳】。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">config:&#123;&#125;,</span><br><span class="line">data:&#123;真实的数据&#125;,</span><br><span class="line">header:&#123;&#125;,</span><br><span class="line">request:&#123;&#125;,</span><br><span class="line">status:xxx,</span><br><span class="line">statusText:&#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h2><ul><li>调用axios之后，使用 async&#x2F;await 进行简化。<ul><li>如果调用某个方法的返回值是Promise实例，则前面可以添加await</li><li>await只能用在被 async “修饰”的方法中</li></ul></li><li>使用解构赋值，从axios封装的大对象中，把data属性解构出来。</li><li>把解构出来的data属性，使用 冒号 进行重命名，一般都重命名为 { data: res }</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法如下：</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;请求的URL地址&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;<span class="variable constant_">URL</span>中的查询参数&#125;, <span class="comment">//GET传参</span></span><br><span class="line">    <span class="attr">data</span>:&#123;请求体参数&#125; <span class="comment">//POST传参</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(result) =&gt; &#123;</span><br><span class="line">    <span class="comment">// .then用来指定成功之后的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//发起GET请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">methos</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;<span class="attr">id</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起POST请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">methosd</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">20</span>    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化：!!!!!</span></span><br><span class="line"><span class="comment">//规则：如果调用某个方法的返回值是Promise实例，则前面可以添加await</span></span><br><span class="line"><span class="comment">//await只能用在被 async “修饰”的方法中</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//解构赋值的时候，使用 : 进行重命名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>:res &#125; = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;  <span class="comment">//解构赋值</span></span><br><span class="line">        <span class="attr">methosd</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">           <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">           <span class="attr">age</span>:<span class="number">20</span>    </span><br><span class="line">       &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br></pre></td></tr></table></figure><h2 id="axios直接发起GET和POST请求"><a href="#axios直接发起GET和POST请求" class="headerlink" title="axios直接发起GET和POST请求"></a>axios直接发起GET和POST请求</h2><p>请求数据发GET，传输数据发POST</p><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;url地址&#x27;</span> [,&#123;</span><br><span class="line">    <span class="attr">params</span>:&#123;<span class="variable constant_">GET</span>参数&#125;</span><br><span class="line">&#125;] )</span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>:res &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">params</span>:&#123;</span><br><span class="line">            <span class="attr">id</span>:<span class="number">1</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;url地址&#x27;</span> [,&#123; <span class="variable constant_">POST</span>请求体数据 &#125;] )</span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>:res &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;&#x27;</span><span class="attr">http</span>:<span class="comment">//www.liulongbin.top:3306/api/getbooks&#x27;&#x27;,&#123;</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">    &#125;,<span class="attr">headers</span>:&#123;<span class="string">&#x27;Authorization&#x27;</span>:<span class="string">&#x27;本机token&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h1><h2 id="单页面应用程序（SPA）"><a href="#单页面应用程序（SPA）" class="headerlink" title="单页面应用程序（SPA）"></a>单页面应用程序（SPA）</h2><p>指<strong>一个web网站中只有唯一的一个HTML页面</strong>，所有的功能与交互都在这唯一的一个页面内完成。</p><h2 id="什么是vue-cli"><a href="#什么是vue-cli" class="headerlink" title="什么是vue-cli"></a>什么是vue-cli</h2><p>vue-cli是Vue.js开发的标准工具，它简化了程序员基于webpack创建工程化的Vue项目的过程。因此，程序员可以专注在撰写应用上，而不必纠结webpack配置的问题。<br>网址：<a href="https://cli.vuejs.org/zh/guide/">介绍 | Vue CLI (vuejs.org)</a></p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><ul><li>vue-cli是npm上的全局包，在终端上输入 npm install -g @vue&#x2F;cli 就可以安装成功了。<ul><li>使用 vue–V 指令可以判断是否安装成功</li></ul></li><li>vue-cli的使用：<ul><li>在终端下运行如下命令，创建指定名称的项目： vue create 项目名<br><img src="/assets/e14baa3852e342578e631a74d8453c6b.png" alt="e14baa3852e342578e631a74d8453c6b.png"><br><img src="/assets/7175be17ef9b470fae6adf67ef2ca418.png" alt="7175be17ef9b470fae6adf67ef2ca418.png"><br><img src="/assets/587c36e7a7a94f7fafd78ee209517a5c.png" alt="587c36e7a7a94f7fafd78ee209517a5c.png"><br><img src="/assets/ac3239327e20486c9ac0729d48d6346c.png" alt="ac3239327e20486c9ac0729d48d6346c.png"><br><img src="/assets/fd489e1b7129498c9fc14cc22533b39f.png" alt="fd489e1b7129498c9fc14cc22533b39f.png"><br><img src="/assets/2592a4676d9c437c8cbaa806d92de3b0.png" alt="2592a4676d9c437c8cbaa806d92de3b0.png"></li></ul></li></ul><h3 id="vue项目中src目录的构成"><a href="#vue项目中src目录的构成" class="headerlink" title="vue项目中src目录的构成"></a>vue项目中src目录的构成</h3><p><img src="/assets/4bdf91a9d1cd41eba7d3ed858a68fd65.png" alt="4bdf91a9d1cd41eba7d3ed858a68fd65.png"></p><ul><li>assets文件夹： 存放项目中用到的静态资源文件。（css样式表、图片资源）</li><li>components文件夹：程序员封装的、可复用的组件，都要放在components目录下。</li><li>main.js：是项目的入口文件，整个项目的运行，要先执行main.js。</li><li>APP.vue：是项目的根组件。</li></ul><h2 id="vue项目的运行流程"><a href="#vue项目的运行流程" class="headerlink" title="vue项目的运行流程"></a>vue项目的运行流程</h2><p>在工程化的项目中，vue通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。<br><img src="/assets/aaded890e40f4fe9b688c0a250beac3b.png" alt="aaded890e40f4fe9b688c0a250beac3b.png"></p><ul><li><strong>App.vue</strong> 用来编写待渲染的<strong>模板结构</strong> （render函数中，渲染的是哪个.vue组件，这个组件就叫做根组件）</li><li><strong>index.html</strong>中需要预留一个<strong>el区域</strong></li><li><strong>main.js</strong>把App.vue渲染到index.html所预留的区域中</li></ul><h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h1><h2 id="什么是组件化开发"><a href="#什么是组件化开发" class="headerlink" title="什么是组件化开发"></a>什么是组件化开发</h2><p>根据封装的思想，把页面上可复用的UI结构封装为组件。</p><h2 id="vue项目中的组件化开发"><a href="#vue项目中的组件化开发" class="headerlink" title="vue项目中的组件化开发"></a>vue项目中的组件化开发</h2><ol><li>vue是个支持组件化开发的前端框架</li><li>vue规定：组建的后缀名是.vue</li></ol><h3 id="组件的三个组成部分"><a href="#组件的三个组成部分" class="headerlink" title="组件的三个组成部分"></a>组件的三个组成部分</h3><h4 id="template：组件的模板结构（要复用的UI结构）"><a href="#template：组件的模板结构（要复用的UI结构）" class="headerlink" title="template：组件的模板结构（要复用的UI结构）"></a>template：组件的模板结构（要复用的UI结构）</h4><ol start="3"><li>组件的模板元素中，只能有一个根节点！</li><li>一般根节点的类名就是xxx-container（xxx为组件名）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pink&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改用户名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="script：-组件的JavaScript行为"><a href="#script：-组件的JavaScript行为" class="headerlink" title="script： 组件的JavaScript行为"></a>script： 组件的JavaScript行为</h4><ol start="5"><li>使用export default默认导出</li><li>组件中的data必须是个函数   data() {  return { 定义数据 }   }</li><li>在组件中，this表示当前组件的实例对象</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//默认导出！固定写法！</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//注意！！ .vue中的data，不能像之前一样，不能指向对象。</span></span><br><span class="line">    <span class="comment">//组件中的data数据源必须是个函数</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//这个return 出去的&#123; &#125;可以定义数据。</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">             <span class="attr">username</span>:<span class="string">&#x27;lsh&#x27;</span>       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;33&quot;</span>      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//当前组件中的计算属性、侦听器、过滤器</span></span><br><span class="line">    <span class="attr">computed</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">filters</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="style：组件的样式"><a href="#style：组件的样式" class="headerlink" title="style：组件的样式"></a>style：组件的样式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//style中启动less语法</span></span><br><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span>&gt;</span><br><span class="line">.<span class="property">pink</span> &#123;</span><br><span class="line">    <span class="attr">color</span>:pink;</span><br><span class="line">    h3 &#123;</span><br><span class="line">        <span class="attr">color</span>:red;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件之间的父子关系"><a href="#组件之间的父子关系" class="headerlink" title="组件之间的父子关系"></a>组件之间的父子关系</h2><p><img src="/assets/23de26cfde744602ad2c63820c0777c2.png" alt="23de26cfde744602ad2c63820c0777c2.png"></p><h3 id="使用组件的三个步骤"><a href="#使用组件的三个步骤" class="headerlink" title="使用组件的三个步骤"></a>使用组件的三个步骤</h3><ol><li>使用import语法导入需要的组件。（在script里面导入）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Left</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Left.vue&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用components结点注册组件</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        <span class="title class_">Left</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>以标签形式使用刚才注册的组件</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Left</span>&gt;</span><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通过components注册的是<strong>私有子组件</strong><br>    缺点：如果某个组件使用频率高，会很麻烦</p></blockquote><blockquote><p>注册全局组件：在vue项目的main.js入口文件中，通过Vue.components()方法，可以注册全局组件。<br>import Count from ‘@&#x2F;components&#x2F;Count.vue’<br>Vue.component(‘Count’,Count);</p></blockquote><h2 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h2><p>props是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大地提高组件的复用性。</p><h3 id="v-bind（父传子，加了准没错！）"><a href="#v-bind（父传子，加了准没错！）" class="headerlink" title="v-bind（父传子，加了准没错！）"></a>v-bind（父传子，加了准没错！）</h3><ul><li>当传递的是个数字，而不是data里的数据时：<ul><li>不使用v-bind传递的是字符串。</li><li>使用v-bind传递的是数字。</li></ul></li><li>当传递的是个data里面的数据时：<ul><li>不使用v-bind传递的是该数据的变量名。</li><li>使用v-bind传递的是该数据的属性值。</li></ul></li></ul><h3 id="props中的数据"><a href="#props中的数据" class="headerlink" title="props中的数据"></a>props中的数据</h3><ul><li>props中的数据，可以直接在模板结构中被使用</li><li>props中的数据是只读的，程序员不能修改props的值，否则终端会报错。<ul><li>想要修改props的值，可以把props的值转存到data中，因为data中的数据都是可读可写的。</li></ul></li></ul><h3 id="default设置默认值"><a href="#default设置默认值" class="headerlink" title="default设置默认值"></a>default设置默认值</h3><ul><li>把props改成<strong>对象形式</strong>，里面通过default指定默认值。</li><li>外界如果没有传递属性，则默认值生效</li><li>如果要给对象设置默认值：<br><img src="/assets/86269b196606447a9dc81b98e62d7831.png" alt="86269b196606447a9dc81b98e62d7831.png"></li></ul><h3 id="type定义属性的值"><a href="#type定义属性的值" class="headerlink" title="type定义属性的值"></a>type定义属性的值</h3><ul><li>在声明自定义属性时，可以通过type来定义属性的值类型</li><li>如果传递过来的值不符合此类型，则会在终端报错</li><li>Number、Boolean、String、Array、Object…</li><li>可以通过数组形式，为当前属性定义多个可能的类型。type: [Number, String]</li></ul><h3 id="require必填项"><a href="#require必填项" class="headerlink" title="require必填项"></a>require必填项</h3><ul><li>某个属性如果设置required的值为true，则必须要传递改属性。</li><li>required只关心是否传值，不关心传递类型是否符合。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//组件的自定义属性</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;自定义属性A&#x27;</span>,<span class="string">&#x27;自定义属性B&#x27;</span>,<span class="string">&#x27;其他自定义属性...&#x27;</span>],</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="comment">//外界使用该组件，没有传这些属性，则默认值生效</span></span><br><span class="line">        自定义属性<span class="attr">A</span>:&#123;</span><br><span class="line">        <span class="attr">default</span>:默认值<span class="number">1</span>,</span><br><span class="line">         <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">//规定传值类型</span></span><br><span class="line">           <span class="attr">required</span>:<span class="literal">true</span> <span class="comment">//必填项校验</span></span><br><span class="line">         &#125;,</span><br><span class="line">        自定义属性<span class="attr">B</span>:&#123;<span class="attr">defalt</span>:默认值<span class="number">2</span>&#125;,   </span><br><span class="line">        自定义属性<span class="attr">C</span>:&#123;<span class="attr">defalt</span>:默认值<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//组件的私有数据</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//Count.vue文件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Count的值：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],<span class="comment">//这样如果别的组件想要给Count传值的话，可以通过init来传</span></span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="attr">init</span>:&#123;</span><br><span class="line">            <span class="comment">//用default属性定义属性的默认值</span></span><br><span class="line">            <span class="attr">default</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">init</span>       </span><br><span class="line">       &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.vue文件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="comment">//不使用v-bind 传递的是字符串</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//使用v-bind 传递的是数字</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">:init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="组件之间的样式冲突"><a href="#组件之间的样式冲突" class="headerlink" title="组件之间的样式冲突"></a>组件之间的样式冲突</h2><p>默认情况下，写在.vue里的组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul><li>单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的。</li><li>每个组件的样式，都会影响整个index.html页面的DOM元素。</li></ul><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><ul><li>给当前组件的style添加 scoped 属性。</li><li>当使用给第三方组件库的时候，如果有修改组件默认样式的需求，需要用到**&#x2F;deep&#x2F;**</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>【补】：浏览器无法正常解析.vue结尾的文件<br>“vue-template-compiler”: “^2.6.11”：vue模板编译器（帮助程序员将.vue结尾的文件编译成js，再交给浏览器去解析）</p></blockquote><blockquote><p>【关于自定义属性的传值问题】：一般来说，传值不要传对象，传的是对象里的每个属性。这样可复用性强。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2-vue基础入门（一）</title>
      <link href="/post/cda38f22.html"/>
      <url>/post/cda38f22.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue简介"><a href="#vue简介" class="headerlink" title="vue简介"></a>vue简介</h1><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>1.构建用户界面 </p><ul><li>用vue往html页面中填充数据，非常方便</li></ul><p>2.框架</p><ul><li>是一套现成的解决方案，程序员只能遵守框架的规范去编写自己的业务功能。</li><li>要学习vue，就是在学习vue框架中规定的用法</li><li>vue的指令、组件（对UI结构的复用）、路由、Vuex</li></ul><h2 id="vue的特性"><a href="#vue的特性" class="headerlink" title="vue的特性"></a>vue的特性</h2><h3 id="1-数据驱动视图"><a href="#1-数据驱动视图" class="headerlink" title="1.数据驱动视图"></a>1.<strong>数据</strong>驱动视图</h3><ul><li>数据的变化会驱动视图自动更新</li><li>好处：程序员只管把数据维护好，页面结构会被vue<strong>自动</strong>渲染出来。</li><li>数据驱动视图是<strong>单向的数据绑定</strong>。（页面结构的变化不会同步到数据中去）</li></ul><p><img src="/assets/c10cfbffc2504956b50579fe8e30b3e8.png" alt="c10cfbffc2504956b50579fe8e30b3e8.png"></p><h3 id="2-双向数据绑定"><a href="#2-双向数据绑定" class="headerlink" title="2.双向数据绑定"></a>2.双向<strong>数据</strong>绑定</h3><ul><li>在网页中，form表单负责<strong>采集数据</strong>，Ajax负责<strong>提交数据</strong>。</li><li>js数据的变化，会被自动渲染到页面上。</li><li>页面上表单采集的数据发生变化，会被vue自动获取，并更新到js数据中心。</li></ul><p><img src="/assets/44be56c67c1c4f308bc2cc1af57f40af.png" alt="44be56c67c1c4f308bc2cc1af57f40af.png"></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM是vue实现<strong>数据驱动视图</strong>和<strong>双向数据绑定</strong>的核心原理。MVVM指的是<strong>M</strong>odel（数据源）、<strong>V</strong>iew（视图）、<strong>V</strong>iew<strong>M</strong>odel（vue的实例）。</p><p>他把每个HTML页面都拆成了三部分，如图：</p><p><img src="/assets/1b92f982d04042edb3f23956be6dca56.png" alt="1b92f982d04042edb3f23956be6dca56.png"></p><p>ViewModel作为MVVM的核心，他把当前页面的<strong>数据源</strong>（Model）和<strong>页面的结构</strong>（View）连接到了一起。</p><p><img src="/assets/47c551c8af3b4fca921482e5e1ec5029.png" alt="47c551c8af3b4fca921482e5e1ec5029.png"></p><h1 id="vue的基本使用"><a href="#vue的基本使用" class="headerlink" title="vue的基本使用"></a>vue的基本使用</h1><h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><p>1.导入vue.js的script脚本文件</p><p>2.在页面中声明一个将要被vue所控制的DOM区域</p><p>3.创建vm实例对象（vue实例对象）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希望vue能够控制下面这个div，帮我们填充数据</span></span><br><span class="line">&lt;div id = <span class="string">&quot;app&quot;</span>&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.导入vue的库文件，在window全局就有了Vue这个构造函数</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//2.创建Vue的实例对象</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//创建Vue的实例对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//el属性是固定写法，表示当前vm实例要控制页面上的哪个区域，接收的值是一个选择器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果传的是个标签名，那么vue只会控制第一个标签。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//data对象就是要渲染到页面上的数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">username</span>:<span class="string">&#x27;03&#x27;</span>        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：实际开发的时候，一般在最外层加一个div标签，id&#x3D;”app”，然后让vue控制这个最外层的div即可</p></blockquote><h2 id="基本代码和MVVM的对应关系"><a href="#基本代码和MVVM的对应关系" class="headerlink" title="基本代码和MVVM的对应关系"></a>基本代码和MVVM的对应关系</h2><p><img src="/assets/793b138f56ce4604b62a87da9524dfff.png" alt="793b138f56ce4604b62a87da9524dfff.png"></p><h1 id="vue的调试工具"><a href="#vue的调试工具" class="headerlink" title="vue的调试工具"></a>vue的调试工具</h1><p>vue-devtools工具很好用，自己去网上搜下载步骤，别忘了配置才能使用。</p><p>下载完就可以如下图所示看到了：</p><p><img src="/assets/3478b3e9f7f14ada8eeae4a107026705.png" alt="3478b3e9f7f14ada8eeae4a107026705.png"></p><h1 id="vue的指令"><a href="#vue的指令" class="headerlink" title="vue的指令"></a>vue的指令</h1><h2 id="指令的概念"><a href="#指令的概念" class="headerlink" title="指令的概念"></a>指令的概念</h2><p>指令是vue为开发者提供的模板语法，辅助开发者渲染页面的基本结构。（最基础）</p><h2 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h2><p>辅助开发者<strong>渲染DOM元素</strong>的文本内容。</p><h3 id="1）v-text指令"><a href="#1）v-text指令" class="headerlink" title="1）v-text指令"></a>1）v-text指令</h3><ul><li>缺点：会覆盖元素内部原有的内容。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//覆盖“姓名”</span></span><br><span class="line">&lt;p v-text=<span class="string">&quot;username&quot;</span>&gt;姓名&lt;/p&gt; </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="2）语法"><a href="#2）语法" class="headerlink" title="2）语法"></a>2）语法</h3><ul><li>语法的专业名称是**插值表达式**（英文名是：Mustache）</li><li>专门用来解决v-text的内容覆盖问题，只是内容的占位符，不会覆盖原有内容。</li><li>注意：插值表达式只能用于元素的内容结点中，不能用于元素的属性节点中。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;姓名：&#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="3）v-html指令"><a href="#3）v-html指令" class="headerlink" title="3）v-html指令"></a>3）v-html指令</h3><p><strong>v-text</strong>和<strong>插值表达式</strong>只能渲染<strong>纯文本</strong>内容。如果要把<strong>包含HTML标签的字符串</strong>渲染为页面的HTML元素，则使用v-html指令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//info里面包含了HTML标签</span></span><br><span class="line">&lt;p v-html=<span class="string">&quot;info&quot;</span>&gt;姓名&lt;/p&gt; </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h2><p>需要为元素的属性<strong>动态绑定属性值</strong>，则用到<strong>v-bind</strong>属性绑定指令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-<span class="attr">bind</span>:placeholder=<span class="string">&quot;tips&quot;</span>&gt;</span><br><span class="line"><span class="comment">//vue 规定 &quot;v-bind:&quot; 指令可以简写为 &quot;:&quot;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:placeholder</span>=<span class="string">&quot;tips&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="使用JavaScript表达式"><a href="#使用JavaScript表达式" class="headerlink" title="使用JavaScript表达式"></a>使用JavaScript表达式</h2><p>在vue提供的模板渲染语法中，除了支持<strong>绑定简单的数据值</strong>之外，还支持<strong>JavaScript表达式的运算</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number+<span class="number">1</span> &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? <span class="string">&#x27;YES&#x27;</span> : <span class="string">&#x27;NO&#x27;</span> &#125;&#125;</span><br><span class="line"><span class="comment">//在使用v-bind属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号</span></span><br><span class="line">&lt;div :title=<span class="string">&quot; &#x27;box-&#x27; + index &quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="事件绑定指令"><a href="#事件绑定指令" class="headerlink" title="事件绑定指令"></a>事件绑定指令</h2><h3 id="1-事件绑定指令"><a href="#1-事件绑定指令" class="headerlink" title="1.事件绑定指令"></a>1.事件绑定指令</h3><p>vue提供了v-on事件绑定指令，来辅助程序员为DOM元素监听事件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id = <span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//如果没有参数的话，可以不加()</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span> = <span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span> = <span class="string">&quot;sub(2)&quot;</span>&gt;</span>-2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//v-on: 指令可以被简写成 @</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&quot;sub(3)&quot;</span>&gt;</span>-3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//vue提供了内置变量，叫做$event，他就是原生DOM的事件对象e</span></span><br><span class="line">    <span class="comment">//如果默默认的事件对象e被覆盖了，则可以手动传一个$event</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&quot;add(2,$event)&quot;</span>&gt;</span>+2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">count</span>:<span class="number">0</span>        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//定义事件的处理函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">add</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//vm.count++;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//this可以替代vm</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">count</span>++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//以上代码可以简写成：</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">sub</span>(<span class="params">n</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">count</span>-=<span class="number">2</span>;         </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//按下按钮后自增2，并且按钮颜色变为红色</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">red</span>(<span class="params">n,e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">count</span>+=<span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;            </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：原生DOM对象有onclick、oninput、onkeyup等原生事件，替换为vue的事件绑定形式后，分别为@click、@input、@keyup</p></blockquote><h3 id="2-事件修饰符"><a href="#2-事件修饰符" class="headerlink" title="2.事件修饰符"></a>2.事件修饰符</h3><p>在事件处理函数中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。因此，vue提供了事件修饰符的概念，用来辅助程序员更方便的对事件的触发进行控制。</p><p><img src="/assets/a9c17ac39605413bb53b6fd10087d4cb.png" alt="a9c17ac39605413bb53b6fd10087d4cb.png"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阻止默认行为  阻止a链接跳转</span></span><br><span class="line">&lt;a @click.<span class="property">prevent</span>=<span class="string">&quot;show&quot;</span>&gt;a链接&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻止事件冒泡（点击里面的标签，会先触发里面的click再触发外面的click）</span></span><br><span class="line"><span class="comment">//不阻止冒泡的话：点击button按钮，会先调用fun1()，再调用fun2()</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;fun2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span> = <span class="string">&quot;fun1&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="3-按键修饰符"><a href="#3-按键修饰符" class="headerlink" title="3.按键修饰符"></a>3.按键修饰符</h3><p>在监听键盘事件时，我们需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> @keyup.<span class="property">esc</span>=<span class="string">&quot;clearInput&quot;</span> @click.<span class="property">enter</span>=<span class="string">&quot;commitAjax&quot;</span>&gt;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//清空文本框操作</span></span><br><span class="line">    <span class="title function_">clearInput</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">commitAjax</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;enter键按下,commitAjax()方法被调用&quot;</span>)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="双向绑定指令"><a href="#双向绑定指令" class="headerlink" title="双向绑定指令"></a>双向绑定指令</h2><p>vue提供了v-model双向数据绑定指令，用来辅助开发者在不操作DOM的前提下，快速获取表单的数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v-model是双向的数据绑定（此时可以不用在使用value属性了）</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line"><span class="comment">//v-blind是单向的数据绑定（数据源的变化会同步到页面上，但是页面上的变化不会同步到数据源）</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：只有表单元素使用v-model才有意义。div如果使用了v-model，没有意义；因为div并不能够修改它里面的数据。</p><p>使用范围：</p><ul><li>textarea</li><li>select</li><li>input输入框 <ul><li>type&#x3D;”xxx”</li><li>type&#x3D;”checkbox”</li><li>type&#x3D;”radio”</li></ul></li></ul></blockquote><h3 id="v-model指令的修饰符"><a href="#v-model指令的修饰符" class="headerlink" title="v-model指令的修饰符"></a>v-model指令的修饰符</h3><p>为了方便对用户输入的内容进行处理。</p><p><img src="/assets/b3929077e43d410e8710a5d134c6ee54.png" alt="b3929077e43d410e8710a5d134c6ee54.png"></p><h2 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h2><p>辅助开发者按需控制DOM的显示与隐藏。</p><ul><li>v-if（常用） <ul><li>原理：每次动态创建或移除元素，来实现元素的显示和隐藏</li><li>如果刚进入页面的时候，某些元素默认不需要被显示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能会更好。</li><li>常与v-else-if（出现率低） 和 v-else （常用）配套使用 【v-else-if指令必须配合v-if一起使用，否则它将不会被识别！】</li></ul></li><li>v-show <ul><li>原理：动态为元素添加或移除 style&#x3D;”display:none;” 样式，来实现元素的显示和隐藏。</li><li>如果要频繁的切换元素的显示状态，用v-show性能更好</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p v-<span class="keyword">if</span>=<span class="string">&quot;flag&quot;</span>&gt;这是被v-<span class="keyword">if</span>控制的元素&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-ishow</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是被v-show控制的元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h2><p>用来辅助开发者<strong>基于一个数组来循环渲染一个列表结构</strong>。</p><p>v-for指令需要使用 <strong>item in items</strong> 形式的特殊语法，其中：</p><ul><li>items是<strong>待循环的数组</strong></li><li>item是<strong>被循环的每一项</strong></li></ul><p>v-for中的索引：</p><ul><li>语法格式：**(item,index) in items**</li></ul><p>v-for中的key值：</p><ul><li>官方建议，只要用到v-for，一定要绑定一个 :key 属性，而且尽量<strong>把id作为key的值（避免重复）</strong>。</li><li>key的值只能是字符串或数字类型。</li><li>key值不能重复，否则会中断报错。【Duplicate keys detected】</li><li>使用index的值当做key的值没有任何意义（index的值不具有唯一性）。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="comment">//列表数据</span></span><br><span class="line">    <span class="attr">list</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;小林&#x27;</span>&#125; ,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;03&#x27;</span>&#125;   </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&lt;ul v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in list&quot;</span> :key=<span class="string">&quot;item.id&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>   <span class="comment">//从0开始</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="过滤器（vue3无了）"><a href="#过滤器（vue3无了）" class="headerlink" title="过滤器（vue3无了）"></a>过滤器（vue3无了）</h1><h2 id="过滤器的概念"><a href="#过滤器的概念" class="headerlink" title="过滤器的概念"></a>过滤器的概念</h2><p>过滤器（Filter）是vue为开发者提供的功能，常用于文本的格式化。【本质：函数】</p><h2 id="过滤器注意点"><a href="#过滤器注意点" class="headerlink" title="过滤器注意点"></a>过滤器注意点</h2><ul><li>由“管道符”进行调用。</li><li>在过滤器的形参中，就可以获取到“管道符”前面待处理的那个值。</li><li>必须被定义到filters节点之下，且一定要有返回值。</li><li>可以串联调用过滤器。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前一个过滤器的返回值作为后一个过滤器的参数</span></span><br><span class="line">&#123;&#123; message | cap1 | cap2 &#125;&#125;  </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>插值表达式</li><li>v-bind属性绑定</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插值表达式：</span></span><br><span class="line"><span class="comment">//在双花括号中调用capitalize过滤器函数，对message的值进行格式化</span></span><br><span class="line"><span class="comment">//p标签里看到的是capitalize(message)函数的返回值</span></span><br><span class="line">&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">message</span>:<span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过滤器函数必须被定义到filters节点之下</span></span><br><span class="line"><span class="attr">filters</span>:&#123;</span><br><span class="line">    <span class="comment">//val就是message的值</span></span><br><span class="line">    <span class="title function_">capitalize</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="comment">//字符串有charAt方法，表示从字符串中把索引对应的字符获取出来</span></span><br><span class="line">        <span class="keyword">const</span> first = val.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>();</span><br><span class="line">        <span class="comment">//字符串的slice方法，可以截取字符串，从指定索引往后截取</span></span><br><span class="line">        <span class="keyword">const</span> other = val.<span class="title function_">slice</span>(<span class="number">1</span>);<span class="comment">//从索引为1一直截取到最后</span></span><br><span class="line">        <span class="keyword">return</span> first+other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="私有过滤器和全局过滤器"><a href="#私有过滤器和全局过滤器" class="headerlink" title="私有过滤器和全局过滤器"></a>私有过滤器和全局过滤器</h2><ul><li>私有过滤器 <ul><li>在filters里面定义的是全局过滤器。</li><li>只能在当前vm实例所控制的el区域内使用。</li><li>不会和别的vm实例共享过滤器。</li></ul></li><li>全局过滤器（常用） <ul><li>独立于每个vm实例之外</li><li>第2个参数：全局过滤器的“处理函数”</li><li>第1个参数：全局过滤器的“名字”</li></ul></li></ul><blockquote><p>【注】：全局过滤器和私有过滤器重名，此时调用的是私有过滤器。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capitalize&#x27;</span>,<span class="function">(<span class="params">str</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：编码规范：先指令，再属性，最后绑定事件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6新特性</title>
      <link href="/post/daf3c6fd.html"/>
      <url>/post/daf3c6fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="let变量声明以及声明特性"><a href="#let变量声明以及声明特性" class="headerlink" title="let变量声明以及声明特性"></a>let变量声明以及声明特性</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> a,b,c;</span><br><span class="line"><span class="keyword">let</span> a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>let变量不能重复声明，但是var却可以。</li><li>块级作用域：变量只在代码块里有效，在代码块外无效。[全局、函数、eval]</li><li>不存在变量提升。（如果有变量提升，可以在变量未声明之前去使用这个变量）</li><li>不影响作用域链。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&quot;xiaolin0333&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);<span class="comment">//会向上一级作用域里去找name变量    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const声明常量及其特点"><a href="#const声明常量及其特点" class="headerlink" title="const声明常量及其特点"></a>const声明常量及其特点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">NAME</span> = <span class="string">&quot;xiaolin0333&quot;</span>;</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>一定要赋初始值。</li><li>一般常量使用大写（潜规则）</li><li>常量值不能修改。</li><li>块级作用域</li><li>对于数组和对象的元素修改，不算对常量的修改，不会报错</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DATA</span> = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;cmb&#x27;</span>];</span><br><span class="line"><span class="variable constant_">DATA</span>.<span class="title function_">push</span>(<span class="string">&#x27;dog&#x27;</span>);<span class="comment">//正确 常量所指的地址没有发生变化</span></span><br><span class="line"><span class="variable constant_">DATA</span> = <span class="number">100</span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><blockquote><p>以后声明数组或者对象的时候使用const来声明可以避免误操作</p><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><p>ES6允许按照一定模式从数组和对象中提取值，对变量进行操作。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组的解构</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">F2</span> = [<span class="string">&#x27;lsh&#x27;</span>,<span class="string">&#x27;cmb&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [lin, chai] = <span class="variable constant_">F2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lin + chai);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的解构</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiaolin0333&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">dadaima</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我可以打代码&#x27;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name,age,dadaima&#125; = lin;<span class="comment">//相当于声明了三个变量，还对他们进行了赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name + age);</span><br><span class="line"><span class="title function_">dadaima</span>();</span><br></pre></td></tr></table></figure><blockquote><p>【注】：一般函数使用解构的方法来写居多</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;dadaima&#125; = lin;<span class="comment">//但是let&#123;&#125;里面的dadaima需要和lin里面的dadaima函数同名才行</span></span><br><span class="line"><span class="title function_">dadaima</span>();</span><br></pre></td></tr></table></figure><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>ES6引入新的声明字符串的方式<code>``</code><br>ES5：<code>&#39; &#39;</code>或<code>&quot; &quot;</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`我也是个字符串`</span>;</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>内容里可以直接出现换行符（单引号、双引号不能直接出现换行符、只能用+来连接）</li><li>可以通过<code>$&#123;变量名&#125;</code>进行变量拼接</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lin = <span class="string">&#x27;xiaolin0333&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> wo = <span class="string">`我是<span class="subst">$&#123;lin&#125;</span></span></span><br></pre></td></tr></table></figure><h1 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h1><p>ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，这样的书写会更加简洁。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;xiaolin0333&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> dadaima = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我爱打代码&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    name,</span><br><span class="line">    dadaima</span><br><span class="line">    <span class="title function_">paobu</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我也爱跑步&#x27;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于如下代码</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    name = name,</span><br><span class="line">    dadaima = dadaima</span><br><span class="line">    <span class="attr">paobu</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我也爱跑步&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6允许使用箭头<code>=&gt;</code>来定义函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">let</span> 函数名 = <span class="function">(<span class="params">形参</span>) =&gt;</span> &#123;</span><br><span class="line">    代码体</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">a,b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>this是静态的，this始终指向函数声明时所在作用域下的 this的值。<br>（普通函数是：谁调用该函数，这个this就指向谁）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getName2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置window对象的name属性</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;xiaolin0333&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;03&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接调用</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">//输出：xiaolin0333（普通函数直接调用this值指向window）</span></span><br><span class="line"><span class="title function_">getName2</span>();<span class="comment">//输出：xiaolin0333（箭头函数在全局作用域下声明的，this也是指向window）</span></span><br><span class="line"><span class="comment">//call()方法调用（可以改变函数内部的this值）</span></span><br><span class="line">getName.<span class="title function_">call</span>(lin);<span class="comment">//输出：03（此时函数内部的this值指向了lin这个对象）</span></span><br><span class="line">getName2.<span class="title function_">call</span>(lin);<span class="comment">//输出：xiaolin0333（箭头函数this值静态的，仍然指向函数在声明时所在作用域的this值）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>不能作为构造函数实例化对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = (name,age) = &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lin&#x27;</span>,<span class="number">20</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ol start="3"><li>不能使用arguments变量</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(argument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ol start="4"><li>箭头函数的简写</li></ol><ul><li>省略小括号。（当形参有且仅有一个的时候）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> n+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码可以简写成如下代码</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> n+n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>省略花括号。（当代码体仅有一条语句的时候）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">pow</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> n*n; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//上面代码可以简写成如下代码</span></span><br><span class="line"> <span class="keyword">let</span> <span class="title function_">pow</span> = n =&gt;n*n;</span><br></pre></td></tr></table></figure><blockquote><p>【注】此时return也必须省略，而且语句的结构就是函数的返回值</p></blockquote><p>【适用场景】：</p><ol><li>箭头函数适合与this无关的回调（定时器、数组的方法回调）</li><li>箭头函数不适合与this有关的回调（DOM元素的事件回调，对象的方法）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ad = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ad&#x27;</span>);</span><br><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">ad.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//保存this的值</span></span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">//定时器的this指向window 所以需要外面定义一个_this 才能在定时器回调函数里面使用</span></span><br><span class="line">        <span class="comment">//修改背景颜色 this</span></span><br><span class="line">        _this.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;pink&#x27;</span>;   </span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用箭头函数就可以解决这个问题</span></span><br><span class="line">ad.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//这里不能改成箭头函数，否则this就无法指向事件源</span></span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//箭头函数的this是静态的，指向声明时所在作用域下的值，而这个定时器函数是在外层作用域下声明的，外层作用域里的this指向事件源ad</span></span><br><span class="line">        _this.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;pink&#x27;</span>;   </span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="函数参数的默认值设置"><a href="#函数参数的默认值设置" class="headerlink" title="函数参数的默认值设置"></a>函数参数的默认值设置</h1><p>ES6允许给函数参数（形参）赋初始值<br>特性：</p><ol><li>具有默认值的参数，一般位置要靠后。（潜规则）【放前面意义不大，因为实参也会按顺序与实参对应】</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b,c=<span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//13</span></span><br></pre></td></tr></table></figure><ol start="2"><li>默认值可以与解构赋值结合使用</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> host = options.<span class="property">host</span>;</span><br><span class="line">    <span class="keyword">let</span> username = options.<span class="property">username</span>; <span class="comment">//代码冗余度比较高  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数（传一个对象）</span></span><br><span class="line"><span class="title function_">connect</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">username</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">3306</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//函数声明简便写法如下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">&#123;host=<span class="string">&quot;127.0.0.1&quot;</span>,username,password,port&#125;</span>) &#123;<span class="comment">//使用解构赋值就不是“实参按顺序与形参对应了”</span></span><br><span class="line">    <span class="keyword">let</span> host = host;</span><br><span class="line">    <span class="keyword">let</span> username = username; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><p>ES6引入rest（数组）参数，用于获取函数的实参，用来代替arguments（对象）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5获取实参的方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);<span class="comment">//是个对象形式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">data</span>(<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"><span class="comment">//rest参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">data</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args);<span class="comment">//是个数组的格式 可以使用数组的很多方法(filter some every map)使我们对参数处理更灵活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">data</span>(<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"><span class="comment">//[注]rest参数必须放在参数最后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b,...args</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><p>扩展运算符<code>...</code> 能够将数组转化为逗号分割的参数序列</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lin = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>];</span><br><span class="line"><span class="comment">//把lin数组变成这种形式   &#x27;xiaolin&#x27;,&#x27;03&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">name</span>(...lin);<span class="comment">//等价于name(&#x27;xiaolin&#x27;,&#x27;03&#x27;)</span></span><br></pre></td></tr></table></figure><blockquote><p>扩展运算符和rest区别：rest参数的声明是放在了函数声明的形参位置，扩展运算符<code>...</code>是放在函数调用的实参位置</p></blockquote><p>【应用】</p><ol><li>数组的合并</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name1 = [<span class="string">&#x27;xiaolin&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> name2 = [<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;33&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> name = [...name1,...name2];<span class="comment">//合并name1和name2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数组的克隆</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;33&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> me = [...name];<span class="comment">//克隆name数组到me数组里</span></span><br></pre></td></tr></table></figure><blockquote><p>【注】如果有引用类型，也是一个浅拷贝</p></blockquote><ol start="3"><li>将伪数组转为真正的数组</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);<span class="comment">//divs得到的是个伪数组</span></span><br><span class="line"><span class="keyword">const</span> divArr = [..<span class="property">divs</span>];<span class="comment">//divArr是真正的数组</span></span><br></pre></td></tr></table></figure><h1 id="Symbol的介绍与创建"><a href="#Symbol的介绍与创建" class="headerlink" title="Symbol的介绍与创建"></a>Symbol的介绍与创建</h1><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。他是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型。<br>【特点】：</p><ol><li>Symbol的值是唯一的，用来解决命名冲突的问题</li><li>Symbol值不能与其他数据类型进行运算（加减乘除、字符串拼接、比较）</li><li>Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Symbol</span></span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;xiaolin&#x27;</span>);<span class="comment">//Symbol里面的字符串（描述字符串）相当于是做一个注释</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;xiaolin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2===s3);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//法3</span></span><br><span class="line"><span class="keyword">let</span> s4 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;xiaolin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s5 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;xiaolin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s4===s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = s+s;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><blockquote><p>【总结】：7种数据类型<br>undefined、string、symbol、object、null、number、boolean</p></blockquote><h2 id="Symbol的使用"><a href="#Symbol的使用" class="headerlink" title="Symbol的使用"></a>Symbol的使用</h2><p>向对象中添加属性和方法（如果给一个别人写的对象添加方法up()，不确定是否已经有这个方法，就可以使用Symbol来添加，更加简单高效安全。）<br>【例】：game是一个别人写的对象，我现在要添加up()和down()方法到这个对象里，但是不确定这个game对象里面是否已经存在这两个方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> game = &#123;...&#125;<span class="comment">//别人写的一个对象</span></span><br><span class="line"><span class="comment">//声明一个对象</span></span><br><span class="line"><span class="keyword">let</span> methods = &#123;</span><br><span class="line">    <span class="attr">up</span>:<span class="title class_">Symbol</span>(),</span><br><span class="line">    <span class="attr">down</span>:<span class="title class_">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将这两个方法添加到对象中</span></span><br><span class="line">game[methods.<span class="property">up</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是up()方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">game[methods.<span class="property">down</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是down()方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> youxi = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;狼人杀&quot;</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;say&#x27;</span>)]:<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//因为Symbol()是个表达式，所以这里要加上[]</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我可以发言&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;zibao&#x27;</span>)]:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我可以自爆&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Symbol内置值"><a href="#Symbol内置值" class="headerlink" title="Symbol内置值"></a>Symbol内置值</h2><p>除了定义自己使用的Symbol值之外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法<br>【例】Symbol.hasInstance：当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](param) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(param);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;类型检测的时候调用我&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(o <span class="keyword">instanceof</span> <span class="title class_">Person</span>);<span class="comment">//输出：&#123;&#125;</span></span><br><span class="line">    <span class="comment">//   类型检测的时候调用我</span></span><br><span class="line">           <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Symbol.hasInstance都是Symbol内部的属性，这个整体又作为对象里边的属性，来改变对象在特定场景下的表现（扩展对象功能）</p></blockquote><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（Iterator）是一种接口，为不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p><ol><li>ES6创建了一种新的遍历命令for…of循环。（只要数据结构部署了Interator接口，就可以使用for…of来遍历数据）</li><li>原生具备Interator接口的数据（可用for…of遍历）：Array、Arguments、set、Map、String、TypedArray、NodeList</li></ol><p>Interator就是指：对象里的一个函数Symbol（Symbol.Interator)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个数组</span></span><br><span class="line"><span class="keyword">const</span> lin = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;33&#x27;</span>];</span><br><span class="line"><span class="comment">//使用for...of遍历数组(v是键值)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> lin) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lin);<span class="comment">//输出 xiaolin 03 33</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对比for...in遍历数组(v是键名)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">in</span> lin) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lin);<span class="comment">//输出 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【应用】：需要自定义遍历数据的时候，要想到迭代器。<br>【例】：使用for…of遍历对象，每次返回结果是数组stus的成员</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个对象</span></span><br><span class="line"><span class="keyword">const</span> banji = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;物联网二班&#x27;</span>,</span><br><span class="line">    <span class="attr">stus</span>:[</span><br><span class="line">        <span class="string">&#x27;xiaolin&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;03&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;33&#x27;</span>                    </span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//自定义迭代器</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">interator</span>]() &#123;</span><br><span class="line">        <span class="comment">//索引变量</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(index&lt;_this.<span class="property">stus</span>.<span class="property">length</span>) &#123;<span class="comment">//this指向的不是banji这个对象（也可以使用箭头函数） </span></span><br><span class="line">                    <span class="keyword">const</span> result = &#123;<span class="attr">value</span>:_this.<span class="property">stus</span>[index],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">                    index++;                </span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;                </span><br><span class="line">                &#125;</span><br><span class="line">                           </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//banji.stus.forEach();//也可以遍历stus数组的成员，但是不符合面向对象的思想。（不能直接对数据成员操作）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> banji) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义迭代器工作原理如下：</p><ol><li>创建一个对象，指向当前数据结构的起始位置</li><li>第一次调用对象的next方法(规定就叫做next方法)，指针自动指向数据结构的第一个成员</li><li>接下来不断调用next方法，指针一直向后移动，直到指向最后一个成员</li><li>每次调用next方法返回一个包含value和done属性的对象<br>如果指针所指向的成员有定义，{value:指针所指成员,done:false}，否则{value:undefined,done:true}</li></ol></blockquote><h1 id="生成器函数生命与调用"><a href="#生成器函数生命与调用" class="headerlink" title="生成器函数生命与调用"></a>生成器函数生命与调用</h1><p>生成器是一个特殊函数，用来进行异步编程（纯回调函数）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：function * 函数名() &#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//yield等价于函数代码的分隔符（把函数代码分割成几块）</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;一只没有眼睛&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;一只没有尾巴&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;真奇怪&#x27;</span>;</span><br><span class="line">    <span class="comment">//gen()返回迭代器对象(如果里面有console.log的话，不会输出里面的内容，得调用next()方法才能执行)</span></span><br><span class="line">    <span class="keyword">let</span> interator = <span class="title function_">gen</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:&quot;一只没有眼睛&quot;,done:false&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:&quot;一只没有眼睛&quot;,done:false&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:&quot;真奇怪&quot;,done:false&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">gen</span>()) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">//输出：一只没有眼睛     一只没有眼睛      真奇怪</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【参数传递】</p><ol><li>整体函数传参</li><li>next方法传参</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">    <span class="keyword">let</span> one = <span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(one);</span><br><span class="line">    <span class="keyword">let</span> two = <span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(two);</span><br><span class="line">    <span class="keyword">let</span> three = <span class="keyword">yield</span> <span class="number">333</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(three)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行迭代器对象</span></span><br><span class="line"><span class="keyword">let</span> interator = <span class="title function_">gen</span>(<span class="string">&#x27;AAA&#x27;</span>); <span class="comment">// 整体函数传参</span></span><br><span class="line"><span class="comment">// 以下都是next方法传参</span></span><br><span class="line">interator.<span class="title function_">next</span>();<span class="comment">//输出：AAA</span></span><br><span class="line"><span class="comment">//next方法可以传入实参（作为上一个yield的返回结果）</span></span><br><span class="line"><span class="comment">//下面代码传入BBB，作为第一个yield语句整个的返回结果</span></span><br><span class="line">interator.<span class="title function_">next</span>(<span class="string">&#x27;BBB&#x27;</span>);<span class="comment">//输出：BBB</span></span><br><span class="line"><span class="comment">//下面代码传入CCC，作为第二个yield语句整个的返回结果</span></span><br><span class="line">interator.<span class="title function_">next</span>(<span class="string">&#x27;CCC&#x27;</span>);<span class="comment">//输出：CCC</span></span><br><span class="line"><span class="comment">//下面代码传入DDD，作为第三个yield语句整个的返回结果</span></span><br><span class="line">interator.<span class="title function_">next</span>(<span class="string">&#x27;DDD&#x27;</span>);<span class="comment">//输出：DDD</span></span><br></pre></td></tr></table></figure><p>【生成器函数实例】：异步编程：文件操作、网络操作（ajax、requests）、数据库操作<br>【例】：定时器案例（1s后控制台输出111  2s后控制台输出222  3s后控制台输出333）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方法</span></span><br><span class="line"><span class="comment">//代码缩进不断向前缩进，阅读调试不方便（回调地狱）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);        </span><br><span class="line">        &#125;,<span class="number">3000</span>);    </span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成器函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">one</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">        interator.<span class="title function_">next</span>();</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">two</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        interator.<span class="title function_">next</span>();    </span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">three</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);    </span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">one</span>();</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">two</span>();</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">three</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用生成器函数</span></span><br><span class="line"><span class="keyword">let</span> interator = <span class="title function_">gen</span>();</span><br><span class="line">interator.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise是ES6引入的异步编程的解决方案（主要解决回调地狱的问题）。语法上Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化Promise对象（有三种状态：初始化、成功、失败）</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//异步操作</span></span><br><span class="line">        <span class="keyword">if</span>(成功)&#123;</span><br><span class="line">             <span class="keyword">let</span> data = <span class="string">&#x27;数据库中的用户数据&#x27;</span>;<span class="comment">//得到数据</span></span><br><span class="line">        <span class="comment">//调用resolve()和reject()方法可以改变Promise对象的状态</span></span><br><span class="line">       <span class="title function_">resolve</span>(data);<span class="comment">//调用resolve()方法，Promise对象p的状态为成功===&gt;then()方法执行第一个回调函数的内容       </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//失败</span></span><br><span class="line">        <span class="keyword">let</span> err = <span class="string">&#x27;数据读取失败&#x27;</span>;</span><br><span class="line">           <span class="title function_">reject</span>(err);<span class="comment">//调用reject()方法，Promise对象p的状态为失败===&gt;then()方法执行第二个回调函数的内容                  </span></span><br><span class="line">        &#125;                                                                                                             </span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用Promise对象的then方法(返回结果是Promise对象，对象状态由回调函数的执行结果决定)</span></span><br><span class="line">    <span class="comment">//1.如果回调函数中返回结果是：非Promise类型的属性(无返回值undefined 也算非Promise类型)，状态为成功。返回值为对象的成功值</span></span><br><span class="line">    <span class="comment">//2.如果回调函数中返回结果是：Promise对象，返回值和then方法返回的值类型是一样的</span></span><br><span class="line">    <span class="comment">//3.如果回调函数中返回的是：抛出错误，then方法返回值状态也是失败</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> result = p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;<span class="comment">//调用成功的形参</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//成功时输出：数据库中的用户数据</span></span><br><span class="line">        <span class="comment">//1.非Promise类型的属性</span></span><br><span class="line">        <span class="comment">//return 123;  </span></span><br><span class="line">        <span class="comment">//2.是promise对象</span></span><br><span class="line">        <span class="comment">//return new Promise((resolve,reject)=&gt; &#123;</span></span><br><span class="line">            <span class="comment">//resolve(&#x27;ok&#x27;);//返回成功，then方法也返回成功        </span></span><br><span class="line">        <span class="comment">//&#125;)</span></span><br><span class="line">        <span class="comment">//3.抛出错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错啦&#x27;</span>);</span><br><span class="line">    &#125;,<span class="keyword">function</span>(<span class="params">reason</span>) &#123;<span class="comment">//调用失败的形参</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(reason);<span class="comment">//失败时输出：数据读取失败</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//综上所述</span></span><br><span class="line"><span class="comment">//then方法可以链式调用</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span> &#123;&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//也可以只指定一个回调</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了新的数据结构Set（集合）。它类似于数组，但成员的值唯一，集合实现了Iterator接口，所以可以使用扩展运算符和for…of进行遍历。<br>【声明一个set】：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;大事&#x27;</span>,<span class="string">&#x27;小事&#x27;</span>,<span class="string">&#x27;坏事&#x27;</span>,<span class="string">&#x27;小事&#x27;</span>]);<span class="comment">//可以传入一个可迭代数据（一般传入数组）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2);<span class="comment">//&#x27;大事&#x27;,&#x27;小事&#x27;,&#x27;坏事&#x27;  ==&gt;  自动去重</span></span><br></pre></td></tr></table></figure><p>【元素个数】：不包括重复元素size</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="property">size</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>【增】：添加新的元素add()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s2.<span class="title function_">add</span>(<span class="string">&#x27;喜事&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2);<span class="comment">//&#x27;大事&#x27;,&#x27;小事&#x27;,&#x27;坏事&#x27;,&#x27;喜事&#x27;</span></span><br></pre></td></tr></table></figure><p>【删】：删除元素delete()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s2.<span class="title function_">delete</span>(<span class="string">&#x27;坏事&#x27;</span>);<span class="comment">//&#x27;大事&#x27;,&#x27;小事&#x27;,&#x27;喜事&#x27;</span></span><br></pre></td></tr></table></figure><p>【是否存在】：检测has()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="title function_">has</span>(<span class="string">&#x27;好事&#x27;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>【遍历】：使用for…of遍历集合</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> s2) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【清空】：清空clear()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="title function_">clear</span>());<span class="comment">//集合里内容为空</span></span><br></pre></td></tr></table></figure><p>【集合实践】：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集合实践：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="comment">//1.数组去重</span></span><br><span class="line"><span class="comment">//let result = new Set(arr);//此时result是个集合（集合可以自动去重）</span></span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];<span class="comment">//通过扩展运算符把result集合改成数组==&gt;此时的数组已经是去除重复元素后的数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.交集arr ∩ arr2</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;<span class="comment">//数组先去重 再使用过滤器过滤相同的元素</span></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>(arr2);</span><br><span class="line">    <span class="keyword">if</span>(s2.<span class="title function_">has</span>(item)) &#123;<span class="comment">//s2里有arr数组去重后的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//[4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.并集</span></span><br><span class="line"><span class="keyword">let</span> union = [...arr,...arr2];<span class="comment">//合并两个数组，此时存在重复元素</span></span><br><span class="line">union = [...union];<span class="comment">//把重复的元素去除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.差集====&gt;就是交集取反</span></span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>ES6提供了Map数据结构，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map也实现了Iterator接口，所以可以使用扩展运算符和for…in进行遍历。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明Map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure><p>【增】：添加元素 对象.set(键,值)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;xiaolin03&#x27;</span>);<span class="comment">//key:&quot;name&quot;  value:&quot;xiaolin03&quot;</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;hobby&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我爱打代码&#x27;</span>);<span class="comment">//key:&quot;hobby&quot;   value:f()</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> key = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiaolin03&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">m.<span class="title function_">set</span>(key,[<span class="string">&#x27;宁德&#x27;</span>,<span class="string">&#x27;厦门&#x27;</span>,<span class="string">&#x27;福州&#x27;</span>]);<span class="comment">//key:&#123;name:&quot;xiaolin03&quot;&#125;   value:[&#x27;宁德&#x27;,&#x27;厦门&#x27;,&#x27;福州&#x27;]  ====&gt;键：对象 值：数组</span></span><br></pre></td></tr></table></figure><p>【元素个数】：获取元素个数  对象.size</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>【删】：删除  对象.delete(键)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><p>【取】：获取  对象.get(键)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line">m.<span class="title function_">get</span>(key);</span><br></pre></td></tr></table></figure><p>【遍历】：for…of遍历</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> m) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);<span class="comment">//v是一个数组，第一个元素是键，第二个元素是值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【清空】：对象.chear();</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">clear</span>();<span class="comment">//清空对象</span></span><br></pre></td></tr></table></figure><h1 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h1><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。作为对象的模板。通过class关键字可以定义类。基本上，ES6的class可以看做只是一个语法糖，他的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法  名字不能修改(自动执行，使用new Person()时自动调用该方法)</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法必须使用该语法 不能使用ES5的对象完整形式 call:fuction()&#123;&#125;   &lt;==   错误！！</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以打电话&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> onPlus = <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;1+&quot;</span>,<span class="number">1999</span>);<span class="comment">//实例化对象，自动调用constructor方法</span></span><br></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员static标注的成员，属于类，而不属于函数对象   &#x3D;&#x3D;&#x3D;&#x3D;&gt;   得用类名.成员名   来调用该属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&quot;手机&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以改变世界&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> huawei = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(huawei.<span class="property">name</span>);<span class="comment">//undefined;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Phone</span>.<span class="property">name</span>);<span class="comment">//手机</span></span><br></pre></td></tr></table></figure><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的成员属性</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打电话&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price,color,size</span>) &#123;</span><br><span class="line">        <span class="title function_">surper</span>(brand,price);<span class="comment">//surper()就是父类的constructor()方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">photo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拍照&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">playGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;玩游戏&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaomi = <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&#x27;小米&#x27;</span>,<span class="number">799</span>,<span class="string">&#x27;黑色&#x27;</span>,<span class="string">&#x27;4.7inch&#x27;</span>);</span><br><span class="line">xiaomi.<span class="title function_">call</span>();</span><br><span class="line">xiaomi.<span class="title function_">photo</span>();</span><br><span class="line">xiaomi.<span class="title function_">playGame</span>();</span><br></pre></td></tr></table></figure><h2 id="子类对父类方法的重写"><a href="#子类对父类方法的重写" class="headerlink" title="子类对父类方法的重写"></a>子类对父类方法的重写</h2><p>重写：在子类声明一个和父类重名的方法，从而对父类的功能进行改进。当调用这个方法时，调用的是子类的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的成员属性</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打电话&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price,color,size</span>) &#123;</span><br><span class="line">        <span class="title function_">surper</span>(brand,price);<span class="comment">//surper()就是父类的constructor()方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类重写父类call()方法</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//无法在子类里去调用父类里的call()方法！！</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打视频、聊天&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaomi = <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&#x27;小米&#x27;</span>,<span class="number">799</span>,<span class="string">&#x27;黑色&#x27;</span>,<span class="string">&#x27;4.7inch&#x27;</span>);</span><br><span class="line">xiaomi.<span class="title function_">call</span>();<span class="comment">//&quot;打视频、聊天&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>ES6里，无法在子类里去调用父类中和他同名的那个方法，只能在子类里写。</p></blockquote><h2 id="getter和setter设置"><a href="#getter和setter设置" class="headerlink" title="getter和setter设置"></a>getter和setter设置</h2><p>对<code>对象的属性</code>进行方法的绑定<br>get：对于对象的动态属性进行封装<br>set：添加更多的控制和判断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">price</span>() &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;价格属性被读取了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;helloworld&#x27;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">price</span>(<span class="params">newVAl</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;价格属性被修改了&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">price</span>());</span><br><span class="line">s.<span class="property">price</span> = <span class="string">&#x27;free&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ol><li>Number.EPSILON 是 JavaScript 表示的最小精度<ul><li>EPSILON 属性的值接近于 2.22E-16</li><li>主要用于浮点数运算（浮点数运算经常会有误差）</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span>+<span class="number">0.2</span>);<span class="comment">//0.3000000000000000000000004</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);<span class="comment">//false</span></span><br><span class="line"><span class="keyword">function</span> equal = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(a-b)&lt;<span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">equal</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol start="2"><li>二进制和八进制</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">0b1010</span>;<span class="comment">//二进制 0b开头 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//10</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="number">0o777</span>;<span class="comment">//八进制 0o开头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);<span class="comment">//511</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0xff</span>;<span class="comment">//十六进制 0x开头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">//255</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Number.isFinite 检测一个数值是否为有限数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">100</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">100</span>/<span class="number">0</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Number.isNaN 检测一个数值是否为NaN</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">123</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Number.parseInt  Number.parseFloat  字符串转整数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&quot;520Love&quot;</span>));<span class="comment">//520</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">parseFloat</span>(<span class="string">&quot;5.20Love&quot;</span>));<span class="comment">//5.20</span></span><br></pre></td></tr></table></figure><ol start="6"><li>Number.isInteger 判断一个数是否为整数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">4</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">4.4</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="7"><li>Math.trunc 将数字的小数部分抹掉</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="number">3.5</span>));<span class="comment">//3</span></span><br></pre></td></tr></table></figure><ol start="8"><li>Math.sign 判断一个数到底为正数、负数还是零</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="number">100</span>));<span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="number">0</span>));<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sign</span>(-<span class="number">100</span>));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure><h1 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h1><ol><li>Object.is(a, b)判断两个值是否完全相等</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">120</span>,<span class="number">120</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>,<span class="title class_">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>===<span class="title class_">NaN</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Object.assign(a, b)对象的合并</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config1 = &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">3306</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">pass</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">text</span>:<span class="string">&#x27;text&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> config2 = &#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&#x27;http://xiaolin03.com&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">33060</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiaolin03.com&#x27;</span>,</span><br><span class="line">    <span class="attr">pass</span>:<span class="string">&#x27;cmb&#x27;</span>,</span><br><span class="line">    <span class="attr">text2</span>:<span class="string">&#x27;text2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config1,config2));</span><br><span class="line"><span class="comment">//如果对象里面参数重名host、port、name、pass，后面一个参数会把前面一个参数覆盖掉；</span></span><br><span class="line"><span class="comment">//如果前面一个对象的属性后面一个对象没有text，那么以前面一个对象为准；</span></span><br><span class="line"><span class="comment">//如果后面一个对象的属性前面一个对象没有text2，那么不会覆盖掉。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Object.setPrototypeOf 设置原型对象   Object.getPrototypeOf</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;学校名&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cities = &#123;</span><br><span class="line">    <span class="attr">xiaoqu</span>:[<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(school,cities);<span class="comment">//为school对象设置原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(school);</span><br></pre></td></tr></table></figure><blockquote><p>不建议这么做(效率低)</p></blockquote><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>将一个大的程序文件，拆分成许多小的文件（模块），然后将小文件组合起来。<br>【好处】：</p><ol><li>防止命名冲突</li><li>代码复用</li><li>高维护性<br>【语法】：模块功能主要由两个命令构成：export和import</li><li>export命令用于规定模块的对外接口</li><li>import命令用于输入其他模块提供功能</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//m1.js文件：</span></span><br><span class="line"><span class="comment">//希望这个数据能够被的模块使用，就在前面加上export，他模块就可以通过import引入这个数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> school = <span class="string">&#x27;学校名&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//index.html文件：</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//引入m1.js模块内容</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;<span class="comment">//通用方式===&gt;index.html这个文件就把m1.js文件里所有暴露数据存储到m1数据里了</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(m1);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【暴露数据语法汇总】：</p><ol><li>分别暴露(在每个需要暴露的数据前面加上export)    m1.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> school = <span class="string">&#x27;学校名&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>统一暴露(在某个地方直接用export，用对象简化写法格yin)    m2.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> school = <span class="string">&#x27;学校名&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;school,teach&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>默认暴露(对于这种方法，在调用的时候也需要上default 【例】m1.default.change())    m3.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：export default + &#123;要暴露的数据&#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">school</span>:<span class="string">&quot;学校名&quot;</span>,</span><br><span class="line">    <span class="attr">change</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【引入模块数据语法汇总】：</p><ol><li>通用的入方式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>解构赋值形式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;school,teach&#125; <span class="keyword">from</span> <span class="string">&quot;./m1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;school <span class="keyword">as</span> guigu,teach <span class="keyword">as</span> teaching&#125; <span class="keyword">from</span> <span class="string">&quot;./m2.js&quot;</span>;<span class="comment">//如果需要引入的数据重名的话，可以使用别名方式</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m3&#125; form <span class="string">&quot;./m3.js&quot;</span>;<span class="comment">//对于默认暴露的方式用解构赋值，不能直接使用default</span></span><br></pre></td></tr></table></figure><ol start="3"><li>简便形式（只能针对默认暴露）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m3 <span class="keyword">from</span> <span class="string">&quot;./m3.js&quot;</span>;<span class="comment">//直接跟变量（不写*和&#123;&#125;）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目】黑马头条 - 普通用户端</title>
      <link href="/post/29134165.html"/>
      <url>/post/29134165.html</url>
      
        <content type="html"><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="/assets/18f63549fbf14a9e866730e78f23454a.png" alt="18f63549fbf14a9e866730e78f23454a.png"><br><img src="/assets/c5abfc1c456449d1b8c1f2e19efca2b0.png" alt="c5abfc1c456449d1b8c1f2e19efca2b0.png"></p><h1 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a>全局异常</h1><p><img src="/assets/287788fb68b54c9ab0aaf82d728277ba.png" alt="287788fb68b54c9ab0aaf82d728277ba.png"></p><h1 id="登录手动加密（md5-随机字符串）"><a href="#登录手动加密（md5-随机字符串）" class="headerlink" title="登录手动加密（md5  + 随机字符串）"></a>登录手动加密（md5  + 随机字符串）</h1><p>【问题】md5是不可逆加密，md5相同的密码每次加密都一样，不安全。<br>【解决】在md5的基础上手动加盐（salt）处理<br><img src="/assets/51135b1974df4aaf92ca2807aa12d794.png" alt="51135b1974df4aaf92ca2807aa12d794.png"><br>校验过程：<br><img src="/assets/6db7d58b06124215aadbe261f1ad796d.png" alt="6db7d58b06124215aadbe261f1ad796d.png"></p><h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><h2 id="1-ApiFox中测试"><a href="#1-ApiFox中测试" class="headerlink" title="1. ApiFox中测试"></a>1. ApiFox中测试</h2><h2 id="2-swagger"><a href="#2-swagger" class="headerlink" title="2. swagger"></a>2. swagger</h2><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在common模块下添加swagger配置类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Docket <span class="title function_">buildDocket</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">              .apiInfo(buildApiInfo())</span><br><span class="line">              .select()</span><br><span class="line">              <span class="comment">// 要扫描的API(Controller)基础包</span></span><br><span class="line">              .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.heima&quot;</span>))</span><br><span class="line">              .paths(PathSelectors.any())</span><br><span class="line">              .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ApiInfo <span class="title function_">buildApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;黑马程序员&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">              .title(<span class="string">&quot;黑马头条-平台管理API文档&quot;</span>)</span><br><span class="line">              .description(<span class="string">&quot;黑马头条后台api&quot;</span>)</span><br><span class="line">              .contact(contact)</span><br><span class="line">              .version(<span class="string">&quot;1.0.0&quot;</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/03715a928244480fbfe41f21dd9cc950.png" alt="03715a928244480fbfe41f21dd9cc950.png"></p><ol start="3"><li>swagger的常用注解</li></ol><ul><li>@Api：修饰整个类，描述Controller的作用  </li><li>@ApiOperation：描述接口  </li><li>@ApiModelProperty：描述属性</li></ul><blockquote><p>成功后启动项目，浏览器访问：<code>http://localhost:51801/swagger-ui.html</code></p></blockquote><h2 id="3-knife4j（常用）"><a href="#3-knife4j（常用）" class="headerlink" title="3. knife4j（常用）"></a>3. knife4j（常用）</h2><p>knife4j继承了swagger，功能比swagger更强大，也会生成接口文档</p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在common中添加配置类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="meta">@Import(BeanValidatorPluginsConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Configuration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;defaultApi2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">defaultApi2</span><span class="params">()</span> &#123;</span><br><span class="line">        Docket docket=<span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                <span class="comment">//分组名称</span></span><br><span class="line">                .groupName(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//这里指定Controller扫描包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.heima&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;黑马头条API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;黑马头条API文档&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样也需要在resources目录中添加该配置类的全类名<br>成功后启动项目，浏览器访问：<code>http://host:port/doc.html</code></p></blockquote><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="1-配置网关"><a href="#1-配置网关" class="headerlink" title="1. 配置网关"></a>1. 配置网关</h2><p>一个父模块(heima-leadnews-gateway)下，放多个子模块(heima-leadnews-app-gateway)。<br><img src="/assets/506178d045ab4f978a4858eb11993e82.png" alt="506178d045ab4f978a4858eb11993e82.png"></p><ol><li>在父模块中引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写子模块的引导类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.app.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">//开启注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppGatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(AppGatewayApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写子模块的bootstrap.yml</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">51601</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heima-leadnews-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在注册中心中引入子模块的配置<br><img src="/assets/7c829db6c8154f0b9fa1c042543095cc.png" alt="7c829db6c8154f0b9fa1c042543095cc.png"></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">OPTION</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment"># 平台管理</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://leadnews-user</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-设置认证过滤器"><a href="#2-设置认证过滤器" class="headerlink" title="2. 设置认证过滤器"></a>2. 设置认证过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取request、response对象</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2. 判断是否是登录</span></span><br><span class="line">        <span class="keyword">if</span>(request.getURI().getPath().contains(<span class="string">&quot;/login&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 判断token是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED); <span class="comment">// 返回401未授权</span></span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 判断token是否有效</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!AppJwtUtil.isValidToken(token)) &#123;</span><br><span class="line">            <span class="comment">// token过期</span></span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange); <span class="comment">// 放行</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete(); <span class="comment">// 抛异常，结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级设置，值越小，优先级越高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>认证过滤器用来拦截前端发过来的请求，写在网关里。</p></blockquote><h1 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h1><h2 id="表的拆分——垂直分表"><a href="#表的拆分——垂直分表" class="headerlink" title="表的拆分——垂直分表"></a>表的拆分——垂直分表</h2><p><img src="/assets/d70a685c8c9c4d77b89a9e5b8aec994a.png" alt="d70a685c8c9c4d77b89a9e5b8aec994a.png"><br>将一个表的字段分散到多个表，每个表存储其中一部分字段</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>减少IO争抢，减少锁表的几率（查看文章信息与文章内容互不影响）</li><li>充分发挥高频数据的操作效率，对文章信息操作的高频率不会被操作文章详情数据的低效率拖累。</li></ul><h3 id="拆分规则"><a href="#拆分规则" class="headerlink" title="拆分规则"></a>拆分规则</h3><ol><li>把不常用的字段单独放在一张表</li><li>把text、blob等大字段拆分出来单独放在一张表</li><li>经常组合查询的字段单独放在一张表</li></ol><h1 id="文章详情"><a href="#文章详情" class="headerlink" title="文章详情"></a>文章详情</h1><h2 id="方案1-直接查文章内容表"><a href="#方案1-直接查文章内容表" class="headerlink" title="方案1. 直接查文章内容表"></a>方案1. 直接查文章内容表</h2><p>用户某一条文章，根据id去查询文章内容表，返回渲染页面<br><img src="/assets/e1f300afed754115b635b8742585ed1e.png" alt="e1f300afed754115b635b8742585ed1e.png"></p><h2 id="方案2-静态模板展示（效率高）"><a href="#方案2-静态模板展示（效率高）" class="headerlink" title="方案2. 静态模板展示（效率高）"></a>方案2. 静态模板展示（效率高）</h2><p><img src="/assets/369f91bc04ab4b13a3024b7cda9063c5.png" alt="369f91bc04ab4b13a3024b7cda9063c5.png"></p><blockquote><p>把文章的内容变成静态的html文件，把生成之后的文件上传到minio中，并保存生成的html存入文章信息表中（static_url字段），前端渲染的时候，直接获取文章信息表的static_url字段，然后去minIO里获取静态访问页面即可。</p></blockquote><p>Freemaker知识点：<a href="https://blog.csdn.net/qq_57882997/article/details/145262781?sharetype=blogdetail&sharerId=145262781&sharerefer=PC&sharesource=qq_57882997&spm=1011.2480.3001.8118">Freemarker模板引擎技术</a></p><p>新增文章的测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createStaticUrlTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TemplateException &#123;</span><br><span class="line">    <span class="comment">// 1. 获取文章内容</span></span><br><span class="line">    <span class="type">ApArticleContent</span> <span class="variable">apArticleContent</span> <span class="operator">=</span> apArticleContentMapper.selectOne(Wrappers.&lt;ApArticleContent&gt;lambdaQuery().eq(ApArticleContent::getArticleId, <span class="string">&quot;1302862387124125698L&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(apArticleContent != <span class="literal">null</span> || StringUtils.isBlank(apArticleContent.getContent()))&#123;</span><br><span class="line">        <span class="comment">// 2. 文章内容通过freemarker生成html文件</span></span><br><span class="line">        <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> configuration.getTemplate(<span class="string">&quot;article.ftl&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">&quot;content&quot;</span>, JSONArray.parseArray(apArticleContent.getContent()));</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        template.process(content, out);</span><br><span class="line">        <span class="comment">// 3. 把html上传到minio中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(out.toString().getBytes());</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> fileStorageService.uploadHtmlFile(<span class="string">&quot;&quot;</span>, apArticleContent.getArticleId() + <span class="string">&quot;.html&quot;</span>, in);</span><br><span class="line">        <span class="comment">// 4. 修改ap_article表，保存static_url字段</span></span><br><span class="line">        apArticleService.update(Wrappers.&lt;ApArticle&gt;lambdaUpdate()</span><br><span class="line">                        .eq(ApArticle::getId, apArticleContent.getArticleId())</span><br><span class="line">                        .set(ApArticle::getStaticUrl, path));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> 网关 </tag>
            
            <tag> 拆分表 </tag>
            
            <tag> 文章详情渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO</title>
      <link href="/post/a5fe9d0b.html"/>
      <url>/post/a5fe9d0b.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol><li>Golang语言实现</li><li>兼容亚马逊S3云存储服务接口，适合存储大量非结构化数据</li><li>官方文档：<a href="https://www.minio.org.cn/docs/minio/kubernetes/upstream/index.html">MinIO</a></li></ol><h1 id="Docker安装MinIO"><a href="#Docker安装MinIO" class="headerlink" title="Docker安装MinIO"></a>Docker安装MinIO</h1><ol><li>创建并运行容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name minio \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">--restart=always \</span><br><span class="line">-e &quot;MINIO_ACCESS_KEY=minio&quot; \</span><br><span class="line">-e &quot;MINIO_SECRET_KEY=minio123&quot; \</span><br><span class="line">-v /home/data:/data \</span><br><span class="line">-v /home/config:/root/.minio \</span><br><span class="line">minio/minio server /data</span><br></pre></td></tr></table></figure><ul><li>用户名：minio</li><li>密码：minio123</li></ul><ol start="2"><li>在浏览器输入<code>http://192.168.140.102:9000/</code>后即可看到minio控制台</li></ol><h1 id="操作MinIO"><a href="#操作MinIO" class="headerlink" title="操作MinIO"></a>操作MinIO</h1><ol><li>引入minio依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>操作minio</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\list.html&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取minio的连接信息，创建minio的客户端</span></span><br><span class="line">    <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span> MinioClient.builder()</span><br><span class="line">            .credentials(<span class="string">&quot;minio&quot;</span>, <span class="string">&quot;minio123&quot;</span>) <span class="comment">// 凭证</span></span><br><span class="line">            .endpoint(<span class="string">&quot;http://192.168.140.102:9000&quot;</span>) <span class="comment">// 连接地址</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 上传</span></span><br><span class="line">    <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">            .object(<span class="string">&quot;list.html&quot;</span>) <span class="comment">// 文件名称</span></span><br><span class="line">            .contentType(<span class="string">&quot;text/html&quot;</span>) <span class="comment">// 文件类型</span></span><br><span class="line">            .bucket(<span class="string">&quot;leadnews&quot;</span>) <span class="comment">// 桶名称(与minio管理界面创建的桶一致)</span></span><br><span class="line">            .stream(fis, fis.available(), -<span class="number">1</span>) <span class="comment">// 流, 流有多大, -1表示所有相关的文件内容</span></span><br><span class="line">            .build();</span><br><span class="line">    minioClient.putObject(putObjectArgs);</span><br><span class="line">    <span class="comment">// 访问路径</span></span><br><span class="line">    System.out.println(<span class="string">&quot;http://192.168.140.102:9000/leadnews/list.html&quot;</span>); <span class="comment">// 访问路径 + 桶的名称 + 文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="封装MinIO为starter"><a href="#封装MinIO为starter" class="headerlink" title="封装MinIO为starter"></a>封装MinIO为starter</h1><p>【问题】：可能有不止一个微服务需要用到minio，如果在每个微服务都去集成minio会很麻烦。<br>【解决】：把文件微服务抽取出来，抽取minio变成一个文件微服务。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> minio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Freemarker模板引擎技术</title>
      <link href="/post/768410d8.html"/>
      <url>/post/768410d8.html</url>
      
        <content type="html"><![CDATA[<p>【<code>问题</code>】当渲染文章数据时，由于文章的数据很多，直接去查询文章内容表的话，效率比较低。<br>【<code>解决</code>】使用freemarker将文章的内容通过模板技术生成静态的html文件存储到minio中，这样用户就只需要拿着minio的url去minio里获取静态页面即可。效率大大提高<br><img src="/assets/369f91bc04ab4b13a3024b7cda9063c5.png" alt="369f91bc04ab4b13a3024b7cda9063c5.png"></p><h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><p>Freemarker是一种模板引擎：一种基于模板和要改变的数据，并用来生成输出文本（html网页、电子邮件、配置文件、源代码…）的通用工具。不是面向最终用户的，而是一个Java类库。<br><img src="/assets/bb81ce762b244cc693aeb5119f053c43.png" alt="bb81ce762b244cc693aeb5119f053c43.png"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- freemarker --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加application.yml配置</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8881</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">freemarker-demo</span> <span class="comment">#指定服务名</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span>  <span class="comment">#关闭模板缓存，方便测试</span></span><br><span class="line">    <span class="attr">settings:</span></span><br><span class="line">      <span class="attr">template_update_delay:</span> <span class="number">0</span> <span class="comment">#检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span> <span class="comment">#指定Freemarker模板文件的后缀名（默认是.ftlh）</span></span><br></pre></td></tr></table></figure><blockquote><p>suffix的属性也可以是.html、.xml、.jsp等，但是一般是以ftl作为扩展名</p></blockquote><ol start="3"><li>在resources下创建templates，此目录为<code>freemarker的默认模板存放目录</code>。在templates下创建<code>模板文件basic.ftl</code>，模板中的<code>插值表达式</code>最终会被freemarker替换成具体的数据。<br>basic.ftl文件</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>普通文本 String 展示：<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Hello $&#123;name&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>对象Student中的数据展示：<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">姓名：$&#123;stu.name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stu.age&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>往模板里填数据，返回模板文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 因为要返回视图，而不是json字符串，所以这里不可以用@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/basic&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// name</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaolin&quot;</span>);</span><br><span class="line">        <span class="comment">// stu</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;03&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;stu&quot;</span>, stu);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;basic&quot;</span>; <span class="comment">// 这里返回的数据必须和模板视图的名字一样，这样才能找到模板视图(别带后缀！！！)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Freemarker指令语法"><a href="#Freemarker指令语法" class="headerlink" title="Freemarker指令语法"></a>Freemarker指令语法</h1><h2 id="基础语法种类"><a href="#基础语法种类" class="headerlink" title="基础语法种类"></a>基础语法种类</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释&lt;#-- --&gt;"></a>1. 注释<code>&lt;#-- --&gt;</code></h3><p>介于其之间的内容会被Freemarker忽视</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--我是一个freemarker注释--&gt;</span><br></pre></td></tr></table></figure><h3 id="2-插值表达式"><a href="#2-插值表达式" class="headerlink" title="2. 插值表达式${...}"></a>2. 插值表达式<code>$&#123;...&#125;</code></h3><p>Freemarker会用真实的值替代${…}</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Hello $&#123;name&#125;</span><br></pre></td></tr></table></figure><h3 id="3-FTL指令"><a href="#3-FTL指令" class="headerlink" title="3. FTL指令&lt;#&gt; &lt;/#&gt;"></a>3. FTL指令<code>&lt;#&gt; &lt;/#&gt;</code></h3><p>名字前加<code>#</code>区分，Freemarker会解析标签中的表达式或逻辑。<br>例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#list stus as stu&gt;$&#123;stu.name&#125;&lt;/#list&gt; </span><br></pre></td></tr></table></figure><h3 id="4-文本"><a href="#4-文本" class="headerlink" title="4. 文本"></a>4. 文本</h3><p>仅文本信息，不是freemarker的注释、插值、FTL指令的内容会被Freemarker忽略解析，直接输出内容。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--freemarker中的普通文本--&gt;</span><br><span class="line">我是一个普通的文本</span><br></pre></td></tr></table></figure><h2 id="集合指令（List、Map）"><a href="#集合指令（List、Map）" class="headerlink" title="集合指令（List、Map）"></a>集合指令（List、Map）</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>钱包<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;#--遍历数据 stu指的是集合里的每一个数据--&gt;</span><br><span class="line">    &lt;#list stus as stu&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            &lt;#--获取当前集合的下标--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu_index + 1&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.age&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.money&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="获取map中某个key对应的值"><a href="#获取map中某个key对应的值" class="headerlink" title="获取map中某个key对应的值"></a>获取map中某个key对应的值</h4><ol><li>通过<code>map[&#39;keyname&#39;].property</code></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">姓名：$&#123;stuMap[&#x27;stu1&#x27;].name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stuMap[&#x27;stu1&#x27;].age&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>map.keyname.property</code></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">姓名：$&#123;stuMap.stu2.name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stuMap.stu2.age&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>钱包<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;#--遍历数据 key指的是map中的每一个key--&gt;</span><br><span class="line">    &lt;#list stuMap?keys as key&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            &lt;#--获取当前集合的下标--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;key_index + 1&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[key].name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[key].age&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[key].money&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if 表达式&gt;</span><br><span class="line">&lt;#else&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【例】：姓名为小红的数据字体显示为红色</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if name = &#x27;小红&#x27;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span> = <span class="string">&quot;color: red&quot;</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&lt;#else&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在Freemarker中，<code>=</code> 与 <code>==</code> 是一样的</p></blockquote><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="数值运算符"><a href="#数值运算符" class="headerlink" title="数值运算符"></a>数值运算符</h3><ol><li>加法：+</li><li>减法：-</li><li>乘法：*</li><li>除法：&#x2F;</li><li>求余：%</li></ol><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/assets/846b7c2736084785a2100f9429e9c333.png" alt="846b7c2736084785a2100f9429e9c333.png"></p><blockquote><p>&#x3D; 和 !&#x3D; 可以用于字符串、数值、日期来比较是否相等<br>&#x3D; 和 !&#x3D; 两边必须是相同类型的值，否则会产生错误<br>字符串”x”和”x “和”X”比较是不相等的<br><code>gt</code>代替<code>&gt;</code>，因为Freemarker会把&gt;解析成FTL标签结束的字符串，可以用括号避免这种情况，如：<code>&lt;#if (x &gt; y)&gt;</code></p></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>逻辑与：&amp;&amp;</li><li>逻辑或：||</li><li>逻辑非：!</li></ol><h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><ol><li>判断某个变量是否存在使用：”??”<br>用法：<code>变量??</code><ul><li>变量存在，返回true</li><li>不存在，返回false</li></ul></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if stus??&gt;</span><br><span class="line">&lt;#list stus as stu&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#list&gt;</span><br><span class="line">&lt;/#if&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>缺失的变量使用：<code>!</code><br>用法：<code>!默认值</code><ul><li>使用<code>!</code>要指定一个默认值，当变量为空时显示默认值</li><li>如果是嵌套对象，要使用<code>()</code>括起来</li></ul></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--如果name为空显示空字符串&#x27;&#x27;--&gt;</span><br><span class="line">$&#123;name!&#x27;&#x27;&#125;</span><br><span class="line">&lt;#--如果stu或name为空，默认显示空字符串&#x27;&#x27;--&gt;</span><br><span class="line">$&#123;(stu.name)!&#x27;&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>语法格式：<code>变量 + ? + 函数名称</code></p><ol><li>集合大小</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$&#123;集合名?size&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>日期格式化<br>显示日期+时间：<code>$&#123;today?datetime&#125;</code><br>自定义格式化：<code>$&#123;today?string(&quot;yyyy年MM月&quot;)&#125;</code><br>显示时分秒：<code>$&#123;today?time&#125;</code><br>显示年月日：<code>$&#123;today?date&#125;</code></li><li>内建函数c<br>【场景】：point是数值类型，使用<code>$&#123;point&#125;</code>会显示这个数字的数值，每三位使用逗号分隔。如果不想显示为每隔三位分割的数字，可以使用c函数将数字型转成字符串输出。<br><img src="/assets/62e4f1978b4447a3b40fd0c46c45e969.png" alt="62e4f1978b4447a3b40fd0c46c45e969.png"></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">model.addAttribute(<span class="string">&quot;poin&quot;</span>, <span class="number">123456780L</span>);</span><br></pre></td></tr></table></figure><p>使用内建函数c：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$&#123;point?c&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将json字符串转为对象</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--assign标签的作用：定义一个变量--&gt;</span><br><span class="line">&lt;#assign text=&quot;&#123;&#x27;bank&#x27;:&#x27;工商银行&#x27;,&#x27;account&#x27;:&#x27;10101920201920212&#x27;&#125;&quot; /&gt;</span><br><span class="line">&lt;#--把json转成变量--&gt;</span><br><span class="line">&lt;#assign data=text?eval /&gt;</span><br><span class="line">开户行：$&#123;data.bank&#125;</span><br><span class="line">账号：$&#123;data.account&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：eval的使用可能不安全，如果传入的字符串内容不可控（比如来自用户输入），可能会导致安全问题（例如代码注入）</p></blockquote><h1 id="输出静态化文件"><a href="#输出静态化文件" class="headerlink" title="输出静态化文件"></a>输出静态化文件</h1><p><img src="/assets/f2aa177960304cbeab1740b830d65999.png" alt="f2aa177960304cbeab1740b830d65999.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreemarkerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TemplateException &#123;</span><br><span class="line">        <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> configuration.getTemplate(<span class="string">&quot;test.ftl&quot;</span>); <span class="comment">// 模板对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数：模型数据 mp</span></span><br><span class="line"><span class="comment">         * 第二个参数：输出流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Object&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        mp.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaolin&quot;</span>);</span><br><span class="line">        template.process(mp, <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:/list.html&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Freemarker </tag>
            
            <tag> 模板引擎 </tag>
            
            <tag> 黑马头条 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch下</title>
      <link href="/post/ffdcb30c.html"/>
      <url>/post/ffdcb30c.html</url>
      
        <content type="html"><![CDATA[<h1 id="DSL查询"><a href="#DSL查询" class="headerlink" title="DSL查询"></a>DSL查询</h1><ol><li>叶子查询：在特定字段里查询特定值，属于简单查询，很少单独使用</li><li>复合查询：以逻辑方式组合多个叶子查询或更改叶子查询的行为方式<ul><li>在查询后还可以对查询结果做处理：<ul><li>排序：按照1个或多个字段做排序</li><li>分页：根据from或size做分页，类似MySQL</li><li>高亮：对搜索结果中的关键字添加特殊样式</li><li>聚合：对搜索结果做数据统计以形成报表</li></ul></li></ul></li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;查询类型&quot;: &#123;</span><br><span class="line">      &quot;查询条件&quot;: &quot;条件值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/2b23b9d359714c4cb0f26918da897173.png" alt="2b23b9d359714c4cb0f26918da897173.png"></p><h2 id="叶子查询"><a href="#叶子查询" class="headerlink" title="叶子查询"></a>叶子查询</h2><h3 id="1-全文检索查询"><a href="#1-全文检索查询" class="headerlink" title="1. 全文检索查询"></a>1. 全文检索查询</h3><p>利用分词器对用户输入内容分词，然后去词条列表中匹配，默认按照匹配度排序。例如：match_query、multi_match_query</p><p><code>match查询（常用）</code>：会对用户输入的内容分词，然后去倒排索引检索，语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;: &quot;搜索条件&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：搜索“脱脂牛奶”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>multi_match查询</code>：与match查询类似，只不过允许查询多个字段，参与查询的字段越多，性能越差。语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;搜索条件&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;字段1&quot;, &quot;字段2&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-精确查询"><a href="#2-精确查询" class="headerlink" title="2. 精确查询"></a>2. 精确查询</h3><p>不对用户输入的内容做分词，直接精确匹配，一般是查找keyword、数值、日期、布尔等类型。例如：ids、range、term</p><p><code>term查询（常用）</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;搜索条件&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：查询“牛奶”分类下的商品</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;category&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;牛奶&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range查询</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: &#123;最小值&#125;,</span><br><span class="line">        &quot;lte&quot;: &#123;最大值&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：查询价格≥5k，≤1w</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: <span class="number">500000</span>,</span><br><span class="line">        &quot;lte&quot;: <span class="number">1000000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ids查询</code>：<br>【例】：查询id为1861099和1861100的商品</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;ids&quot;: &#123;</span><br><span class="line">      &quot;values&quot;: [&quot;1861099&quot;, &quot;1861100&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-地理查询"><a href="#3-地理查询" class="headerlink" title="3. 地理查询"></a>3. 地理查询</h3><p>用于搜索地理位置。例如：geo_distance、geo_bounding_box</p><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><h3 id="1-bool查询"><a href="#1-bool查询" class="headerlink" title="1. bool查询"></a>1. bool查询</h3><p>基于逻辑运算组合叶子查询，实现组合条件，例如：bool</p><ol><li>must：必须匹配每个子查询（“与”）</li><li>should：选择性匹配子查询（“或”）</li><li>must_not：必须不匹配，<strong>不参与算分</strong>（“非”）</li><li>filter：必须匹配，<strong>不参与算分</strong>（“与”）</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_search &#123;</span><br><span class="line">&quot;query&quot;: &#123;</span><br><span class="line">bool查询条件: &#123;</span><br><span class="line">叶子查询</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用户在输入框搜索“手机”，在底下：品牌选择“华为”，价格选择“1600以上元”。<br><img src="/assets/bcceb581d0854273bcfb4d9b5a7bb18e.png" alt="bcceb581d0854273bcfb4d9b5a7bb18e.png"></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;手机&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;brand&quot;: &quot;华为&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;price&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: <span class="number">160000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-算分函数查询"><a href="#2-算分函数查询" class="headerlink" title="2. 算分函数查询"></a>2. 算分函数查询</h3><p>基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：function_score、dis_max</p><h2 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>es默认根据相关度算分（_score）来排序，也可以指定字段排序。可以排序的类型有：keyword、数值、地理坐标、日期。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;排序字段&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;排序方式asc和desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：搜索“脱脂牛奶”，结果按照销量排序，销量一样按照价格升序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;sold&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>es默认只返回前10的数据，如果查询更多数据就需要修改分页参数。</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档<br>【例】：搜索“脱脂牛奶”，查询出销量前10的商品，销量一样时按照价格升序</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: <span class="number">0</span>, <span class="operator">/</span><span class="operator">/</span> 分页开始的位置，默认为<span class="number">0</span></span><br><span class="line">  &quot;size&quot;: <span class="number">10</span>, <span class="operator">/</span><span class="operator">/</span> 每页文档数量，默认<span class="number">10</span></span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;sold&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h4><p>es中from + size不能超过1w条，因为太深了会有深度分页问题。<br>【产生原因】因为es存储的数据很多，所以es数据一般会采用分片存储，把一个索引中的数据分成N份，存储到不同的节点上。查询时需要汇总各个分片的数据。查询的页码越深，从每个分片差的数据量越多，内存压力越大，性能越差。<br>【解决办法】<strong>search after模式</strong>：分页时需要<code>排序</code>，原理是在上一次排序后，会记住上一次的排序值，下一次排序时，就会直接从上一次排序值开始，查询下一页数据。</p><ul><li>优点：没有查询上限，支持深度分页</li><li>缺点：只能向后逐页查询，不能随即翻页</li><li>场景：数据迁移，手机滚动查询</li></ul><h2 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h2><p>在搜索结果中，把搜索结果突出显示<br>【原理】：<br>    1. 高亮词条都加了<code>&lt;em&gt;</code>标签，标签上都添加了红色样式<br>    2. 倒排索引在分词的时候，会把词条列表进行分词，还会记录词条在文档中的位置<br><img src="/assets/3468afd108364447873d0a6fac332cba.png" alt="3468afd108364447873d0a6fac332cba.png"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;搜索字段&quot;: &quot;搜索关键字&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;高亮字段名称&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;, <span class="operator">/</span><span class="operator">/</span> 高亮的前置标签</span><br><span class="line">        &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; <span class="operator">/</span><span class="operator">/</span> 高亮的后置标签</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般搜哪个字段，就对哪个字段做高亮，标签可以不加，默认是em</p></blockquote><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/4915936d29da416b9db298d7defdde97.png" alt="4915936d29da416b9db298d7defdde97.png"></p><h1 id="JavaRestClient查询"><a href="#JavaRestClient查询" class="headerlink" title="JavaRestClient查询"></a>JavaRestClient查询</h1><h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><ol><li>构建并发起请求<br><img src="/assets/64e8e6e4bb7f4e9fbf91386bb408a2cc.png" alt="64e8e6e4bb7f4e9fbf91386bb408a2cc.png"></li><li>解析查询结果<br><img src="/assets/e0d930c0b734471ab2b87c60def123f7.png" alt="e0d930c0b734471ab2b87c60def123f7.png"></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建Request对象</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 配置Request参数</span></span><br><span class="line">    request.source()</span><br><span class="line">            .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4. 解析结果</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value; <span class="comment">// 查询的总条数</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits(); <span class="comment">// 查询的结果数组</span></span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();<span class="comment">// 得到source</span></span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="叶子查询-1"><a href="#叶子查询-1" class="headerlink" title="叶子查询"></a>叶子查询</h2><h3 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h3><p><img src="/assets/8e55b250e3064f519fd196741918f652.png" alt="8e55b250e3064f519fd196741918f652.png"></p><h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p><img src="/assets/884f81bd5b1d472f81992205b66c2daf.png" alt="884f81bd5b1d472f81992205b66c2daf.png"></p><h2 id="复合查询-1"><a href="#复合查询-1" class="headerlink" title="复合查询"></a>复合查询</h2><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p><img src="/assets/a7c8fbc7b08e4c529d33aad057a93250.png" alt="a7c8fbc7b08e4c529d33aad057a93250.png"><br>【例】：搜索关键字为“脱脂牛奶”，品牌为“德亚”，价格低于300元</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建Request对象</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 配置Request参数</span></span><br><span class="line">    request.source().query(</span><br><span class="line">            QueryBuilders.boolQuery()</span><br><span class="line">                    .must(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>))</span><br><span class="line">                    .filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;德亚&quot;</span>))</span><br><span class="line">                    .filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lt(<span class="number">30000</span>))</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4. 解析结果</span></span><br><span class="line">    parseResponseResult(response); <span class="comment">// 对上边解析response的步骤进行了封装</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序和分页-1"><a href="#排序和分页-1" class="headerlink" title="排序和分页"></a>排序和分页</h2><p><img src="/assets/18b783395c2b4960bd2b2ba510271222.png" alt="18b783395c2b4960bd2b2ba510271222.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSortAndPage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery()) <span class="comment">// query条件</span></span><br><span class="line">            .from((pageNo - <span class="number">1</span>) * pageSize).size(pageSize) <span class="comment">// 分页条件(分页开始的位置, 每页文档数量)</span></span><br><span class="line">            .sort(<span class="string">&quot;sold&quot;</span>, SortOrder.DESC)</span><br><span class="line">            .sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC); <span class="comment">// 排序条件(排序字段, 排序方式)</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    parseResponseResult(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高亮显示-1"><a href="#高亮显示-1" class="headerlink" title="高亮显示"></a>高亮显示</h2><p><img src="/assets/e3a3c7b588604fb496f34acb625fc0d9.png" alt="e3a3c7b588604fb496f34acb625fc0d9.png"><br>高亮显示的结果解析：<br><img src="/assets/c3e042b09f4c4baaa1fc3755d933deb1.png" alt="c3e042b09f4c4baaa1fc3755d933deb1.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighLight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>)) <span class="comment">// 查询条件</span></span><br><span class="line">            .highlighter(SearchSourceBuilder.highlight().field(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 高亮条件</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    parseResponseResult(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于高亮的结果不是在source里的，所以parseResponseResult()方法需要添加对高亮的处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseResponseResult</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">   <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">   <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value; <span class="comment">// 查询的总条数</span></span><br><span class="line">   SearchHit[] hits = searchHits.getHits(); <span class="comment">// 查询的结果数组</span></span><br><span class="line">   <span class="keyword">for</span>(SearchHit hit : hits) &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();<span class="comment">// 得到source</span></span><br><span class="line">       <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(json, ItemDoc.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ===处理高亮结果===</span></span><br><span class="line">       Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();</span><br><span class="line">       <span class="keyword">if</span>(hfs != <span class="literal">null</span> &amp;&amp; !hfs.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">// 根据高亮字段名获取高亮结果</span></span><br><span class="line">           <span class="type">HighlightField</span> <span class="variable">hf</span> <span class="operator">=</span> hfs.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">           <span class="comment">// 获取高亮结果后，用高亮结果覆盖非高亮结果</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">hfName</span> <span class="operator">=</span> hf.getFragments()[<span class="number">0</span>].string(); <span class="comment">// 高亮结果</span></span><br><span class="line">           itemDoc.setName(hfName); <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(itemDoc);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h1><p>聚合可以实现对文档数据的统计、分析、运算，聚合常见的有：</p><ol><li><code>桶聚合</code>：用来对文档做分组<ul><li>TermAggregation（<strong>term</strong>）：按照文档字段值分组</li><li>Date Histogram：按照日期阶梯分组，例如：一周为一组，或一月为一组</li></ul></li><li><code>度量聚合</code>：用来计算一些值，如：最大值、最小值、平均值<ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum</li></ul></li><li><code>管道聚合</code>：其他聚合结果为基础做聚合，聚合的数据是其他聚合的结果</li></ol><blockquote><p>参与聚合的字段必须是Keyword、数值、日期、布尔类型的字段</p></blockquote><h2 id="DSL聚合"><a href="#DSL聚合" class="headerlink" title="DSL聚合"></a>DSL聚合</h2><p>【例1】：统计所有商品中的商品分类</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) &quot;categroyAgg&quot; <span class="keyword">from</span> items <span class="keyword">group</span> <span class="keyword">by</span> category</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;, <span class="operator">/</span><span class="operator">/</span> 如果使用&quot;match_all&quot;，可以省略</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>, <span class="operator">/</span><span class="operator">/</span> 如果不设置size，默认为<span class="number">10</span>，不仅会返回聚合结果，还会返回搜索结果，增加网络传输的负担</span><br><span class="line">  &quot;aggs&quot;: &#123; <span class="operator">/</span><span class="operator">/</span> 定义聚合</span><br><span class="line">    &quot;categroyAgg&quot;: &#123; <span class="operator">/</span><span class="operator">/</span> 给聚合起个名字</span><br><span class="line">      &quot;terms&quot;: &#123; <span class="operator">/</span><span class="operator">/</span> 聚合的类型，按照分类聚合，所以选择term</span><br><span class="line">        &quot;field&quot;: &quot;category&quot;, <span class="operator">/</span><span class="operator">/</span> 参与聚合的字段</span><br><span class="line">        &quot;size&quot;: <span class="number">5</span> <span class="operator">/</span><span class="operator">/</span> 希望获取的聚合结果数量</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/f29c201884a04b25be600954c26364a5.png" alt="f29c201884a04b25be600954c26364a5.png"><br>【例2】：统计手机的品牌，每个品牌价格的最小值、最大值、平均值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;category&quot;: &quot;手机&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brand&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;price_stats&quot;: &#123;</span><br><span class="line">          &quot;stats&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/4c0c108af89348e08fcc888e6cd7fd42.png" alt="4c0c108af89348e08fcc888e6cd7fd42.png"></p><h2 id="JavaRestClient聚合"><a href="#JavaRestClient聚合" class="headerlink" title="JavaRestClient聚合"></a>JavaRestClient聚合</h2><p><img src="/assets/6a085a6d89bd4516ac36f3e34ff2258a.png" alt="6a085a6d89bd4516ac36f3e34ff2258a.png"><br>解析聚合结果：<br><img src="/assets/b71d01646c2842bfaf933f0048f6fa70.png" alt="b71d01646c2842bfaf933f0048f6fa70.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAgg</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandAggName</span> <span class="operator">=</span> <span class="string">&quot;brandAgg&quot;</span>;</span><br><span class="line">    request.source()</span><br><span class="line">            .size(<span class="number">0</span>) <span class="comment">// 不返回文段，只返回聚合结果</span></span><br><span class="line">            .aggregation(AggregationBuilders.terms(brandAggName) <span class="comment">// 聚合类型、聚合名称</span></span><br><span class="line">                    .field(<span class="string">&quot;brand&quot;</span>) <span class="comment">// 聚合字段</span></span><br><span class="line">                    .size(<span class="number">20</span>) <span class="comment">// 聚合返回结果</span></span><br><span class="line">            );</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 解析结果</span></span><br><span class="line">    <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    <span class="comment">// 根据聚合名称获取对应的聚合</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">terms</span> <span class="operator">=</span> aggregations.get(brandAggName); <span class="comment">// 这里用了向下转型（Aggregation：父、Terms：子）</span></span><br><span class="line">    <span class="comment">// 获取buckets</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = terms.getBuckets();</span><br><span class="line">    <span class="comment">// 遍历每一个bucket</span></span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;brand:&quot;</span> + bucket.getKeyAsString());</span><br><span class="line">        System.out.println(<span class="string">&quot;count:&quot;</span> + bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch上</title>
      <link href="/post/88db839a.html"/>
      <url>/post/88db839a.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h1><ul><li>Lucene：Java语言的搜索引擎类库，易扩展；高性能（基于倒排索引）</li><li>Elasticsearch基于Lucene，支持分布式，可水平扩展；提供Restful接口，可被任何语言调用</li><li>Elasticsearch结合kibana、logstash、Beats，是一套完整的技术栈，被叫做ELK。<br><img src="/assets/930b9838c9514033be11e0400478269a.png" alt="930b9838c9514033be11e0400478269a.png"></li></ul><h2 id="安装ElasticSearch-1"><a href="#安装ElasticSearch-1" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name es \</span><br><span class="line">  -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \</span><br><span class="line">  -e &quot;discovery.type=single-node&quot; \</span><br><span class="line">  -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">  -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">  --privileged \</span><br><span class="line">  --network hm-net \</span><br><span class="line">  -p 9200:9200 \</span><br><span class="line">  -p 9300:9300 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><ul><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code> ：配置JVM的最大最小内存</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：配置运行模式（集群模式、单点模式）</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：es的数据存储目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：es的插件目录</li><li><code>-p 9200:9200</code>：访问的http端口</li><li><code>-p 9300:9300</code>：集群间通信端口</li></ul><blockquote><p>查看es的日志：<code> docker logs -f es</code><br><img src="/assets/5bf4577a4b594756b3bf188e79fe0cfd.png" alt="5bf4577a4b594756b3bf188e79fe0cfd.png"><br><img src="/assets/28d478f9ecc14c87b0b46d9900bddf77.png" alt="28d478f9ecc14c87b0b46d9900bddf77.png"></p></blockquote><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>Kibana是个图形界面，帮助我们连接es</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=hm-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">--restart=always \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure><ul><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200 \</code>：因为kibana和es在同一个网络下，所以可以通过容器名直接连接es<br><img src="/assets/d7e47a8ae9324d3baeea300602dfc6e4.png" alt="d7e47a8ae9324d3baeea300602dfc6e4.png"></li></ul><blockquote><p>安装成功后，在浏览器输入：<code>http://192.168.140.101:5601/</code>，看到响应即安装成功。<br><img src="/assets/c40ab9bb8a294d60a4402f1380cdabd6.png" alt="c40ab9bb8a294d60a4402f1380cdabd6.png"><br>可以利用kibana中<code>Dev Tools</code>控制台向es发送http请求</p></blockquote><h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>MySQL采用的是正向索引：<br><img src="/assets/4001096f000443a9b7421bc5e89416ac.png" alt="4001096f000443a9b7421bc5e89416ac.png"></p><blockquote><p>查询词条时需要<code>逐行遍历文档</code>，再判断文档中是否包含了词条</p></blockquote><p>Elasticsearch采用倒排索引：</p><ul><li>文档（document）：每条数据就是一个文档</li><li>词条（term）：文档按照语义分成的词语<br><img src="/assets/831fb28a305940a7a15ea2292f0d9863.png" alt="831fb28a305940a7a15ea2292f0d9863.png"></li></ul><blockquote><p>用户搜索的时候，先对用户搜索的数据进行分词，将分词后的词条放到<code>词条列表</code>中得到文档id，根据文档id去<code>文档列表</code>中查询。虽然有两次查询，但是每次查询都是有索引，搜索速度快。</p></blockquote><h1 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h1><p>中文分词往往需要根据语义，比较复杂，这就需要用到中文分词器，例如：<code>IK分词器</code>。<br>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip">IK分词器</a></p><h2 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h2><p>只需要把IK分词器下载后放到<code>es的插件目录</code>后<code>重启es</code>即可生效。<br><img src="/assets/065c15d57a1e4149ae334cb4176c6253.png" alt="065c15d57a1e4149ae334cb4176c6253.png"></p><h2 id="测试IK分词器是否安装成功"><a href="#测试IK分词器是否安装成功" class="headerlink" title="测试IK分词器是否安装成功"></a>测试IK分词器是否安装成功</h2><h3 id="ik-smart"><a href="#ik-smart" class="headerlink" title="ik_smart"></a>ik_smart</h3><p>智能切分，粗粒度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;今天天气真好&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/bcd463bbd34c4d8aae5c8156aab1a128.png" alt="bcd463bbd34c4d8aae5c8156aab1a128.png"></p><h3 id="ik-max-word"><a href="#ik-max-word" class="headerlink" title="ik_max_word"></a>ik_max_word</h3><p>最细切分，细粒度IK分词器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;今天天气真好&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/f672e0f46f2d4537b0cbd985ebd8a65e.png" alt="f672e0f46f2d4537b0cbd985ebd8a65e.png"></p><h2 id="自定义词典"><a href="#自定义词典" class="headerlink" title="自定义词典"></a>自定义词典</h2><p>可以在ik插件的config目录下的IKAnalyzer.cfg.xml文件配置<code>扩展词典</code>、<code>停止词典</code><br><img src="/assets/3dee2da829594868a3380a1284a3f975.png" alt="3dee2da829594868a3380a1284a3f975.png"></p><h1 id="ElasticSearch中基础概念"><a href="#ElasticSearch中基础概念" class="headerlink" title="ElasticSearch中基础概念"></a>ElasticSearch中基础概念</h1><p><img src="/assets/8d52bf4e8af14734ae540e7c7384115b.png" alt="8d52bf4e8af14734ae540e7c7384115b.png"></p><h1 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h1><p>索引库相当于MySQL里的表，Mapping相当于对表字段的约束</p><h2 id="Mapping映射属性"><a href="#Mapping映射属性" class="headerlink" title="Mapping映射属性"></a>Mapping映射属性</h2><p>mapping是对索引库中文档的约束。</p><ol><li>type：字段数据类型<ul><li>字符串：text（可分词文本）、keyword（精确值，不能分词，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float</li><li>布尔：boolean</li><li>日期：date（es自己把日期对象做了序列化）</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true<ul><li>true：es就会给这个字段创建倒排索引，就可以根据这个字段进行搜索或排序</li></ul></li><li>analyzer：使用哪种分词器（ik_smart、ik_max_word），只有字段类型是text才需要指定分词器</li><li>properties：该字段的子字段</li></ol><blockquote><p>在es中，不需要管是否是数组，就算是数组，也只要指定元素的类型即可</p></blockquote><h2 id="索引库的CRUD"><a href="#索引库的CRUD" class="headerlink" title="索引库的CRUD"></a>索引库的CRUD</h2><p>es中提供的API都是Restful的接口，遵循Restful的基本规范：<br><img src="/assets/3280b872e43b4f0a81e21e2fe3e6e444.png" alt="3280b872e43b4f0a81e21e2fe3e6e444.png"></p><h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PUT <span class="operator">/</span>索引库名称</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;, <span class="operator">/</span><span class="operator">/</span> 可分词</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;字段名2&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;, <span class="operator">/</span><span class="operator">/</span> 不可分词</span><br><span class="line">        &quot;index&quot;: &quot;false&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;字段名3&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;子字段&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="operator">/</span><span class="operator">/</span> ...略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建索引库</span><br><span class="line">PUT <span class="operator">/</span>people </span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;info&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;byte&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;email&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;false&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;firstName&quot;:&#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;lastName&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/f7dfaa5973ff49fcbc8a1a9611342af8.png" alt="f7dfaa5973ff49fcbc8a1a9611342af8.png"></p><h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PUT <span class="operator">/</span>索引库名<span class="operator">/</span>_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;新字段名&quot;:&#123;</span><br><span class="line">      &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 修改索引库，新增一个sex字段</span><br><span class="line">PUT <span class="operator">/</span>people<span class="operator">/</span>_mapping </span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;sex&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：es中是<code>不允许对已有索引库的字段进行修改</code>，但是<code>允许添加新的字段</code>。<br>【原因】：假设已经在es中创建大量的倒排索引，做了大量的分词，如果此时需要修改索引库，那么前期做的所有分词都作废还要重新建立倒排索引，对于整个数据库的影响很大。</p></blockquote><h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询索引库</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名</span><br></pre></td></tr></table></figure><h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除索引库</span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">/</span>索引库名</span><br></pre></td></tr></table></figure><h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><h2 id="文档的CRUD"><a href="#文档的CRUD" class="headerlink" title="文档的CRUD"></a>文档的CRUD</h2><h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>索引库名<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;字段1&quot;: &quot;值1&quot;,</span><br><span class="line">    &quot;字段2&quot;: &quot;值2&quot;,</span><br><span class="line">    &quot;字段3&quot;: &#123;</span><br><span class="line">        &quot;子属性1&quot;: &quot;值3&quot;,</span><br><span class="line">        &quot;子属性2&quot;: &quot;值4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>people<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;info&quot;: &quot;程序员&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;xiaolin0333@qq.com&quot;,</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">        &quot;firstName&quot;: &quot;林&quot;,</span><br><span class="line">        &quot;lastName&quot;: &quot;三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新增文档的时候最好指定文档id，es会根据文档id创建索引，如果不指定id，es会随机生成id，这样将来操作文档就会很不方便</p></blockquote><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><h4 id="1-全量修改"><a href="#1-全量修改" class="headerlink" title="1. 全量修改"></a>1. 全量修改</h4><p>删除旧文档，添加新文档</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PUT <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;字段1&quot;: &quot;值1&quot;,</span><br><span class="line">    &quot;字段2&quot;: &quot;值2&quot;,</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> ... 文档的所有字段都要写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：如果想要修改一个文档id不存在的文档，删除文档的时候，文档不存在，会直接新增一条文档<br>因此PUT请求具备了<code>新增</code>和<code>修改</code>两种功能</p><ul><li>新增：文档id不存在</li><li>修改：文档id存在</li></ul></blockquote><h4 id="2-增量修改"><a href="#2-增量修改" class="headerlink" title="2. 增量修改"></a>2. 增量修改</h4><p>修改部分字段值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_update<span class="operator">/</span>文档id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">         &quot;字段名&quot;: &quot;新的值&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询文档</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br></pre></td></tr></table></figure><p><img src="/assets/ace01edaf4b84bc0a8ad8f48d168782c.png" alt="ace01edaf4b84bc0a8ad8f48d168782c.png"></p><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除文档</span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br></pre></td></tr></table></figure><h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>es中允许通过一次请求中携带多次文档操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;1&quot; &#125; &#125; <span class="operator">/</span><span class="operator">/</span> 新增（索引库名、id）</span><br><span class="line">&#123; &quot;field1&quot; : &quot;value1&quot; &#125; <span class="operator">/</span><span class="operator">/</span> 新增的文档信息</span><br><span class="line"></span><br><span class="line">&#123; &quot;delete&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;2&quot; &#125; &#125; <span class="operator">/</span><span class="operator">/</span> 删除（索引库名、id）</span><br><span class="line"></span><br><span class="line">&#123; &quot;update&quot; : &#123;&quot;_id&quot; : &quot;1&quot;, &quot;_index&quot; : &quot;test&quot;&#125; &#125; <span class="operator">/</span><span class="operator">/</span> 更新（索引库名、id）</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125; <span class="operator">/</span><span class="operator">/</span> 更新的文档信息（增量修改）</span><br></pre></td></tr></table></figure><blockquote><p>写的时候不能换行，只能在一行写，否则会报错</p></blockquote><p>【例1】：批量新增</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>_bulk </span><br><span class="line">  &#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;2&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;info&quot;: &quot;这是人&quot;, &quot;email&quot;: &quot;xiaolin0333@qq.com&quot;, &quot;name&quot;: &#123;&quot;firstName&quot;: &quot;林&quot;, &quot;lastName&quot;: &quot;三&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;3&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;info&quot;: &quot;这是狗&quot;, &quot;email&quot;: &quot;cmb@qq.com&quot;, &quot;name&quot;: &#123;&quot;firstName&quot;: &quot;柴&quot;, &quot;lastName&quot;: &quot;犬&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>【例2】：批量删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>_bulk </span><br><span class="line">  &#123;&quot;delete&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;2&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;delete&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;3&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaRestClient"><a href="#JavaRestClient" class="headerlink" title="JavaRestClient"></a>JavaRestClient</h1><h2 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h2><ol><li>引入es的RestHighLevelClient的依赖：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>因为SpringBoot默认ES的版本是7.17.0，所以需要覆盖默认的ES版本：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>初始化RestHighLevelClient（这里暂时先用单元测试为例）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client = &quot;</span> + client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@BeforeEach</span> <span class="comment">// 初始化方法：在单元测试执行前</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.140.101:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterEach</span> <span class="comment">// 销毁方法：在单元测试执行后</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(client != <span class="literal">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="商品表Mapping映射"><a href="#商品表Mapping映射" class="headerlink" title="商品表Mapping映射"></a>商品表Mapping映射</h2><p>【业务分析】：<br><img src="/assets/e9b41e2aadc4472abdeecb3f50a41b3a.png" alt="e9b41e2aadc4472abdeecb3f50a41b3a.png"><br><img src="/assets/ece92419c1134c71a9eaefe155ad8864.png" alt="ece92419c1134c71a9eaefe155ad8864.png"><br>【在控制台创建Mapping映射】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 商品索引库</span><br><span class="line">PUT <span class="operator">/</span>hmall</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;image&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;category&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;brand&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;sold&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;commentCount&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;index&quot;: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;isAD&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;updateTime&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引库操作-1"><a href="#索引库操作-1" class="headerlink" title="索引库操作"></a>索引库操作</h2><ol><li>创建XxxIndexRequest。Xxx指：Create、Get、Delete</li><li>准备请求参数（Create需要）</li><li>发送请求。调用client.indices.xxx()方法，xxx指：create、get、exists、delete</li></ol><h3 id="创建索引库-1"><a href="#创建索引库-1" class="headerlink" title="创建索引库"></a>创建索引库</h3><p>创建索引库的JavaAPI和Restful接口API对比：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 准备请求参数</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON); <span class="comment">// MAPPING_TEMPLATE就是前面在控制台写的那段</span></span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/65d6537c9bab4055847d8fae1a6b8d72.png" alt="65d6537c9bab4055847d8fae1a6b8d72.png"></p><h3 id="查询索引库-1"><a href="#查询索引库-1" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 发送请求</span></span><br><span class="line">    <span class="type">GetIndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().get(request, RequestOptions.DEFAULT);<span class="comment">// 查询索引库（索引库不存在报错）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);<span class="comment">// 判断索引库是否存在（索引库不存在返回false）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="comment">// 1. 准备Request对象</span></span><br><span class="line">     <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">     <span class="comment">// 2. 发送请求</span></span><br><span class="line">     client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="文档操作-1"><a href="#文档操作-1" class="headerlink" title="文档操作"></a>文档操作</h2><ol><li>初始化RestHighLevelClient</li><li>创建XxxRequest。Xxx指：Index、Get、Update、Delete</li><li>准备参数（Index和Update需要）</li><li>请求参数。调用xxx()方法，xxx是index、get、update、delete</li><li>解析结果（Get需要）</li></ol><h3 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h3><p>新增文档的JavaAPI和Restful接口API对比：<br><img src="/assets/22d934d176f3427d9b51644eb52e8dbb.png" alt="22d934d176f3427d9b51644eb52e8dbb.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIndexDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 准备文档数据</span></span><br><span class="line">    <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getById(<span class="number">2018833</span>);</span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class); <span class="comment">// 文档数据对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(itemDoc); <span class="comment">// JSON</span></span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(itemDoc.getId());<span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 准备JSON文档</span></span><br><span class="line">    request.source(jsonStr, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><h4 id="全量修改"><a href="#全量修改" class="headerlink" title="全量修改"></a>全量修改</h4><p>全量修改相当于新增，就是新增的时候文档id已经存在</p><h4 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h4><p><img src="/assets/f369c5e2c72644c18b1cdec0eac46372.png" alt="f369c5e2c72644c18b1cdec0eac46372.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;2018833&quot;</span>); <span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>, <span class="number">25600</span>,</span><br><span class="line">            <span class="string">&quot;stock&quot;</span>, <span class="number">9999</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h3><p>查询文档主要是拿到_source部分<br><img src="/assets/98d5e2804ab847c2b7656976a4c8f037.png" alt="98d5e2804ab847c2b7656976a4c8f037.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;2018833&quot;</span>); <span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 发送请求</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">doc</span> <span class="operator">=</span> JSONUtil.toBean(json, ItemDoc.class);</span><br><span class="line">    System.out.println(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;2018833&quot;</span>); <span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>构建请求时会用到BulkRequest来封装普通的CRUD请求：<br><img src="/assets/018d138da6544a71aed9f9d5387c3fb6.png" alt="018d138da6544a71aed9f9d5387c3fb6.png"><br>【案例】：往索引库里添加所有上架的商品</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 0. 准备文档数据</span></span><br><span class="line">        Page&lt;Item&gt; page = itemService.lambdaQuery()</span><br><span class="line">                .eq(Item::getStatus, <span class="number">1</span>) <span class="comment">// 上架商品</span></span><br><span class="line">                .page(Page.of(pageNo, pageSize));</span><br><span class="line">        List&lt;Item&gt; records = page.getRecords();</span><br><span class="line">        <span class="keyword">if</span>(records == <span class="literal">null</span> || records.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 准备Request</span></span><br><span class="line">        <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">        <span class="comment">// 2. 准备数据-批量新增</span></span><br><span class="line">        <span class="keyword">for</span>(Item item : records) &#123;</span><br><span class="line">            <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);</span><br><span class="line">            request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(item.getId().toString()).source(JSONUtil.toJsonStr(itemDoc), XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 发送请求</span></span><br><span class="line">        client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">        pageNo++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ确保消息可靠性</title>
      <link href="/post/619a560a.html"/>
      <url>/post/619a560a.html</url>
      
        <content type="html"><![CDATA[<h1 id="消息丢失的可能性"><a href="#消息丢失的可能性" class="headerlink" title="消息丢失的可能性"></a>消息丢失的可能性</h1><p><img src="/assets/d2795a487f804ce59f0ec8a984b9cf18.png" alt="d2795a487f804ce59f0ec8a984b9cf18.png"><br>支付服务先扣减余额和更新支付状态（这俩是同步调用），然后通过RabbitMq异步调用支付服务更新订单状态。但是有些情况下，可能订单已经支付 ，但是更新订单状态却失败了，这就出现了消息丢失。</p><ol><li><code>发送者</code>在发送的过程中出现了网络故障</li><li><code>RabbitMQ</code>在发送消息的过程中出现了问题</li><li><code>消费者</code>在更新订单状态的时候出现了问题</li></ol><h1 id="发送者的可靠性"><a href="#发送者的可靠性" class="headerlink" title="发送者的可靠性"></a>发送者的可靠性</h1><p>发送者确认机制需要与MQ进行通信和确认，会影响消息发送的效率且一般出现的概率极低，所以一般不用这个。</p><hr><h2 id="方法1-发送者重连"><a href="#方法1-发送者重连" class="headerlink" title="方法1. 发送者重连"></a>方法1. 发送者重连</h2><p>确保发送者与MQ之间连接的可靠性。有的时候由于网络波动，可能出现发送者连接MQ失败的情况，这个配置是关闭的，可以开启连接失败后的重连机制：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制(默认是false)</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><blockquote><p>【注】：当网络不稳定时，利用重试机制可以提高消息发送的成功率，但是SpringAMQP提供的重试机制是<code>阻塞式</code>的重试，如果需要多次重试等待，当前线程被阻塞，会影响性能。<br>如果对业务性能有要求，建议<code>禁用</code>重试机制，如果一定要使用，要合理的配置等待时常和重试次数，或使用<code>异步线程</code>来执行发送消息的代码。</p></blockquote><h2 id="方法2-发送者确认"><a href="#方法2-发送者确认" class="headerlink" title="方法2. 发送者确认"></a>方法2. 发送者确认</h2><p>确保消息发送的可靠性。SpringAMQP提供了Publisher Confirm和Publisher Return两种机制，开启确认机制后，当发送者发送消息给MQ后，MQ会返回确认结果给发送者，返回的结果有以下几种情况：</p><ul><li>消息投递到MQ，但是路由失败，此时通过PublisherReturn返回路由异常信息，然后返回<code>ACK</code>，告知投递成功。例如：<ul><li><pre><code>消息发送给图中的exchange1，但是RoutingKey写错了，没有匹配到正确的队列，也会导致路由失败。</code></pre></li><li><pre><code>消息发送给图中的exchange2，但是它底下没有绑定新的队列，就会导致路由失败。</code></pre></li></ul></li><li>临时消息【不需要往磁盘做持久化的消息】投递到MQ，并入队成功，返回<code>ACK</code>，告知投递成功。</li><li>持久消息投递到MQ，并入队完成持久化，返回<code>ACK</code>，告知投递成功。</li><li>其他情况都会返回<code>NACK</code>，告知投递失败。<br><img src="/assets/1d5dac29f79645f7b70988aec1b9332c.png" alt="1d5dac29f79645f7b70988aec1b9332c.png"><br>步骤：</li></ul><ol><li>在发送方publisher所在的微服务的application.yml中配置：</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><blockquote><p>publisher-confirm-type有三种模式：</p><ul><li>none：关闭confirm机制</li><li>simple：同步阻塞等待MQ回执消息</li><li>correlated：MQ异步回调方式返回回执消息（常用）</li></ul></blockquote><ol start="2"><li>开启回调机制：每个RabbitTemplate只能配置一个ReturnCallback，在发送者publisher所在的项目启动时配置即可。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// 在Bean初始化完成后调用这个方法（只会调用一次）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回ACK，但是此时路由失败，就会走这个方法</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(returnedMessage -&gt; &#123;</span><br><span class="line">            log.error(<span class="string">&quot;监听到了消息return callback&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returnedMessage.getExchange());</span><br><span class="line">            log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returnedMessage.getRoutingKey());</span><br><span class="line">            log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returnedMessage.getMessage());</span><br><span class="line">            log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returnedMessage.getReplyCode());</span><br><span class="line">            log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>开启消息确认机制：发送消息、指定消息ID、每次发送消息都需要配置一个ConfirmCallback</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConfirmCallback</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">  cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">      <span class="comment">// 【几乎不可能发生】Future发生异常时的处理逻辑</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">          log.error(<span class="string">&quot;spring ampq处理确认结果异常&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 成功，拿到MQ结果，判断是ACK还是NACK</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(result.isAck()) &#123;</span><br><span class="line">              <span class="comment">// ACK</span></span><br><span class="line">              log.debug(<span class="string">&quot;收到ACK，消息发送成功&quot;</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// NACK</span></span><br><span class="line">              log.debug(<span class="string">&quot;收到NACK，消息发送失败，失败原因：&#123;&#125;&quot;</span>,result.getReason());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;hello world&quot;</span>, cd); <span class="comment">// 发送消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h1><p>RabbitMQ一般会将收到的信息保存到<strong>内存</strong>（速度快）中，降低消息收发的延迟，这样会导致：</p><ol><li>MQ宕机，内存中的消息会丢失。</li><li>内存空间有限，消费者故障或处理过慢，会导致消息积压，引发MQ阻塞。<br><img src="/assets/b6edb928b1264d50a5b503b2c56e5df9.png" alt="b6edb928b1264d50a5b503b2c56e5df9.png"></li></ol><blockquote><p>【案例】发送者往MQ发消息，MQ会把数据保存到内存中，如果内存<strong>满了</strong>，MQ就会把一部分数据迁移到磁盘中暂时进行持久化存储，移动到磁盘的这段时间发送者发送的消息就会产生丢失。</p></blockquote><h2 id="方法1-数据持久化"><a href="#方法1-数据持久化" class="headerlink" title="方法1. 数据持久化"></a>方法1. 数据持久化</h2><p>数据持久化就是把数据持久化到磁盘，但是不是向上边那个案例，等满了再去持久化（被动），而是提前进行持久化。</p><ol><li>交换机的持久化（默认开启的）<br><img src="/assets/8a372d3f987e4948a4e72a6ba5a9b0d3.png" alt="8a372d3f987e4948a4e72a6ba5a9b0d3.png"></li><li>队列的持久化（默认开启的）<br><img src="/assets/87f68a2ef34a485db948adb22b1a51cf.png" alt="87f68a2ef34a485db948adb22b1a51cf.png"></li><li>消息持久化（默认是非持久的）<br>在发送消息的时候设定的<br><img src="/assets/af7cbfc0248d4d598289121a8f7bf452.png" alt="af7cbfc0248d4d598289121a8f7bf452.png"><br>【<code>案例</code>】：比较一下持久化和非持久化的性能。<br>发100w条消息给MQ：<br>这是非持久化的方式：使用纯内存的方式存储，每次内存满之后，MQ就会把消息写到磁盘中，此时就会出现阻塞状态，处理速度降低到0<br><img src="/assets/c299dfe47826452d93a6d5ff9731fb21.png" alt="c299dfe47826452d93a6d5ff9731fb21.png"><br>【<code>问题</code>】可能出现消息丢失和MQ阻塞<br>【<code>解决办法</code>】使用持久化的方式：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendPersistentMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义构建消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8)) <span class="comment">// 消息体</span></span><br><span class="line">            .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="comment">// 投递模式（持久化）</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mq并没有阻塞，每发一条消息就赶紧把它存到磁盘中，和纯内存方式相比，不会有个中断的过程。<br><img src="/assets/a7722b341dda45fa8520dce35998273c.png" alt="a7722b341dda45fa8520dce35998273c.png"></p><h2 id="方法2-Lazy-Queue（推荐）"><a href="#方法2-Lazy-Queue（推荐）" class="headerlink" title="方法2. Lazy Queue（推荐）"></a>方法2. Lazy Queue（推荐）</h2><p>【<code>问题</code>】：由于使用了消息持久化的方式，发到MQ的消息不仅要到内存，还要在磁盘中写一份，这会导致整体的并发能力下降<br>【<code>特征</code>】：</p><ul><li>接收到消息后直接入磁盘，不再存储到内存</li><li>在写磁盘的时候也对写入磁盘的操作进行一些优化，比传统的写操作高很多</li><li>消费者要消费消息时，才会从磁盘中读取并加载到内存<ul><li>【<code>问题</code>】：可能会影响消费者处理消息的速度</li><li>【<code>解决</code>】：可以提前缓存部分消息到内存，最多2048条</li></ul></li></ul><h3 id="控制台声明Lazy-Queue队列"><a href="#控制台声明Lazy-Queue队列" class="headerlink" title="控制台声明Lazy Queue队列"></a>控制台声明Lazy Queue队列</h3><p><img src="/assets/423f7c05c9014ea4b6a827925a1c0a41.png" alt="423f7c05c9014ea4b6a827925a1c0a41.png"></p><h3 id="Java代码添加"><a href="#Java代码添加" class="headerlink" title="Java代码添加"></a>Java代码添加</h3><h4 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RabbitListener注解"><a href="#RabbitListener注解" class="headerlink" title="@RabbitListener注解"></a>@RabbitListener注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;) // 开启Lazy模式</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h1><h2 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h2><p>为了确认消费者是否成功处理消息，当消费者处理消息结束后，应该向MQ发送一个回执，告知MQ自己的消息处理状态。有如下几种消息处理状态：</p><ul><li>ack：处理消息成功，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息【在处理的过程中，发现消息的内容有问题，没有重试的必要，直接拒绝就行】</li></ul><blockquote><p>【注意】：不管是哪种情况，都应该等消息处理完后得到结果再返回，不要一拿到消息就返回<br>返回消息处理状态的过程，类似于处理事务，事务处理成功，返回ACK；处理失败，返回NACK</p></blockquote><p>SpringAMQP允许通过在消费者的配置文件选择ACK的处理方式，有三种：</p><ul><li>none：不处理，消息投递给消费者后立刻ack，消息会立刻从MQ中删除，别用</li><li>manual：手动模式，需要在业务代码中调用api，发送ack或reject，存在业务入侵，但是更灵活。</li><li>auto：自动模式，利用AOP对消息处理逻辑进行了环绕增强<ul><li>业务处理正常：自动返回<code>ack</code></li><li>业务处理异常：自动返回<code>nack</code></li><li>消息处理或校验异常【MessageConversionException】：自动返回<code>reject</code></li></ul></li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto#</span> <span class="string">不做处理</span></span><br></pre></td></tr></table></figure><h2 id="失败重试策略"><a href="#失败重试策略" class="headerlink" title="失败重试策略"></a>失败重试策略</h2><p>在消费者出现异常时，利用本地重试，而不是无限的重新入队到mq，可以在消费者的yaml文件中添加配置来开启重试机制。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数（达到最大重试次数后，MQ会把消息丢弃）</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p>【<code>问题</code>】：在开启重试模式后，重试次数耗尽，如果消息仍然失败，默认会把消息进行丢弃。<br>【<code>解决</code>】：因此需要有MessageRecoverer接口来处理，包含三种不同的实现：</p><ul><li>RejectAndDontRequeueRecoverer（默认）：重试耗尽后，直接reject，丢弃消息。</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队。</li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机 。<br><img src="/assets/37694c723e9b44a39bee6b67070c4b07.png" alt="37694c723e9b44a39bee6b67070c4b07.png"></li></ul><h3 id="修改失败重试策略为RepublishMessageRecoverer"><a href="#修改失败重试策略为RepublishMessageRecoverer" class="headerlink" title="修改失败重试策略为RepublishMessageRecoverer"></a>修改失败重试策略为RepublishMessageRecoverer</h3><ol><li>定义接收失败的交换机、队列、 </li><li>定义RepublishMessageRecoverer</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 定义接收失败的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义接收失败的队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorQueueBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue())</span><br><span class="line">                .to(errorExchange())</span><br><span class="line">                .with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义失败处理策略</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">messageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h2><p>f(x) &#x3D; f(f(x))，指同一个业务，执行一次或多次对业务状态的影响是一致的。</p><ul><li>幂等业务：查询业务、删除业务</li><li>非幂等业务：用户下单需要扣减库存、用户退款业务需要恢复余额</li></ul><h3 id="方案1-唯一消息id"><a href="#方案1-唯一消息id" class="headerlink" title="方案1. 唯一消息id"></a>方案1. 唯一消息id</h3><p>给每个消息设置一个唯一id，利用id区分是否是重复消息：</p><ul><li>每条消息都生成一个唯一id，与消息一起投递给消费者</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息id保存到数据库中</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则视为重复消息放弃处理</li></ul><ol><li>在发送方配置Bean用来自动创建消息id</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">        converter.setCreateMessageIds(<span class="literal">true</span>); <span class="comment">// 配置自动创建消息id</span></span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在接收方接收消息id</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(Message msg)</span> &#123; <span class="comment">// 使用字符串发送，就用字符串接收</span></span><br><span class="line">        log.info(<span class="string">&quot;监听到simple.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        log.info(<span class="string">&quot;消息id：&#123;&#125;&quot;</span>, msg.getMessageProperties().getMessageId());</span><br><span class="line">        <span class="comment">// throw new RuntimeException(&quot;故意的&quot;);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/ede2c8352f014e61a549afe6fa45d49f.png" alt="ede2c8352f014e61a549afe6fa45d49f.png"></p><h3 id="方案2-业务判断（常用）"><a href="#方案2-业务判断（常用）" class="headerlink" title="方案2. 业务判断（常用）"></a>方案2. 业务判断（常用）</h3><p>结合业务逻辑，基于业务本身做判断。<br>【<code>案例</code>】：当用户下单成功后，通过MQ通知交易服务来修改订单状态为已支付（这里记作<code>消息1</code>），修改成功后交易服务返回ACK给MQ，此时出现了网络的故障，MQ没有收到交易服务发送的ACK，MQ认为交易服务宕机，消息又重新入队。<br>就在此刻，用户点击了申请退款，直接向交易服务修改订单状态为退款中（这个操作没有走MQ，此时订单状态是退款中，但是消息1还在消息队列中）。<br>此时网络恢复了，MQ又将消息1发送给交易服务，此时交易服务又把订单状态标记为已支付（订单申请退款中的状态又被覆盖了）。<br><img src="/assets/6114b30ce9784387a6925375b1004202.png" alt="6114b30ce9784387a6925375b1004202.png"><br>【<code>解决</code>】：通知来的时候，先判断订单的状态，再进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayStatusListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;trade.pay.success.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;pay.direct&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;pay.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="comment">// 2.判断订单状态是否为未支付</span></span><br><span class="line">        <span class="keyword">if</span>(order == <span class="literal">null</span> || order.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 不做处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.标记订单状态为已支付</span></span><br><span class="line">        orderService.markOrderPaySuccess(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/25e9d5b300b04d0cb730cf1ae91a7af4.png" alt="25e9d5b300b04d0cb730cf1ae91a7af4.png"></p><h1 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h1><p>延迟消息：发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。<br>延迟任务：设置在一定时间后才执行的任务。<br><img src="/assets/f6713f02b3c349d096e499b1f02d077b.png" alt="f6713f02b3c349d096e499b1f02d077b.png"></p><h2 id="方案1-死信交换机"><a href="#方案1-死信交换机" class="headerlink" title="方案1. 死信交换机"></a>方案1. 死信交换机</h2><p>当一个队列中的消息满足下列情况之一的，就会成为<code>死信</code>：</p><ul><li>消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false。</li><li>消息是一个过期消息（达到队列设置的过期时间 或 消息本身设置的过期时间），超时无人消费。</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信。</li></ul><p>队列通过<strong>dead-letter-exchange</strong>属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中，这个交换机就叫做<code>死信交换机</code>（DLX）。<br><img src="/assets/280e34d1fd4943eab40b6d6b71398e4c.png" alt="280e34d1fd4943eab40b6d6b71398e4c.png"></p><ol><li>声明死信队列、死信交换机、它们之间的绑定关系：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;dlx.queue&quot;, durable = &quot;true&quot;), // 死信队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;dlx.direct&quot;, type = ExchangeTypes.DIRECT), // 死信交换机</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;hi&quot;&#125; </span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlxQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者监听到dlx.queue的消息: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明普通队列、普通交换机、它们之间的绑定关系，并把队列绑定到死信交换机上（此时就不需要把它绑定消费者了）：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123; <span class="comment">// 普通交换机</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;normal.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123; <span class="comment">// 普通队列</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;normal.direct&quot;</span>) <span class="comment">// 队列名字</span></span><br><span class="line">                .deadLetterExchange(<span class="string">&quot;dlx.direct&quot;</span>) <span class="comment">// 死信交换机名字</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">normalQueueBinding</span><span class="params">(Queue normalQueue, DirectExchange normalExchange)</span> &#123; <span class="comment">// 绑定关系</span></span><br><span class="line">        <span class="comment">// 把队列绑定到交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(normalQueue) <span class="comment">// 队列</span></span><br><span class="line">                .to(normalExchange) <span class="comment">// 交换机</span></span><br><span class="line">                .with(<span class="string">&quot;hi&quot;</span>);<span class="comment">// 这里绑定关系要和普通队列的绑定关系保持一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>发送延迟消息：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDelayMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;normal.direct&quot;</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;hello world&quot;</span>, message -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当消息被转成Message对象后，还可以进一步做加工</span></span><br><span class="line">        message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span>); <span class="comment">// 设置消息过期时间(10s)</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：<strong>normal.direct和normal.queue</strong>之间绑定的BindingKey 与 <strong>dlx.direct和dlx.queue</strong>之间绑定的BindingKey要一致</p></blockquote><h2 id="方案2-延迟消息插件DelayExchange（推荐）"><a href="#方案2-延迟消息插件DelayExchange（推荐）" class="headerlink" title="方案2. 延迟消息插件DelayExchange（推荐）"></a>方案2. 延迟消息插件DelayExchange（推荐）</h2><p>这个插件可以将普通交换机改造为支持延迟消息功能的交换机，当消息投递到交换机后，可以暂存一段时间，到后期再投递到队列。</p><h3 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h3><ol><li>插件下载地址：<a href="https://b11et3un53m.feishu.cn/wiki/A9SawKUxsikJ6dk3icacVWb4n3g#share-BinndxWXIorpaFxltoRclv6fnMG">DelayExchange</a></li><li>需要把插件放在RabbitMQ插件目录对应的数据卷下</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p><img src="/assets/571644c4a5004005bd5fceef602a40e9.png" alt="571644c4a5004005bd5fceef602a40e9.png"><br><img src="/assets/7d8aa7eb82744446b18d4a15f7a333b6.png" alt="7d8aa7eb82744446b18d4a15f7a333b6.png"></p><ol start="3"><li>执行命令，安装插件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it rabbitmq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h3 id="二、使用插件"><a href="#二、使用插件" class="headerlink" title="二、使用插件"></a>二、使用插件</h3><ol><li>声明延迟交换机：只要设置delay的属性为true即可</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;, type = ExchangeTypes.DIRECT), // 只要设置一个delayed属性为true即可</span></span><br><span class="line"><span class="meta">        key = &#123;&quot;hi&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者监听到delay.queue的消息: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>发送延迟消息：通过消息头x-delay来设置过期时间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDelayMsgByPlugin</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, <span class="string">&quot;hello world&quot;</span>, message -&gt; &#123;</span><br><span class="line">        message.getMessageProperties().setDelay(<span class="number">10000</span>);<span class="comment">// 添加延迟消息属性</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>延迟消息的实现需要记录消息的过期时间，计时的时钟需要依赖cpu，是个cpu密集型任务。因此使用延迟消息时，需要避免同一时刻在mq里存在大量的延迟消息（尽可能地让延迟消息的延迟时间不要太长）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息丢失 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/post/b543ced0.html"/>
      <url>/post/b543ced0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然多线程也能做异步处理，但是多线程仅限于在同一个进程做异步处理，会占用服务器的资源。<br>MQ是可以分布式的，可以分担服务器的压力。</p></blockquote><h1 id="同步调用和异步调用"><a href="#同步调用和异步调用" class="headerlink" title="同步调用和异步调用"></a>同步调用和异步调用</h1><h2 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h2><p>优势：时效性强，等待到结果后才返回<br>问题：拓展性差、性能差、级联失败问题</p><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><ul><li>消息发送者：投递消息的人（调用者）</li><li>消息接收者：接收和处理消息的人（服务提供者）</li><li>消息代理：管理、暂存、转发消息（微信服务器）<br><img src="/assets/7ac1576587c5453f95aaeaad8a28e8e2.png" alt="7ac1576587c5453f95aaeaad8a28e8e2.png"></li></ul><blockquote><p>扣减数据余额和更新支付状态必须采用同步调用。<br>更新订单状态、短信通知用户、增加用户积分，这三个业务其实和支付服务的关系不大，有点业务耦合，可以用异步调用，支付服务先发一条消息给消息代理，交易服务、通知服务、积分服务去监听消息代理。如果服务故障了，没有收到消息，只要这个服务重新启动，消息代理还会投递消息给这个服务。</p></blockquote><p>优势：解除耦合，拓展性好；无需等待；故障隔离；缓存消息，流量削峰填谷。<br>问题：不能立刻得到调用结果，时效性差；不能确定下游业务执行是否成功；业务安全依赖Broker的可靠性。</p><h2 id="MQ技术选型"><a href="#MQ技术选型" class="headerlink" title="MQ技术选型"></a>MQ技术选型</h2><p>MQ：消息队列，存放消息的队列。也就是异步调用的Broker<br><img src="/assets/7a3c7ee01adf459590df9d0ba9fca1a5.png" alt="7a3c7ee01adf459590df9d0ba9fca1a5.png"></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>创建并运行容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run  -d \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name rabbitmq \</span><br><span class="line"> --hostname rabbitmq \</span><br><span class="line">--restart=always \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hm-net \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><ol start="2"><li>创建容器成功后，即可查看rabbitmq控制台：<code>http://192.168.140.101:15672</code>，用户名、密码为admin</li></ol><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>virtual-host：虚拟主机，起到数据隔离的作用</li><li>publisher：消息发送者</li><li>consumer：消息的消费者</li><li>queue：队列，存储消息</li><li>exchange：交换机，负责路由消息<br><img src="/assets/4787873ed4ff4f8e8a866b25113b115e.png" alt="4787873ed4ff4f8e8a866b25113b115e.png"></li></ul><blockquote><p>交换机只能路由消息，无法存储消息<br>交换机只会路由消息给与其绑定的队列，因此队列必须与交换机绑定</p></blockquote><h1 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h1><h2 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h2><ol><li>引入spring-amqp依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置RabbitMQ服务端信息，让微服务连接到rabbitmq</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span> <span class="comment"># 虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><ol start="3"><li>【发送消息】：SpringAMQP提供了RabbitTemplate工具类，方便我们发送消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, msg); <span class="comment">// 发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>【接收消息】：只需要通过注解（<code>@RabbitListener</code>）在方法上声明要监听的队列名称，将来SpringAMQP就会把消息传递给当前方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123; <span class="comment">// 使用字符串发送，就用字符串接收</span></span><br><span class="line">        log.info(<span class="string">&quot;监听到simple.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p> work Queues：任务模型，让<code>多个消费者绑定到一个队列</code>，共同消费队列中的消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"><span class="comment">// 多个消费者绑定到同一个队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;consumer 1: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;consumer 2: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>实际开发只会写一个方法，但是在部署的时候会在不同服务器上部署多个实例，形成一个集群。<br>【<code>问题</code>】：默认是轮询投递给绑定在队列上的每一个消费者，但是这并没有考虑到消费者处理完消息，可能出现消息堆积的问题。<br>【<code>解决</code>】：修改application.yml，设置preFetch的值为1，确保同一时刻最多投递给消费者一条消息（性能好的服务器，处理的消息越多，能者多劳）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">listener:</span></span><br><span class="line"><span class="attr">simple:</span></span><br><span class="line"> <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h2><p>接收发送者发送的消息，并将消息路由到与其绑定的队列。<br><img src="/assets/19d6a91aad5646afa6e9fa613898128b.png" alt="19d6a91aad5646afa6e9fa613898128b.png"></p><h3 id="Fanout交换机（广播）"><a href="#Fanout交换机（广播）" class="headerlink" title="Fanout交换机（广播）"></a>Fanout交换机（广播）</h3><p>会将接收到的消息路由到每一个与其绑定的Queue。<br><img src="/assets/9f362598ed8b4902b945901ead3258e0.png" alt="9f362598ed8b4902b945901ead3258e0.png"></p><blockquote><p>【案例】：用户消费完毕，更新支付状态后，需要通知交易服务、短信服务、积分服务。如果没有交换机，通过队列发送，但是在队列里，一个消息只能被一个消费者处理。所以需要fanout交换机，把这个消息发送给所有的队列。</p></blockquote><p>发送消息到Fanout交换机的API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;<span class="comment">// 消息</span></span><br><span class="line">        <span class="comment">// 发送消息，参数分别为：交换机名，RoutingKey(暂时为空)，消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="literal">null</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：convertAndSend方法中两个参数默认是发给<code>队列</code>，三个参数是发给<code>交换机</code></p></blockquote><h3 id="Direct交换机（定向）"><a href="#Direct交换机（定向）" class="headerlink" title="Direct交换机（定向）"></a>Direct交换机（定向）</h3><p>会将接收到的消息根据<code>规则</code>（RoutingKey）路由到指定的Queue，规则如下：</p><ul><li>每一个Queue都与Exchange绑定时都需要设置一个BindingKey</li><li>发布者发布消息时，指定消息的RoutingKey</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列<br><img src="/assets/adcd87bd2a454998874466cddbd409e1.png" alt="adcd87bd2a454998874466cddbd409e1.png"></li></ul><blockquote><p>【注】：当两个队列的BindingKey相同时，Direct交换机就变成了Fanout交换机。<br>【场景】：用户消费完毕后，如果点了取消，交易服务需要把订单状态变成已取消，但是不需要通知短信服务、积分服务了。此时只需要发给交易服务即可。</p></blockquote><p>在rabbitMq控制台设置交换机和队列的绑定关系，并设置RoutingKey：<br><img src="/assets/229f3d34f2f445afb2be234ee6615af6.png" alt="229f3d34f2f445afb2be234ee6615af6.png"><br>发送消息到Direct交换机的API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;蓝色&quot;</span>;<span class="comment">// 消息</span></span><br><span class="line">        <span class="comment">// 发送消息，参数分别为：交换机名，RoutingKey(绑定关系)，消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, msg); <span class="comment">// 此时只有direct.queue1收到消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic交换机（话题）"><a href="#Topic交换机（话题）" class="headerlink" title="Topic交换机（话题）"></a>Topic交换机（话题）</h3><p>也是基于RoutingKey做消息路由，但时RoutingKey通常是多个单词的组合，并且以<code>.</code>分割。<br>Queue与Exchange指定的BindingKey可以使用通配符：</p><ul><li>#：代表0个或多个单词</li><li>*：代表一个单词<br><img src="/assets/18608ac9f3074897853eab96668b1491.png" alt="18608ac9f3074897853eab96668b1491.png"></li></ul><p>在rabbitMq控制台设置交换机和队列的绑定关系，并设置RoutingKey：<br><img src="/assets/65f0d098fb8d4ff2be093a4c6759f03a.png" alt="65f0d098fb8d4ff2be093a4c6759f03a.png"><br>发送消息到Topic交换机的API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopicxchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;有关中国的新闻&quot;</span>;<span class="comment">// 消息</span></span><br><span class="line">        <span class="comment">// 发送消息，参数分别为：交换机名，RoutingKey(绑定关系)，消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, msg); <span class="comment">// 此时topic.queue1和topic.queue4都能收到消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h2><ul><li>Queue：声明队列，可以用工厂类QueueBuilder创建</li><li>Exchange：声明交换机，可以用工厂类ExchangeBuilder创建</li><li>Binding：声明队列和交换机的绑定关系，可以用工厂类BindingBuilder创建</li></ul><h3 id="基于JavaBean的方式声明"><a href="#基于JavaBean的方式声明" class="headerlink" title="基于JavaBean的方式声明"></a>基于JavaBean的方式声明</h3><p>【案例】：声明一个Direct类型的交换机，并创建两个队列与其绑定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123; <span class="comment">// 交换机</span></span><br><span class="line">        <span class="comment">// return new directExchange(&quot;hmall.direct&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span> &#123; <span class="comment">// 队列1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span> &#123; <span class="comment">// 队列2</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;direct.queue2&quot;</span>) <span class="comment">// 队列持久化到磁盘</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">directQueue1Binding</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span> &#123; <span class="comment">// 绑定关系1</span></span><br><span class="line">        <span class="comment">// 把队列绑定到交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(directQueue1) <span class="comment">// 队列</span></span><br><span class="line">                .to(directExchange) <span class="comment">// 交换机</span></span><br><span class="line">                .with(<span class="string">&quot;blue&quot;</span>); <span class="comment">// 绑定关系（但是只能传一个key，如果需要绑定多个routingKey需要再写一个绑定关系）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">directQueue2Binding</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span> &#123; <span class="comment">// 绑定关系2</span></span><br><span class="line">        <span class="comment">// 把队列绑定到交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(directQueue2) <span class="comment">// 队列</span></span><br><span class="line">                .to(directExchange) <span class="comment">// 交换机</span></span><br><span class="line">                .with(<span class="string">&quot;yellow&quot;</span>); <span class="comment">// 绑定关系（但是只能传一个key）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于注解的方式声明"><a href="#基于注解的方式声明" class="headerlink" title="基于注解的方式声明"></a>基于注解的方式声明</h3><p>使用<code>@RabbitListener</code>注解来声明队列和交换机</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;direct.queue1&quot;, durable = &quot;true&quot;), // 队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT), // 交换机</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;red&quot;, &quot;blue&quot;&#125; // 绑定关系</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;consumer 1: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;direct.queue2&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;consumer 2: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><p>【场景】：向object.queue队列发送一个对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendObject</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaolin&quot;</span>);</span><br><span class="line">        msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制台上看到的是：<br><img src="/assets/5aad7ced954b4a119d1de1a78585dfab.png" alt="5aad7ced954b4a119d1de1a78585dfab.png"><br>【原因】：Spring对消息对象的处理是由MessageConverter来处理的，而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。<br>【这种方式存在的问题】：JDK的序列化有安全风险，JDK序列化的消息太大，JDK序列化的消息可读性太差<br>【解决】：建议采用JSON序列化代替默认的JDK序列化。</p><ol><li>在publisher和consumer中，引入jackson依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jackson消息转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在publisher和consumer中，配置MessageConverter</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(RabbitTemplate.class)</span> <span class="comment">// 有RabbitTemplate才生效</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/359d3cb0ff0f413f8fdf65a278ba6712.png" alt="359d3cb0ff0f413f8fdf65a278ba6712.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 同步异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关 + Nacos配置管理</title>
      <link href="/post/e0cedcb.html"/>
      <url>/post/e0cedcb.html</url>
      
        <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>网关：就是网络的关口，负责请求的路由、转发、身份校验。<br><img src="/assets/09f95626ddea400b8bacdab65fafb1d6.png" alt="09f95626ddea400b8bacdab65fafb1d6.png"></p><h2 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h2><ol><li>新建网关模块gateway</li><li>引入相关依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>写启动类</li><li>配置路由规则</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 前端请求的端口（网关的端口）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="comment"># 路由配置</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item-service</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由目标微服务，lb代表负载均衡协议</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断请求是否符合要求，符合则路由到目标</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,</span> <span class="string">/search/**</span> <span class="comment"># 以请求路径做判断，以/items或/search开头则符合</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/addresses/**,</span> <span class="string">/users/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br></pre></td></tr></table></figure><h2 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h2><p>网关路由对应的Java类型是RouteDefinition，常见的属性有：</p><ul><li>id：路由唯一标识</li><li>uri：路由目标地址</li><li>predicates：路由断言，判断请求是否符合当前路由</li><li>filters：路由过滤器，对请求或响应做特殊处理</li></ul><h3 id="predicates路由断言"><a href="#predicates路由断言" class="headerlink" title="predicates路由断言"></a>predicates路由断言</h3><p>文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.8/reference/html/#gateway-request-predicates-factories">predicates路由断言</a><br><img src="/assets/a06fc78dc06f4ad893c48b690b57ee9b.png" alt="a06fc78dc06f4ad893c48b690b57ee9b.png"></p><h3 id="filters路由过滤器"><a href="#filters路由过滤器" class="headerlink" title="filters路由过滤器"></a>filters路由过滤器</h3><p>文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.8/reference/html/#gatewayfilter-factories">filters路由过滤器</a><br><img src="/assets/818227d547a6437d99c043f307fe15b8.png" alt="818227d547a6437d99c043f307fe15b8.png"></p><h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><p>网关过滤器有两种：</p><ol><li>GatewayFilter：路由过滤器，作用于任意指定的路由，默认不生效，要陪知道路由后生效。</li><li>GlobalFilter（常用）：全局过滤器，作用范围是所有路由；声明后自动生效。<br><img src="/assets/de4bb87f30e944a78554a8dba6730a8b.png" alt="de4bb87f30e944a78554a8dba6730a8b.png"></li></ol><h3 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取请求</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> exchange.getRequest().getHeaders();</span><br><span class="line">        <span class="comment">// 过滤器业务处理（登录校验逻辑...）</span></span><br><span class="line">        <span class="keyword">if</span>(...) &#123;</span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange); <span class="comment">// 放行</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 控制过滤器执行顺序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 值越小，优先级越高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义的过滤器需要在NettyRoutingFilter【将请求转发到微服务】这个过滤器之前执行，所以需要再继承一个Ordered接口，来保证我们自定义的过滤器的优先级比NettyRoutingFilter高</p></blockquote><h2 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h2><p><img src="/assets/1a7472fcc3034feeb999d6699a88b4af.png" alt="1a7472fcc3034feeb999d6699a88b4af.png"></p><h3 id="网关传递用户"><a href="#网关传递用户" class="headerlink" title="网关传递用户"></a>网关传递用户</h3><p><img src="/assets/0fcac58bbf304ed0afa42dfc94e8320d.png" alt="0fcac58bbf304ed0afa42dfc94e8320d.png"></p><ol><li>在网关的登录校验过滤器中，从前端发送的请求头里拿到用户信息，并把用户信息放到请求头里，再发给微服务。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">swe</span> <span class="operator">=</span> exchange.mutate()</span><br><span class="line">                .request(builder -&gt; builder.header(<span class="string">&quot;user-info&quot;</span>, userInfo))</span><br><span class="line">                .build(); <span class="comment">// 传递的时候，需要传递这个返回的新的exchange</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在微服务中定义拦截器，保存网关发过来的用户信息到ThreadLocal里。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义拦截器</span></span><br><span class="line"><span class="comment">// 因为校验请求头这些操作已经在网关做过了，所以拦截器里边只需要把用户信息保存到ThreadLocal里即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否获取了用户信息</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            <span class="comment">// 存入上下文</span></span><br><span class="line">            UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 清理用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册拦截器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DispatcherServlet.class：springmvc的核心api</span></span><br><span class="line"><span class="comment"> * 防止网关【没有SpringMvc】也引用这个类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span> <span class="comment">// 条件注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于很多微服务，都需要获取用户信息，不可能在这么多微服务里都一个拦截器，太麻烦啦。所以就把拦截器的代码写在common公共模块。<br>【<code>问题</code>】：配置类想要生效，需要被Spring扫描包扫描到，但是现在mvc配置类是在common公共模块下，但是是其他微服务使用这个拦截器，无法扫描到这个配置类。<br>【<code>解决</code>】：利用SpringBoot自动装配的原理，将定义的配置类放在了META-INF下的spring.factories文件下，这样就能实现自动装</p></blockquote><h3 id="OpenFeign传递用户信息"><a href="#OpenFeign传递用户信息" class="headerlink" title="OpenFeign传递用户信息"></a>OpenFeign传递用户信息</h3><p><img src="/assets/6116a9309a3e42ea8b5ede7ca200c0b9.png" alt="6116a9309a3e42ea8b5ede7ca200c0b9.png"><br>【<code>分析</code>】：购物车服务中的请求，不是直接从网关发过来的，而是网关先发给交易服务，再由交易服务通过OpenFeign向购物车服务中发送请求【微服务之间的调用】。<br>【<code>解决</code>】：OpenFeign提供了一个拦截器接口，所有由OpenFeign发起的请求都会先调用拦截器处理请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line"><span class="comment">// 交易服务可以拿到用户信息，它向购物车发请求时，UserContext里会保存用户信息</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line"><span class="keyword">if</span> (userId != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 把用户信息放到请求头中</span></span><br><span class="line">template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString()); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：DefaultFeignConfig配置类想要生效，必须在<code>发起请求所在的服务</code>（交易服务）的启动类上添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><p>【<code>存在问题</code>】：</p><ol><li>微服务重复配置过多，维护成本高。</li><li>业务配置经常变动，每次修改都要重启服务</li><li>网关路由配置写死，如果变更都要重启网关<br><img src="/assets/3fe9b4ff6f6b407084bb0d74d8ee4ee5.png" alt="3fe9b4ff6f6b407084bb0d74d8ee4ee5.png"></li></ol><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><h3 id="1-添加共享配置"><a href="#1-添加共享配置" class="headerlink" title="1. 添加共享配置"></a>1. 添加共享配置</h3><p><img src="/assets/94b4df1cef85413fbe42a5be8e80a932.png" alt="94b4df1cef85413fbe42a5be8e80a932.png"></p><h3 id="2-拉取共享配置"><a href="#2-拉取共享配置" class="headerlink" title="2. 拉取共享配置"></a>2. 拉取共享配置</h3><p>基于NacosConfig拉取共享配置代替微服务的本地配置<br><img src="/assets/946301ba738e46fc9ad04a7fee35a511.png" alt="946301ba738e46fc9ad04a7fee35a511.png"></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.新建bootstrap.yaml文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 微服务的名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-jdbc.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-log.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-swagger.yaml</span></span><br></pre></td></tr></table></figure><p><img src="/assets/4a766faffbb94956a64d70f84bc562db.png" alt="4a766faffbb94956a64d70f84bc562db.png"></p><blockquote><p>先加载bootstrap配置文件，拉取nacos配置，再进行合并。</p></blockquote><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>当修改配置文件中的配置时，微服务<strong>无需重启</strong>即可使配置生效。<br>【<code>条件</code>】：</p><ol><li>nacos中要有一个与微服务名有关的配置文件。<br><img src="/assets/617202b295ac4f2ab1684dcb20ee19c1.png" alt="617202b295ac4f2ab1684dcb20ee19c1.png"></li><li>微服务中要以特定方式读取需要热更新的配置属性。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对应nacos中的配置：<br><img src="/assets/3bdd6371c4894edc9886796dd8e3016f.png" alt="3bdd6371c4894edc9886796dd8e3016f.png"></p></blockquote><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>要实现动态路由首先要将路由配置保存到nacos中，当nacos中路由配置变更时，推送最新配置到网关，更新网关中的路由信息。</p><ol><li>拉取配置并添加监听器</li><li>在<code>路由表里的内容变更</code>和<code>项目启动</code>时，更新路由表</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 保存旧的路由表</span></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// 在项目一启动的时候执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1. 项目启动，先拉取配置，并添加配置监听器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123; <span class="comment">// 定义线程池</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123; <span class="comment">// 配置变更时做的事</span></span><br><span class="line">                        <span class="comment">// 2. 监听到配置变更时，需要去更新路由表</span></span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 3. 第一次读取到配置，也需要更新路由表</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新路由表【利用RouteDefinitionWriter来更新路由表】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123; <span class="comment">// configInfo就是配置文件的内容</span></span><br><span class="line">        <span class="comment">// 1. 解析配置文件，转为RouteDefinition</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routes = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2. 更新路由表</span></span><br><span class="line">        <span class="comment">// 【删】删除旧的路由表</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空旧的路由表</span></span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="keyword">for</span> (RouteDefinition route : routes) &#123;</span><br><span class="line">            <span class="comment">// 【增】新增新的路由表</span></span><br><span class="line">            writer.save(Mono.just(route)).subscribe();</span><br><span class="line">            <span class="comment">// 记录路由id，便于下次更新时删除</span></span><br><span class="line">            routeIds.add(route.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在nacos中添加动态路由<br><img src="/assets/f8daa3c9a9f644c9a93bcca2e3a3a4c1.png" alt="f8daa3c9a9f644c9a93bcca2e3a3a4c1.png"></li></ol><blockquote><p>【注】：为了方便解析从nacos读取到的路由配置，推荐使用json格式的路由配置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> nacos </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel服务保护 + Seata分布式事务</title>
      <link href="/post/83df4a98.html"/>
      <url>/post/83df4a98.html</url>
      
        <content type="html"><![CDATA[<h1 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h1><p><img src="/assets/2cc9cca2bb6c4b8fba768d0a1e1a3374.png" alt="2cc9cca2bb6c4b8fba768d0a1e1a3374.png"><br>【<code>原因</code>】：</p><ol><li>微服务相互调用，服务提供者出现故障。</li><li>服务调用这没有做好异常处理，导致自身故障。</li><li>调用链中所有服务级联失败，导致整个集群故障。</li></ol><p>【<code>解决方案</code>】：<br>请求限流、线程隔离、服务熔断<br>【<code>服务保护技术</code>】：<br><img src="/assets/54aa0a3b19124b8d8e17aa6a80f7381d.png" alt="54aa0a3b19124b8d8e17aa6a80f7381d.png"></p><h1 id="Sentinel服务保护"><a href="#Sentinel服务保护" class="headerlink" title="Sentinel服务保护"></a>Sentinel服务保护</h1><p>官方文档：<a href="https://sentinelguard.io/zh-cn/docs/quick-start.html">Sentinel</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-使用docker部署sentinel"><a href="#1-使用docker部署sentinel" class="headerlink" title="1. 使用docker部署sentinel"></a>1. 使用docker部署sentinel</h3><p>创建并运行sentinel容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--net=host \</span><br><span class="line">--name sentinel \</span><br><span class="line">--restart=always \</span><br><span class="line">-e AUTH_USERNAME=admin \</span><br><span class="line">-e AUTH_PASSWORD=admin \</span><br><span class="line">bladex/sentinel-dashboard:1.8.6</span><br></pre></td></tr></table></figure><p>完成后在浏览器输入：<code>192.168.140.101:8858</code>，用户名admin，密码admin</p><h3 id="2-在微服务中连接sentinel控制台"><a href="#2-在微服务中连接sentinel控制台" class="headerlink" title="2.在微服务中连接sentinel控制台"></a>2.在微服务中连接sentinel控制台</h3><p>引入sentinel依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置控制台：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8858</span> <span class="comment"># sentinel的控制台地址</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><blockquote><p>Restful风格的API请求路径一般相同，会导致簇点资源名称重复。所以我们要修改配置，把<code>请求方式 + 请求路径</code>作为簇点资源名称</p></blockquote><h2 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h2><p>簇点链路就是单机调用链路，是一次请求进入服务后经过的每一个被Sentinel监控的资源链。默认Sentinel会监控SpringMVC的每一个Endpoint（Http接口）。限流、熔断等都是争对簇点链路中的资源设置的，资源名默认就是接口的请求路径。<br><img src="/assets/73c5da38241d45dc9ecb894066f1aafd.png" alt="73c5da38241d45dc9ecb894066f1aafd.png"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-请求限流"><a href="#1-请求限流" class="headerlink" title="1. 请求限流"></a>1. 请求限流</h3><p>限制访问微服务的请求的并发量，避免服务因流量激增而出现故障。<br><img src="/assets/7257b09894a64584991f2caa12ce5723.png" alt="7257b09894a64584991f2caa12ce5723.png"><br><img src="/assets/8e0ebcb4bc544398a62f2bc43cb3671e.png" alt="8e0ebcb4bc544398a62f2bc43cb3671e.png"><br>这个接口每秒钟只能处理6个请求，使用ApiFox进行测试，会有部分请求失败【失败返回状态码429】。<br><img src="/assets/8d05ad4b973d4911a59e0db815072b13.png" alt="8d05ad4b973d4911a59e0db815072b13.png"></p><h3 id="2-线程隔离"><a href="#2-线程隔离" class="headerlink" title="2. 线程隔离"></a>2. 线程隔离</h3><p>通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散。<br><img src="/assets/66f03b62c56a46b28426749b0bbfa7e5.png" alt="66f03b62c56a46b28426749b0bbfa7e5.png"><br>【<code>场景</code>】：假设有大量的查询购物车的请求，通过对查询购物车这个线程做线程隔离，可以保证购物车这个微服务的资源不会被耗尽，不会对修改购物车等其他业务造成影响。<br><img src="/assets/65421a69176f41f280895281be0cbaa0.png" alt="65421a69176f41f280895281be0cbaa0.png"><br><img src="/assets/dc7dfeb1f5f2434fbacab1b1188ac1e2.png" alt="dc7dfeb1f5f2434fbacab1b1188ac1e2.png"></p><blockquote><p>线程隔离和请求限流的区别：<br><strong>请求限流</strong>：控制接受请求的<code>速度</code>(每秒访问几次)<br><strong>线程隔离</strong>：控制最多能接收请求的<code>次数</code>(一次访问的线程数)<br>就算请求限流设置的再慢，如果线程卡住的话，不设置线程隔离，也会导致资源占用。</p></blockquote><h3 id="3-fallback"><a href="#3-fallback" class="headerlink" title="3. fallback"></a>3. fallback</h3><p><img src="/assets/919d0bc52c674d66b761d79030ed1ba0.png" alt="919d0bc52c674d66b761d79030ed1ba0.png"><br>一、 将FeignClient作为Sentinel的簇点资源：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启流量控制</span></span><br></pre></td></tr></table></figure><p>二、 为FeignClient添加Fallback：</p><ul><li>方法1：FallbackClass，无法对远程调用的异常做处理</li><li>方法2：<code>FallbackFactory</code>，可以对远程调用的异常做处理</li></ul><ol><li>自定义类，实现FallbackFactory，编写对某个FeignClient的fallback逻辑：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">    <span class="comment">// 编写失败的处理逻辑（失败后就会走里边的方法）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;查询商品失败，&quot;</span>+ cause);</span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;扣减商品库存失败，&quot;</span>+ cause);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将定义的FallbackFactory注册为一个Bean：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ItemClientFallbackFactory <span class="title function_">itemClientFallbackFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClientFallbackFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在ItemClient接口中使用FallbackFactory：<code>@FeignClient(value = &quot;item-service&quot;, fallbackFactory = ItemClientFallbackFactory.class)</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, fallbackFactory = ItemClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; items)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/dd48672f97c8470ba4eaccb7e55fa40f.png" alt="dd48672f97c8470ba4eaccb7e55fa40f.png"></p><h3 id="4-服务熔断"><a href="#4-服务熔断" class="headerlink" title="4. 服务熔断"></a>4. 服务熔断</h3><p>由<strong>断路器</strong>统计请求的异常比例或慢调用比例，如果超出阈值则会熔断该业务，则拦截改接口的请求。熔断期间，所有请求<code>快速失败</code>，全部走fallback逻辑。当服务恢复时，断路器会放行访问该服务的请求。<br><img src="/assets/6fb72065d9ab449da726f4d8475717a0.png" alt="6fb72065d9ab449da726f4d8475717a0.png"></p><h4 id="断路器工作原理："><a href="#断路器工作原理：" class="headerlink" title="断路器工作原理："></a>断路器工作原理：</h4><p><img src="/assets/f7b1a34e18ef4ed58cf252b6cc209674.png" alt="f7b1a34e18ef4ed58cf252b6cc209674.png"><br>默认情况：<code>Closed状态</code><br>如果失败的比例过高：就会进入<code>Open状态</code>【拦截一切请求，快速失败】<br>在<code>Open状态</code>下会尝试放行一次请求，进入<code>Half-Open状态</code>，如果仍然失败，再次返回Open状态；如果成功，回到<code>Closed状态</code>。</p><h4 id="配置熔断策略"><a href="#配置熔断策略" class="headerlink" title="配置熔断策略"></a>配置熔断策略</h4><p><img src="/assets/c8573593d04c4081a9fd34a3ed557f64.png" alt="c8573593d04c4081a9fd34a3ed557f64.png"><br><img src="/assets/41c3633ff01d4c7686feca76ccec84cb.png" alt="41c3633ff01d4c7686feca76ccec84cb.png"></p><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>如果一个业务需要多个服务合作完成，而且每个服务都有事务，多个事务必须同时成功或同时失败，这样的事务就是<code>分布式事务</code>。其中每一个服务的事务就是一个<code>分支事务</code>。整个业务称为<code>全局事务</code>。<br>【<code>场景</code>】：用户下单后，订单服务首先创建订单，随后调用购物车服务清理购物车，最后调用库存服务扣减商品的库存。如果在调用库存服务的时候商品库存为0，此时扣减库存失败，订单服务和购物车服务应该同时失败。<br><img src="/assets/099e39d670064e3b8e9ba752153342da.png" alt="099e39d670064e3b8e9ba752153342da.png"><br>【<code>出现问题的原因</code>】：各个分支服务不知道对方的情况<br>【<code>解决思路</code>】：让各个分支事务感受到对方的存在，让所有的微服务向事务协调者报告当前的状态。<br><img src="/assets/b8c06f583e3f4ee9909a011fab1f7986.png" alt="b8c06f583e3f4ee9909a011fab1f7986.png"></p><h1 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构</h1><ul><li>事务协调者（TC）：维护<code>全局和分支事务</code>的状态，协调全局事务提交或回滚。</li><li>事务管理器（TM）：定义<code>全局事务</code>的范围、开始全局事务、提交或回滚全局事务。</li><li>资源管理器（RM）：管理<code>分支事务</code>，与TC交谈以注册分支事务和报告分支事务的状态。<br><img src="/assets/b497bbfe12194c6d8a2cb7cf88b41a47.png" alt="b497bbfe12194c6d8a2cb7cf88b41a47.png"></li></ul><h2 id="1-部署TC服务"><a href="#1-部署TC服务" class="headerlink" title="1. 部署TC服务"></a>1. 部署TC服务</h2><ol><li>创建数据库，导入sql文件<br><img src="/assets/150a14f4bbfb468bbd8d53777f85df86.png" alt="150a14f4bbfb468bbd8d53777f85df86.png"></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `seata`;</span><br><span class="line">USE `seata`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `global_table`</span><br><span class="line">(</span><br><span class="line">    `xid`                       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `transaction_id`            <span class="type">BIGINT</span>,</span><br><span class="line">    `status`                    TINYINT      <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `application_id`            <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_service_group` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_name`          <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `timeout`                   <span class="type">INT</span>,</span><br><span class="line">    `begin_time`                <span class="type">BIGINT</span>,</span><br><span class="line">    `application_data`          <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`                DATETIME,</span><br><span class="line">    `gmt_modified`              DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`xid`),</span><br><span class="line">    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),</span><br><span class="line">    KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `branch_table`</span><br><span class="line">(</span><br><span class="line">    `branch_id`         <span class="type">BIGINT</span>       <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `xid`               <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `transaction_id`    <span class="type">BIGINT</span>,</span><br><span class="line">    `resource_group_id` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `resource_id`       <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `branch_type`       <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    `status`            TINYINT,</span><br><span class="line">    `client_id`         <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    `application_data`  <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`        DATETIME(<span class="number">6</span>),</span><br><span class="line">    `gmt_modified`      DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`branch_id`),</span><br><span class="line">    KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `lock_table`</span><br><span class="line">(</span><br><span class="line">    `row_key`        <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `xid`            <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">    `branch_id`      <span class="type">BIGINT</span>       <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `resource_id`    <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `table_name`     <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `pk`             <span class="type">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    `status`         TINYINT      <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0:locked ,1:rollbacking&#x27;</span>,</span><br><span class="line">    `gmt_create`     DATETIME,</span><br><span class="line">    `gmt_modified`   DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`row_key`),</span><br><span class="line">    KEY `idx_status` (`status`),</span><br><span class="line">    KEY `idx_branch_id` (`branch_id`),</span><br><span class="line">    KEY `idx_xid_and_branch_id` (`xid` , `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `distributed_lock`</span><br><span class="line">(</span><br><span class="line">    `lock_key`       <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `lock_value`     <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `expire`         <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="keyword">primary key</span> (`lock_key`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;AsyncCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryRollbacking&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;TxTimeoutCheck&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>准备配置文件<br><a href="https://download.csdn.net/download/qq_57882997/90244761?spm=1001.2014.3001.5503">seata运行时所需的配置文件</a><br>上传前先看看application.yml，里边可能有些配置需要改一下<br>把上边的配置文件丢到root根目录下<br><img src="/assets/35c04cad63ca46c48c78793dc560ba46.png" alt="35c04cad63ca46c48c78793dc560ba46.png"></li><li>docker部署<br>在&#x2F;root目录下执行以下命令，创建并允许seata容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name seata \</span><br><span class="line">-p 8099:8099 \</span><br><span class="line">-p 7099:7099 \</span><br><span class="line">-e SEATA_IP=192.168.140.101 \</span><br><span class="line">-v ./seata:/seata-server/resources \</span><br><span class="line">--privileged=true \</span><br><span class="line">--network hm-net \</span><br><span class="line">--restart=always \</span><br><span class="line">-d \</span><br><span class="line">seataio/seata-server:1.5.2</span><br></pre></td></tr></table></figure><ol start="4"><li>以上操作都完成后，在浏览器输入：<code>http://192.168.140.101:7099/</code>后即可登录seata控制台。（初始账号：admin、密码：admin）</li></ol><h2 id="2-微服务集成Seata"><a href="#2-微服务集成Seata" class="headerlink" title="2. 微服务集成Seata"></a>2. 微服务集成Seata</h2><ol><li>引入Seata依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置TC服务地址，让微服务找到TC服务地址<br><img src="/assets/71f62f42519b4caba2fca5bcaa9c7a40.png" alt="71f62f42519b4caba2fca5bcaa9c7a40.png"></li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为很多服务都需要实现分布式事务，所以可以把对于seata的配置抽取成一个共享配置写在nacos里。所以添加依赖的时候，检查一下是否有<code>bootstrap</code>和<code>nacos配置管理</code>的依赖。</p></blockquote><p>查看seata的日志文件，可以看到购物车服务、交易服务、商品服务已经全部和seata的TC服务建立连接。<br><img src="/assets/ade0cde731924dbeb93ce0272718895b.png" alt="ade0cde731924dbeb93ce0272718895b.png"></p><h2 id="3-Seata解决分布式事务问题"><a href="#3-Seata解决分布式事务问题" class="headerlink" title="3. Seata解决分布式事务问题"></a>3. Seata解决分布式事务问题</h2><h3 id="XA模式—强一致"><a href="#XA模式—强一致" class="headerlink" title="XA模式—强一致"></a>XA模式—强一致</h3><p><img src="/assets/89a4a66e8aac422c9f909bf4d6437f0f.png" alt="89a4a66e8aac422c9f909bf4d6437f0f.png"></p><ol><li>一阶段工作：</li></ol><ul><li>RM注册分支事务</li><li>RM执行分支事务sql<code>但不提交</code></li><li>RM报告执行状态到TC</li></ul><ol start="2"><li>二阶段工作：</li></ol><ul><li>TC检测各分支事务执行状态：<ul><li>如果都成功，通知所有RM<code>提交事务</code></li><li>如果有失败，通知所有RM<code>回滚事务</code></li></ul></li><li>RM接收到TC指令，提交或回滚事务</li></ul><blockquote><p>通过“等待”的方式，确保了全局事务的ACID特性。但是一阶段需要锁定数据库的资源，到二阶段才释放，性能差。</p></blockquote><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>修改（每个参与事务的微服务）application.yml文件，开启XA模式</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><ol start="2"><li>给发起全局事务的入口添加<code>@GlobalTransactional</code>注解<br><img src="/assets/40c708a8b87143399bacde7aa1b077dd.png" alt="40c708a8b87143399bacde7aa1b077dd.png"></li></ol><h3 id="AT模式（主推）—最终一致"><a href="#AT模式（主推）—最终一致" class="headerlink" title="AT模式（主推）—最终一致"></a>AT模式（主推）—最终一致</h3><p>AT模式弥补了XA模式中资源锁定周期过长的缺陷。<br><img src="/assets/984ee6e1df964b379ff0c9524daa0d63.png" alt="984ee6e1df964b379ff0c9524daa0d63.png"></p><ol><li>一阶段RM的工作：</li></ol><ul><li>注册分支事务</li><li>记录<code>undo-log</code>（数据快照）</li><li>执行业务sql<code>并提交</code></li><li>报告事务状态</li></ul><ol start="2"><li>二阶段提交时RM的工作：</li></ol><ul><li>删除undo-log即可</li></ul><ol start="3"><li>二阶段回滚时RM的工作：</li></ol><ul><li>根据undo-log恢复数据到更新前</li></ul><blockquote><p>AT模式相比于XA模式的优点在于：在一阶段不需要等待彼此执行，而是各自提交，这样资源就没有锁定，性能也会好。<br>但是如果二阶段需要进行回滚，在回滚之前，会出现数据短暂的不一致。<br>【<code>AT模式与XA模式的区别</code>】：</p><ol><li>XA模式一阶段不提交事务，锁定资源<br>  AT模式一阶段直接提交，不锁定资源</li><li>XA模式依赖数据库机制实现回滚<br>  AT模式利用数据快照实现回滚</li><li>XA模式强一致<br>  AT模型最终一致</li></ol></blockquote><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>创建数据表，导入用来记录数据快照的undo_log表<br>【<code>注</code>】：每个分支事务都需要有自己的undo_log表</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `undo_log`</span><br><span class="line">(</span><br><span class="line">    `branch_id`     <span class="type">BIGINT</span>       <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    `xid`           <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    `context`       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    `rollback_info` LONGBLOB     <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    `log_status`    <span class="type">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    `log_created`   DATETIME(<span class="number">6</span>)  <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    `log_modified`  DATETIME(<span class="number">6</span>)  <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span><span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改application.yml文件，将事务模式修改为AT模式</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span></span><br></pre></td></tr></table></figure><p><img src="/assets/b5011655c47246f49d5f0770c77002ba.png" alt="b5011655c47246f49d5f0770c77002ba.png"><br>数据快照（undo_log表）：<br><img src="/assets/09abfcb768a64fefa0d1397b8ce4e5f9.png" alt="09abfcb768a64fefa0d1397b8ce4e5f9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> sentinel </tag>
            
            <tag> 服务保护 </tag>
            
            <tag> seata </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos注册中心 + OpenFeign远程调用</title>
      <link href="/post/61626915.html"/>
      <url>/post/61626915.html</url>
      
        <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h2><p>服务提供者：暴露服务接口，供其他服务调用<br>服务调用者：调用别的服务提供的接口<br>注册中心：记录并监控微服务各实例状态，推送服务变更信息<br><img src="/assets/16c60d1c84d945988f8bcc8394929317.png" alt="16c60d1c84d945988f8bcc8394929317.png"></p><blockquote><ol><li><strong>服务提供者</strong>会在启动时注册自己的信息到<strong>注册中心</strong>，<strong>消费者</strong>可以从<strong>注册中心</strong>订阅和拉取服务信息</li><li><strong>服务提供者</strong>通过<strong>心跳机制</strong>向<strong>注册中心</strong>报告自己的健康状态，当心跳异常时，注册中心会将异常服务剔除，并通知订阅了该服务的<strong>消费者</strong>。</li><li><strong>消费者</strong>可以通过<strong>负载均衡算法</strong>，从多个实例中选择一个。</li></ol></blockquote><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><ol><li>先导入nacos表<br><img src="/assets/76b42e46dee24390b2ae2119c4591545.png" alt="76b42e46dee24390b2ae2119c4591545.png"></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导出 nacos 的数据库结构</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `nacos`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `nacos` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line">USE `nacos`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_aggr 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_aggr`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_aggr 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_aggr`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_beta 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_beta`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_beta 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_beta`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_tag 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_tag`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_tag 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_tag`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_tags_relation 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_tags_relation`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_tags_relation 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_tags_relation`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.group_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `group_capacity`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.group_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `group_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.his_config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `his_config_info`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.his_config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `his_config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.permissions 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `permissions`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `permissions` (</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.permissions 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `permissions`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.roles 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `roles`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `roles` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_user_role` (`username`,`role`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.roles 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `roles`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `roles` (`username`, `role`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_capacity`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_info`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.users 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `users`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `enabled` tinyint(<span class="number">1</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.users 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `users`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `users` (`username`, `password`, `enabled`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>把custom.env文件丢到服务器上。<br><img src="/assets/f3a559af7165417b9dd8707f1ad9b7d4.png" alt="f3a559af7165417b9dd8707f1ad9b7d4.png"></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PREFER_HOST_MODE=hostname</span><br><span class="line">MODE=standalone</span><br><span class="line">SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">MYSQL_SERVICE_HOST=192.168.140.101</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">MYSQL_SERVICE_PORT=3307</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=123</span><br><span class="line">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><ol start="3"><li>创建并启动nacos容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nacos \</span><br><span class="line">--env-file ./nacos/custom.env \</span><br><span class="line">--network hm-net \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">-p 9848:9848 \</span><br><span class="line">-p 9849:9849 \</span><br><span class="line">--restart=always \</span><br><span class="line">nacos/nacos-server:v2.1.0-slim</span><br></pre></td></tr></table></figure><blockquote><p>配置成功后，在浏览器里输入：<code>http://192.168.140.101:8848/nacos</code>，即可看到nacos操作界面。<br>用户名：nacos、密码：nacos</p><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2></blockquote><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p><strong>服务注册</strong>：<strong>服务提供者</strong>在启动时提交自己的信息到注册中心。</p><ol><li>引用nacos依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置nacos地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><p>如果服务提供者配置在两台服务器上（这里用不同端口来演示），直接启动后，注册中心就能看到这两个服务。<br><img src="/assets/3b0e281c97ee47d2bae1df707e0217cc.png" alt="3b0e281c97ee47d2bae1df707e0217cc.png"></p><blockquote><p>假如有一台服务器宕机了，注册中心会感知到这台服务器宕机，并将它从注册中心删除。</p></blockquote><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><strong>服务发现</strong>：<strong>服务调用者</strong>调用别的服务，需要去注册中心里拉取别的服务。</p><ol><li>引用nacos依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置nacos地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><ol start="3"><li>服务发现</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 根据服务名称，获取服务的实例列表</span></span><br><span class="line"> List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>); <span class="comment">// 实例列表</span></span><br><span class="line"> <span class="keyword">if</span>(CollUtils.isEmpty(instances))&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 2. 手写负载均衡，从实例列表中随机挑选一个实例</span></span><br><span class="line"> <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(<span class="number">0</span>, instances.size()));</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 3.使用RestTemplate发起远程调用（暂时先这样，实际上用的是OpenFeign）</span></span><br><span class="line"> ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">         instance.getUri()+ <span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">         HttpMethod.GET,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">         &#125;, <span class="comment">// 泛型的引用</span></span><br><span class="line">         Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line"> );</span><br><span class="line"> <span class="comment">// 解析响应</span></span><br><span class="line"> <span class="keyword">if</span>(!response.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;ItemDTO&gt; items = response.getBody();</span><br></pre></td></tr></table></figure><h1 id="OpenFeign远程调用"><a href="#OpenFeign远程调用" class="headerlink" title="OpenFeign远程调用"></a>OpenFeign远程调用</h1><p>声明式的http客户端，帮助我们优雅的实现http请求的发送。<br><strong>旧</strong>：使用RestTemplate发送http请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">        instance.getUri()+ <span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">        &#125;, <span class="comment">// 泛型的引用</span></span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br><span class="line">List&lt;ItemDTO&gt; items = response.getBody();</span><br></pre></td></tr></table></figure><p><strong>新</strong>：OpenFeign</p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启用OpenFeign功能：在启动类上加入@EnableFeignClients注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写FeignClient</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;)</span> <span class="comment">// 告诉OpenFeign，这个是一个客户端[OpenFeign就可以根据服务的名称去注册中心里拉取实例列表]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/items&quot;)</span> <span class="comment">// 请求方式、路径</span></span><br><span class="line">List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>; <span class="comment">// 请求参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用OpenFeign，实现远程调用</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(ids);</span><br></pre></td></tr></table></figure><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>OpenFeign底层发起http请求，依赖其他框架，这些框架可以自己配置，包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><blockquote><p>OpenFeign底层最终发送请求<strong>默认</strong>使用的是Client代理，每次都要重新创建连接，效率很低，所以需要<strong>连接池</strong>。</p></blockquote><h3 id="OpenFeign整合OKHttp"><a href="#OpenFeign整合OKHttp" class="headerlink" title="OpenFeign整合OKHttp"></a>OpenFeign整合OKHttp</h3><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>开启连接池功能</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><h2 id="最佳方案"><a href="#最佳方案" class="headerlink" title="最佳方案"></a>最佳方案</h2><p><strong>方法1.</strong><br><img src="/assets/b1cfbddd8b0a47278eeccaaff9e3ab99.png" alt="b1cfbddd8b0a47278eeccaaff9e3ab99.png"><br><strong>方法2.</strong><br><img src="/assets/b8232fab7d034370a8bdac8ba76df2cb.png" alt="b8232fab7d034370a8bdac8ba76df2cb.png"></p><blockquote><p>当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。<strong>报错</strong>：<br><img src="/assets/763530fca0f74f368c78c96b489b18fe.png" alt="763530fca0f74f368c78c96b489b18fe.png"><br><strong>解决办法</strong>：</p><ol><li>指定FeignClient所在包：<br><code>@EnableFeignClients(basePackages = &quot;com.hmall.api.clients&quot;)</code></li><li>指定FeignClient字节码：<br><code>@EnableFeignClients(clients = &#123;UserClient.class&#125;)</code></li></ol></blockquote><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>OpenFeign只会在FeignClient所在包的日志级别为DEBUG时，才会输出日志。<br><img src="/assets/0e3e0b6fa77b48e68a17a90b68726b9f.png" alt="0e3e0b6fa77b48e68a17a90b68726b9f.png"></p><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><ul><li>NONE（默认值）：不记录任何日志信息</li><li>BASIC：请求的方法 + URL + 响应状态码 + 执行时间</li><li>HEADERS：BASIC + 请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细（头信息、请求体、元数据）</li></ul><h3 id="定义日志级别"><a href="#定义日志级别" class="headerlink" title="定义日志级别"></a>定义日志级别</h3><ol><li>声明一个类型为Logger.Level的Bean，在其中定义日志级别：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>此时这个Bean并未生效</li></ol><ul><li>如果想配置某个FeignClient的日志级别，可以在@FeignClient注解中声明<br><code>@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</code></li><li>如果想要全局配置，让所有的FeignClient都按照这个日志级别配置，需要在@EnableFeignClients注解中声明<br><code>@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> nacos </tag>
            
            <tag> openFeign </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 远程调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构</title>
      <link href="/post/e8b36ae1.html"/>
      <url>/post/e8b36ae1.html</url>
      
        <content type="html"><![CDATA[<h1 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h1><p>将<strong>业务的所有功能</strong>集中在一个项目中开发，打包成一个包部署。<br><img src="/assets/6f344e10fbcb4c8e9385198a5c2ed481.png" alt="6f344e10fbcb4c8e9385198a5c2ed481.png"><br><strong>优点</strong>：架构简单、部署成本低。<br><strong>缺点</strong>：团队协作成本高、系统发布效率低、系统可用性差。</p><blockquote><p>由于tomcat资源有限，同一个时间可能的并发量不大，如果有一个线程有大量的请求访问，其他的线程也会收到影响。</p></blockquote><h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p>微服务架构是服务化思想指导下的一套最佳实践架构方案。<strong>服务化思想</strong>：把单体架构中的功能模块拆分为多个独立的项目。<br><img src="/assets/a45478ce92d8493f804f65d3cb61de66.png" alt="a45478ce92d8493f804f65d3cb61de66.png"></p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p>是最广泛的微服务框架。<br><img src="/assets/2c49976ed225467f96da6b5dbe4fe874.png" alt="2c49976ed225467f96da6b5dbe4fe874.png"></p><h1 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h1><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><ol><li>创业型项目：先采用单体项目快速开发，随着规模扩大，逐渐拆分。</li><li>确定的大型项目：资金充足，目标明确，可以直接选择微服务项目，避免后续拆分麻烦。</li></ol><blockquote><p>要做到：高内聚、低耦合。<br><strong>高内聚</strong>：每个微服务的职责单一，包含的业务关联度高、完整度高。<br><strong>低耦合</strong>：每个微服务的功能相对独立，尽量减少对其他服务的依赖。</p></blockquote><p>拆分方式：</p><ul><li><strong>横向拆分</strong>：抽取公共服务，提高复用性。</li><li><strong>纵向拆分</strong>：按照业务模块来拆分。</li></ul><h2 id="拆分服务"><a href="#拆分服务" class="headerlink" title="拆分服务"></a>拆分服务</h2><p>工程结构有两种：</p><ol><li>独立Project：一个Project下多个Project</li><li>Maven聚合：一个Project下多个module</li></ol><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>购物车服务里需要用到商品服务里的接口，但是此时是这两个服务已经拆分了，所以需要购物车服务向商品服务发送请求【类似于前端页面向后端发请求】<br><img src="/assets/f8d891fc93dc49b1b0a24c2fd22aad96.png" alt="f8d891fc93dc49b1b0a24c2fd22aad96.png"></p><h2 id="方法1-RestTemplate"><a href="#方法1-RestTemplate" class="headerlink" title="方法1.RestTemplate"></a>方法1.RestTemplate</h2><p><img src="/assets/70b364c3b28c4956b5a785039d30df34.png" alt="70b364c3b28c4956b5a785039d30df34.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单体服务：</span></span><br><span class="line"><span class="comment">// List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 微服务远程调用：</span></span><br><span class="line"><span class="comment">// 1. 利用restTemplate发起http请求，得到http响应</span></span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">         <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">         HttpMethod.GET,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">         &#125;, <span class="comment">// 泛型的引用</span></span><br><span class="line">         Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line"> );</span><br><span class="line"> <span class="comment">// 2.解析响应</span></span><br><span class="line"> <span class="keyword">if</span>(!response.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;ItemDTO&gt; items = response.getBody();</span><br></pre></td></tr></table></figure><blockquote><p><strong>存在的问题</strong>：服务的调用者，在写代码的时候，还不知道服务提供者的地址。例如：商品微服务那边部署在了多台服务器，写url时，就不知道怎么写了。<br><img src="/assets/2f37302c55054edb95b1d5380ac397e3.png" alt="2f37302c55054edb95b1d5380ac397e3.png"></p></blockquote><h2 id="方法2-注册中心"><a href="#方法2-注册中心" class="headerlink" title="方法2.注册中心"></a>方法2.注册中心</h2><p>通过注册中心进行服务治理，通过订阅服务和注册服务，实现服务之间的远程调用；再通过OpenFeign来发送http请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法2.使用nacos + openFeign</span></span><br><span class="line"><span class="comment">// 根据服务名称，获取服务的实例列表</span></span><br><span class="line"> List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>); <span class="comment">// 实例列表</span></span><br><span class="line"> <span class="keyword">if</span>(CollUtils.isEmpty(instances))&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br></pre></td></tr></table></figure><p>（详细操作看：<a href="https://blog.csdn.net/qq_57882997/article/details/144990202?spm=1001.2014.3001.5502">nacos注册中心 + OpenFeign远程调用</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/post/f5f9fa9b.html"/>
      <url>/post/f5f9fa9b.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><h2 id="1-卸载已有的Docker"><a href="#1-卸载已有的Docker" class="headerlink" title="1. 卸载已有的Docker"></a>1. 卸载已有的Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-selinux </span><br></pre></td></tr></table></figure><h2 id="2-配置yum源"><a href="#2-配置yum源" class="headerlink" title="2. 配置yum源"></a>2. 配置yum源</h2><ol><li>安装yum工具</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><ol start="2"><li>配置yum源</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="几个常见的错误"><a href="#几个常见的错误" class="headerlink" title="几个常见的错误"></a>几个常见的错误</h2><ol><li>报错<br><img src="/assets/34a3e7528a934f21825bf1f8a34323d8.png" alt="34a3e7528a934f21825bf1f8a34323d8.png"><br>去<code>/etc/yum.repos.d/</code>路径下的配置文件里，看看是否有中文注释，删了中文注释就行了</li><li>报错<br><img src="/assets/e1a02af7f0aa4453a937726202221c4c.png" alt="e1a02af7f0aa4453a937726202221c4c.png"><br>把<a href="https://gitcode.com/open-source-toolkit/10c42/?utm_source=tools_gitcode&index=bottom&type=card&">资源文件</a>放到指定的路径（<code>/opt/centos/repodata/</code>）下就行了</li><li>安装docker时报错：<br><img src="/assets/6611d9b24eb243cbb3d07b54e6264c6b.png" alt="6611d9b24eb243cbb3d07b54e6264c6b.png"><br><strong>解决办法</strong>：安装docker-ce-selinux</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><h2 id="4-启动和校验"><a href="#4-启动和校验" class="headerlink" title="4. 启动和校验"></a>4. 启动和校验</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 停止Docker</span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"># 设置开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 执行docker ps命令，如果不报错，说明安装启动成功</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="5-配置镜像加速"><a href="#5-配置镜像加速" class="headerlink" title="5. 配置镜像加速"></a>5. 配置镜像加速</h2><ol><li>打开<a href="https://www.aliyun.com/product/acr?spm=5176.28536895.nav-v2-dropdown-menu-0.d_main_2_0_2.6651586crapZkh">阿里云的容器镜像服务</a></li><li>点击管理控制台：<br><img src="/assets/e8410e441042494ab55665d37348a253.png" alt="e8410e441042494ab55665d37348a253.png"></li><li>按照步骤配置镜像加速器即可。<br><img src="/assets/2ae0900d88e241afa8e20eb46d605fe0.jpeg" alt="2ae0900d88e241afa8e20eb46d605fe0.jpeg"><br><img src="/assets/e2dda10e3182492b9bba6c80db438609.png" alt="e2dda10e3182492b9bba6c80db438609.png"><br><strong>原因</strong>：现在阿里云的镜像已经停用失效，导致网络无法访问。<br><strong>解决</strong>：可以修改配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://docker.1ms.run&quot;,</span><br><span class="line">        &quot;https://docker.1panel.live/&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新加载配置文件并重启docker：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h1><p>利用Docker安装应用时，Docker会自动搜索并下载<strong>镜像</strong>（<strong>image</strong>）。镜像包含了：应用本身、应用运行所需的环境、配置、系统函数库。Docker会在运行镜像时创建一个隔离环境，成为<strong>容器</strong>（<strong>container</strong>）<br><strong>镜像仓库</strong>：存储和管理镜像的平台。<br><strong>镜像帮助文档</strong>：<a href="https://hub.docker.com/">dockerHub</a></p><h1 id="部署Mysql"><a href="#部署Mysql" class="headerlink" title="部署Mysql"></a>部署Mysql</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  mysql:5.7.32</span><br></pre></td></tr></table></figure><ul><li>docker run：创建并运行一个容器</li><li>-d：让容器在后台运行</li><li>–name：给容器起名，必须唯一</li><li>-p：设置端口映射【宿主机 : 容器内】</li><li>-e：设置环境变量</li><li>–restart&#x3D;always：设置开机自启</li><li>mysql:5.7.32：指定运行的镜像名[镜像名]:[版本]（版本省略就默认是最新版）</li></ul><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><p><img src="/assets/b9244ef79a834c888e55732c87abae93.png" alt="b9244ef79a834c888e55732c87abae93.png"></p><blockquote><p><strong>docker run</strong>：创建并运行容器<br><strong>docker start</strong>：启动容器，但是不会创建容器<br><strong>docker exec -it 容器名 bash</strong>：进入容器内部</p></blockquote><h2 id="给docker-ps和docker-images命令取个别名"><a href="#给docker-ps和docker-images命令取个别名" class="headerlink" title="给docker ps和docker images命令取个别名"></a>给docker ps和docker images命令取个别名</h2><ol><li>进入.bashrc文件：<code>vim ~/.bashrc</code></li><li>起别名：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br><span class="line">alias dis=&#x27;docker images&#x27;</span><br></pre></td></tr></table></figure><ol start="3"><li>让修改的文件生效：<code>source ~/.bashrc</code></li></ol><h1 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h1><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>和<strong>宿主机目录</strong>之间映射的桥梁。(是个<strong>双向映射</strong>)<br><img src="/assets/80dca7e55e50465584a5bed7fd485c55.png" alt="80dca7e55e50465584a5bed7fd485c55.png"><br><img src="/assets/2b47c6a8ab464ab9bf2787b665d2a36d.png" alt="2b47c6a8ab464ab9bf2787b665d2a36d.png"></p><blockquote><ol><li>在执行docker run命令，使用<code>-v 数据卷:容器内目录</code>，可以完成数据卷的挂载。</li><li>当创建容器时，如果挂载了数据卷，且数据卷不存在，会自动创建数据卷。</li></ol></blockquote><h1 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h1><blockquote><ol><li>在执行docker run命令，使用<code>-v 本地目录:容器内目录</code>，可以完成本地目录的挂载。</li><li>本地目录必须以 &#x2F; 或 .&#x2F; 开头，如果直接以名称开头，会被识别成数据卷而非本地目录。</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3307:3306 \</span><br><span class="line">  -v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /root/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  -v /root/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  mysql:5.7.32</span><br></pre></td></tr></table></figure><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><p>镜像包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程实际上就是把上述文件打包的过程。</p><h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h2><p><img src="/assets/46fd11e845e64b2cae8325cb6b53118e.png" alt="46fd11e845e64b2cae8325cb6b53118e.png"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile就是一个文本文件，其中包含一个个的指令，用指令来说明要执行什么操作来构建镜像。<br><img src="/assets/6e0455e392ae441384b8361d201a7680.png" alt="6e0455e392ae441384b8361d201a7680.png"></p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t myImage:1.0 .</span><br></pre></td></tr></table></figure><ul><li>-t：给镜像起名，格式：[镜像名]:[版本]（不指定版本默认为latest）</li><li>. ：指定Dockerfile所在目录，如果在当前目录就指定为“.”</li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>默认情况下，所有容器都是以bridge方式连接到Docker的一个虚拟网桥上。<br><img src="/assets/7602a42ae6804609bdfa2436d6f2d9ce.png" alt="7602a42ae6804609bdfa2436d6f2d9ce.png"></p><h2 id="Docker的网络操作命令"><a href="#Docker的网络操作命令" class="headerlink" title="Docker的网络操作命令"></a>Docker的网络操作命令</h2><p>加入自定义网络的容器才可以通过容器名互相访问。<br><img src="/assets/d01da4c991094d4b8f93ccfab81d5b03.png" alt="d01da4c991094d4b8f93ccfab81d5b03.png"></p><blockquote><p>把容器加入网络的两种方式：<br>先创建容器，再把容器加入网桥：<code>docker network connect 网络名 容器名</code><br>创建容器的同时把容器加入网桥：<code>docker run -d .... --network 网络名 ...</code></p></blockquote><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h2><ol><li>打包项目<br><img src="/assets/815202303137461c8e76def8f5579d1c.png" alt="815202303137461c8e76def8f5579d1c.png"></li><li>把打包好的<code>jar包</code>和<code>Dockerfile文件</code>一起丢到服务器上<br><img src="/assets/af5776419de44941aab52b5256069fa8.png" alt="af5776419de44941aab52b5256069fa8.png"></li><li>切换到&#x2F;root&#x2F;hm目录下，构建自定义镜像hm-java：<code>docker build -t hm-java:1.0 .</code><br><img src="/assets/87c818023be948d3b074c189292c8d8c.png" alt="87c818023be948d3b074c189292c8d8c.png"></li><li>创建并运行容器，同时把容器加入网桥：<code>docker run -d --name hm-java -p 8080:8080 --network lsh hm-java:1.0</code><br><img src="/assets/ec70f4a7666e4af3a3fec5e6cf8c877a.png" alt="ec70f4a7666e4af3a3fec5e6cf8c877a.png"></li></ol><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><ol><li>准备好<code>静态资源</code>和<code>配置文件</code><br><img src="/assets/d7380915e3224e3090d4e97bced881bd.png" alt="d7380915e3224e3090d4e97bced881bd.png"></li><li>创建容器并挂载</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nginx \</span><br><span class="line">-p 18080:18080 \</span><br><span class="line">-p 18081:18081 \</span><br><span class="line">-v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--network lsh \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>通过一个独立的<strong>docker-compose.yml</strong>模板文件（yaml格式）来定义一组相关联的应用容器，帮助我们实现多个关联的Docker容器的快速部署。<br><img src="/assets/d8c05b0d94c9419f8f1f6eeb80ee7726.png" alt="d8c05b0d94c9419f8f1f6eeb80ee7726.png"><br><img src="/assets/e158bb3d266d49e6ac949769a14fd4d5.png" alt="e158bb3d266d49e6ac949769a14fd4d5.png"><br><code>docker-compose.yml</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: mysql</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3306:3306&quot;</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;./mysql/conf:/etc/mysql/conf.d&quot;</span><br><span class="line">      - &quot;./mysql/data:/var/lib/mysql&quot;</span><br><span class="line">      - &quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">  hmall:</span><br><span class="line">    build: </span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    container_name: hmall</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: nginx</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;18080:18080&quot;</span><br><span class="line">      - &quot;18081:18081&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span><br><span class="line">      - &quot;./nginx/html:/usr/share/nginx/html&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - hmall</span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">networks:</span><br><span class="line">  hm-net:</span><br><span class="line">    name: hmall</span><br></pre></td></tr></table></figure><p>docker compose的命令格式：<br><img src="/assets/802e0738aabe48518c52f5ed8d674d65.png" alt="802e0738aabe48518c52f5ed8d674d65.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-Stream流</title>
      <link href="/post/50c7718b.html"/>
      <url>/post/50c7718b.html</url>
      
        <content type="html"><![CDATA[<p>stream流相当于一个流水线，一共可以分成三大类的方法。</p><ol><li>获取stream流</li><li>中间方法</li><li>终结方法（可以得到一个返回结果的）</li></ol><hr><h1 id="获取stream流"><a href="#获取stream流" class="headerlink" title="获取stream流"></a>获取stream流</h1><h2 id="单列集合获取Stream流"><a href="#单列集合获取Stream流" class="headerlink" title="单列集合获取Stream流"></a>单列集合获取Stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="comment">// 单列集合获取stream流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>);</span><br><span class="line">        <span class="comment">/*Stream&lt;String&gt; stream = list.stream(); // 获取到一条流水线，并把集合中的数据放到流水线上</span></span><br><span class="line"><span class="comment">        stream.forEach((x)-&gt; System.out.println(x));*/</span></span><br><span class="line">        list.stream().forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双列集合获取stream流"><a href="#双列集合获取stream流" class="headerlink" title="双列集合获取stream流"></a>双列集合获取stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;d&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 双列集合获取stream流</span></span><br><span class="line">        map.keySet().stream().forEach(x -&gt; System.out.println(x));</span><br><span class="line">        map.entrySet().stream().forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组获取stream流"><a href="#数组获取stream流" class="headerlink" title="数组获取stream流"></a>数组获取stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.stream(arr).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一堆零散的数据"><a href="#一堆零散的数据" class="headerlink" title="一堆零散的数据"></a>一堆零散的数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>流只能用一次，就算保存了流对象，后边也无法使用了。</p></blockquote><h1 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h1><h2 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(x -&gt; x.startsWith(<span class="string">&quot;张&quot;</span>)) <span class="comment">// 过滤姓名张开头的</span></span><br><span class="line">                .filter(x -&gt; x.length() == <span class="number">3</span>) <span class="comment">// 过滤长度为3的</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="skip跳过前n个"><a href="#skip跳过前n个" class="headerlink" title="skip跳过前n个"></a>skip跳过前n个</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .limit(<span class="number">2</span>) <span class="comment">// 获取前两[个]</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .skip(<span class="number">2</span>) <span class="comment">// 跳过前两个</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .skip(<span class="number">3</span>)</span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="distinct去除集合中重复的元素"><a href="#distinct去除集合中重复的元素" class="headerlink" title="distinct去除集合中重复的元素"></a>distinct去除集合中重复的元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .distinct() <span class="comment">// 去重</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concat连接两个集合"><a href="#concat连接两个集合" class="headerlink" title="concat连接两个集合"></a>concat连接两个集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list1, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list2, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span> , <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        Stream.concat(list1.stream(), list2.stream()) <span class="comment">// 连接两个集合</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map类型转换"><a href="#map类型转换" class="headerlink" title="map类型转换"></a>map类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌-1&quot;</span>, <span class="string">&quot;周芷若-2&quot;</span>, <span class="string">&quot;赵敏-3&quot;</span>, <span class="string">&quot;张三丰-4&quot;</span>, <span class="string">&quot;张翠山-5&quot;</span>, <span class="string">&quot;张良-6&quot;</span>, <span class="string">&quot;王二麻子-7&quot;</span>, <span class="string">&quot;谢广坤-8&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .map(x -&gt; &#123; <span class="comment">// map方法执行完后，流上的数据就变成了整数</span></span><br><span class="line">                        String[] arr = x.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">                    &#125;)</span><br><span class="line">                .forEach(x -&gt; System.out.println(x)); <span class="comment">// 打印的是整数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flatMap将流中每个元素转成另一个流"><a href="#flatMap将流中每个元素转成另一个流" class="headerlink" title="flatMap将流中每个元素转成另一个流"></a>flatMap将流中每个元素转成另一个流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; familyNameList = Arrays.asList(<span class="string">&quot;赵&quot;</span>, <span class="string">&quot;钱&quot;</span>, <span class="string">&quot;孙&quot;</span>, <span class="string">&quot;李&quot;</span>);</span><br><span class="line">        List&lt;String&gt; boyNameList = Arrays.asList(<span class="string">&quot;男&quot;</span>, <span class="string">&quot;子&quot;</span>, <span class="string">&quot;孩&quot;</span>);</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; cartesianProductList = familyNameList.stream()</span><br><span class="line">                .flatMap(familyName -&gt; boyNameList.stream() <span class="comment">// 将流中每个元素转换成另一个流</span></span><br><span class="line">                                        .map(boyName -&gt; familyName + boyName))</span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h1><h2 id="forEach遍历集合"><a href="#forEach遍历集合" class="headerlink" title="forEach遍历集合"></a>forEach遍历集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream().forEach(x-&gt;System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="count计算集合中的元素"><a href="#count计算集合中的元素" class="headerlink" title="count计算集合中的元素"></a>count计算集合中的元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray收集流中的数据放到数组中"><a href="#toArray收集流中的数据放到数组中" class="headerlink" title="toArray收集流中的数据放到数组中"></a>toArray收集流中的数据放到数组中</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="comment">// 收集流中的数据，放到数组中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        Object[] arr1 = list.stream().toArray();</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        String[] arr2 = list.stream().toArray(n -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[n]);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="collect收集流中的数据，放到集合中（List、Set、Map）"><a href="#collect收集流中的数据，放到集合中（List、Set、Map）" class="headerlink" title="collect收集流中的数据，放到集合中（List、Set、Map）"></a>collect收集流中的数据，放到集合中（List、Set、Map）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="comment">// 收集流中的数据，放到集合中（List、Set、Map）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌-男-15&quot;</span>, <span class="string">&quot;周芷若-女-14&quot;</span>, <span class="string">&quot;赵敏-女-14&quot;</span>, <span class="string">&quot;张三丰-男-100&quot;</span>, <span class="string">&quot;张翠山-男-40&quot;</span>, <span class="string">&quot;张良-男-35&quot;</span>, <span class="string">&quot;王二麻子-男-37&quot;</span>, <span class="string">&quot;谢广坤-男-41&quot;</span>);</span><br><span class="line">        <span class="comment">// 收集所有的男性到List集合中</span></span><br><span class="line">        List&lt;String&gt; list1 = list.stream()</span><br><span class="line">                .filter(x -&gt; <span class="string">&quot;男&quot;</span>.equals(x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>])) <span class="comment">// 过滤所有男性</span></span><br><span class="line">                .collect(Collectors.toList());<span class="comment">// 创建一个ArrayList集合</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收集所有的男性到Set集合中</span></span><br><span class="line">        Set&lt;String&gt; set1 = list.stream()</span><br><span class="line">                .filter(x -&gt; <span class="string">&quot;男&quot;</span>.equals(x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>])) <span class="comment">// 过滤所有男性</span></span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集Map集合(键不能重复，否则代码报错)</span></span><br><span class="line">        <span class="comment">// Key：姓名、Value：年龄</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * toMap(键的规则，值的规则)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMap&lt;String, String&gt; mp1 = list.stream()</span><br><span class="line">                .filter(x -&gt; <span class="string">&quot;男&quot;</span>.equals(x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>])) <span class="comment">// 过滤所有男性</span></span><br><span class="line">                .collect(Collectors.toMap(x -&gt; x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>], <span class="comment">// 键的规则</span></span><br><span class="line">                        x -&gt; x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]));<span class="comment">// 值的规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> stream </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-Thread</title>
      <link href="/post/d89ccce6.html"/>
      <url>/post/d89ccce6.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义多线程的三种方式"><a href="#定义多线程的三种方式" class="headerlink" title="定义多线程的三种方式"></a>定义多线程的三种方式</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个类继承自Thread</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 2.重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;run()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3.创建对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口的方式"><a href="#实现Runnable接口的方式" class="headerlink" title="实现Runnable接口的方式"></a>实现Runnable接口的方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个类实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2.重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前线程对象</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;run()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3.创建对象(表示多线程要执行的任务)</span></span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">mr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">mr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">        <span class="comment">// 4.创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr2);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用Callable接口和Future接口-可以获取多线程的结果"><a href="#利用Callable接口和Future接口-可以获取多线程的结果" class="headerlink" title="利用Callable接口和Future接口[可以获取多线程的结果]"></a>利用Callable接口和Future接口[可以获取多线程的结果]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个MyCallable类实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123; <span class="comment">// Callable的泛型表示这个线程返回的结果</span></span><br><span class="line">    <span class="comment">//2.重写call方法，返回值表示多线程运行结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 3.创建MyCallable对象【表示多线程要执行的任务】</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">// 4.创建FutureTask对象【管理多线程运行的结果】</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">        <span class="comment">// 5.创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        <span class="comment">// 6.启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 获取线程的返回结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见的成员方法"><a href="#常见的成员方法" class="headerlink" title="常见的成员方法"></a>常见的成员方法</h1><p><img src="/assets/dd9adb91be924e9883e65f30ed8b321a.png" alt="dd9adb91be924e9883e65f30ed8b321a.png"></p><p>setPriority(int newPriority)【设置线程的优先级】 和 final int getPriority()【获取线程的优先级】</p><ul><li>优先级不是绝对的，只是表示线程有很大的概率能抢到CPU</li></ul><p>final void setDaemon(boolean on)：设置为守护线程</p><ul><li>当其他非守护线程结束了，守护线程也会陆续结束</li><li>应用场景：线程1（聊天）、线程2（传输文件-守护线程）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            System.out.println(getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">        t2.setDaemon(<span class="literal">true</span>); <span class="comment">// 设置为守护线程</span></span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;非守护线程&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;守护线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的生命周期【5种】"><a href="#线程的生命周期【5种】" class="headerlink" title="线程的生命周期【5种】"></a>线程的生命周期【5种】</h1><p><img src="/assets/82b504e93c09411da619543c59ef03e9.png" alt="82b504e93c09411da619543c59ef03e9.png"></p><h1 id="线程安全的问题"><a href="#线程安全的问题" class="headerlink" title="线程安全的问题"></a>线程安全的问题</h1><p>线程在执行的时候会有随机性，CPU的执行权随时有可能被其他线程抢走</p><p>买票问题：三个窗口同时卖100张票</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                ++ticket;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步代码块：把操作共享数据的代码锁起来"><a href="#同步代码块：把操作共享数据的代码锁起来" class="headerlink" title="同步代码块：把操作共享数据的代码锁起来"></a>同步代码块：把操作共享数据的代码锁起来</h2><ul><li>锁默认打开，有一个线程进去，锁自动关闭</li><li>里面的代码全部执行完毕，线程出来，锁自动打开</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁) &#123;</span><br><span class="line">    操作共享数据的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>更新上边买票代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 锁对象一定要是唯一的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 锁对象一般可以写成【当前类的字节码文件对象MyThraed.class】</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++ticket;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p> 把synchronized关键字加到方法上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>同步方法是锁住方法里面的所有代码</li><li>锁对象不能自己指定 <ul><li>非静态：this</li><li>静态：当前类的字节码文件对象</li></ul></li></ul><p>更新上边买票代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 如果是继承Runnable接口的方式定义的线程，不需要加static，因为只会定义一个MyRunnable对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            ++ticket;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>void lock()：获得锁</p><p>void unlock()：释放锁</p><blockquote><p>Lock是接口，不能直接实例化，需要采用他的实现类ReentrantLock来实例化</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 因为使用继承Thread的方式，所以ticket和lock都会创建多次，要保证只会创建一次，就要加上static关键字</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    ++ticket;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁【如果不写在finally里，达到100张票后，其中一个线程会经过break跳出循环，就无法释放锁，程序无法停止】</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是一个错误，在写锁的时候，不要让两个锁嵌套写</p><p><img src="/assets/37439290d8b94a73be88e05f4b13c3d3.png" alt="37439290d8b94a73be88e05f4b13c3d3.png"></p><h1 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h1><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p><img src="/assets/4c3d2285c11c45aaaea14e7902cdc8c7.png" alt="4c3d2285c11c45aaaea14e7902cdc8c7.png"></p><p>场景：有一个桌子（Desk）、厨师（Cook）、吃货（Foodie）；要求厨师做一碗，吃货吃一碗。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【厨师】：生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Desk.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断桌子上是否有食物</span></span><br><span class="line">                    <span class="keyword">if</span>(Desk.foodFlag == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有-等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 有-制作食物，修改食物状态、叫醒消费者</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;厨师正在做&quot;</span>);</span><br><span class="line">                        Desk.foodFlag = <span class="number">1</span>;</span><br><span class="line">                        Desk.lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【吃货】：消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断桌子上是否有面条</span></span><br><span class="line">                    <span class="keyword">if</span>(Desk.foodFlag == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有 - 等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();<span class="comment">// 要用锁对象调用wait方法，让当前线程和锁进行绑定</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 有 - 开吃、唤醒厨师、总数-1、更改桌子的状态</span></span><br><span class="line">                        Desk.count--;</span><br><span class="line">                        System.out.println(<span class="string">&quot;吃货正在吃，还能吃：&quot;</span>+ Desk.count);</span><br><span class="line">                        Desk.lock.notifyAll();<span class="comment">// 唤醒绑定在这把锁上的所有线程</span></span><br><span class="line">                        Desk.foodFlag = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【桌子】：控制生产者和消费者的执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="comment">// 桌子上是否有食物 0-没有食物、1-有食物</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">foodFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cook</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>();</span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>();</span><br><span class="line">        cook.setName(<span class="string">&quot;厨师&quot;</span>);</span><br><span class="line">        foodie.setName(<span class="string">&quot;吃货&quot;</span>);</span><br><span class="line">        cook.start();</span><br><span class="line">        foodie.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="利用阻塞队列方式实现"><a href="#利用阻塞队列方式实现" class="headerlink" title="利用阻塞队列方式实现"></a>利用阻塞队列方式实现</h2><p>阻塞队列：连接生产者和消费者之间的管道。</p><ul><li>put数据：放不进去，会等着，叫做阻塞</li><li>take数据：取出第一个数据，取不到会等着，也叫阻塞</li></ul><blockquote><p>写的时候可以不用加锁，put()和take()底层就已经有锁了</p></blockquote><h3 id="阻塞队列的继承结构"><a href="#阻塞队列的继承结构" class="headerlink" title="阻塞队列的继承结构"></a>阻塞队列的继承结构</h3><p><img src="/assets/92fe5595b5f24ca3b41d6462ac3b58a4.png" alt="92fe5595b5f24ca3b41d6462ac3b58a4.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【厨师】：生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(ArrayBlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 不断地把面条放入阻塞队列中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;面条&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;厨师放了一碗面条&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【吃货】：消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(ArrayBlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 不断地从阻塞队列中获取面条</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">food</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建阻塞队列</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建线程的对象，并把阻塞队列传过去</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(queue);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(queue);</span><br><span class="line">        cook.setName(<span class="string">&quot;厨师&quot;</span>);</span><br><span class="line">        foodie.setName(<span class="string">&quot;吃货&quot;</span>);</span><br><span class="line">        cook.start();</span><br><span class="line">        foodie.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="线程的状态【7种】"><a href="#线程的状态【7种】" class="headerlink" title="线程的状态【7种】"></a>线程的状态【7种】</h1><p><img src="/assets/2ac906960b66471d8a04b7b4c0e2bcef.png" alt="2ac906960b66471d8a04b7b4c0e2bcef.png"></p><blockquote><p>注：在Java虚拟机种只有六种状态，没有运行状态，因为线程抢到CPU的执行权进入运行状态，虚拟机就会把当前线程交给操作系统管理</p></blockquote><p><img src="/assets/438d5dbcea4c4f58926a6a50ae6f0f02.png" alt="438d5dbcea4c4f58926a6a50ae6f0f02.png"></p><h1 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h1><p><img src="/assets/6b7fe42977f5476ea43d715e2b857282.png" alt="6b7fe42977f5476ea43d715e2b857282.png"></p><blockquote><p>线程1和线程2的run()方法里的存储空间是相互独立的。</p></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ol><li><strong>创建一个池子</strong>，池子是空的</li><li><strong>提交任务</strong>，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接服用已有的线程即可。</li><li>如果提交任务时，池子里没有空闲的线程，也无法创建新的线程，任务就会排队等待。</li></ol><p>Executors：线程池的工具类，通过调用方法返回不同类型的线程池对象</p><p><img src="/assets/4de2b6aa401f4fff96e320e3d4885980.png" alt="4de2b6aa401f4fff96e320e3d4885980.png"></p><h2 id="创建没有上限的线程池"><a href="#创建没有上限的线程池" class="headerlink" title="创建没有上限的线程池"></a>创建没有上限的线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        <span class="comment">// 销毁线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>线程是可以复用的，代码中让提交任务后，让main线程睡1秒中，此时上一个线程执行完毕，就会把线程重新放入线程池中</p></blockquote><h2 id="创建有上限的线程池"><a href="#创建有上限的线程池" class="headerlink" title="创建有上限的线程池"></a>创建有上限的线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        <span class="comment">// 销毁线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>上边的代码相当于是3个线程在执行5个任务。因为创建了多个线程，所以当代码一步一步往下走的时候，上一步可能是还没执行完的。所以运行到第四个提交任务的时候，就会有一个任务在排队了，到第五个提交任务，就有两个任务在排队。</p></blockquote><p>线程池多大合适？</p><p><img src="/assets/62bf226445104081a2cff5e196bce135.png" alt="62bf226445104081a2cff5e196bce135.png"></p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p><img src="/assets/110193df8ff741deaf86cff67b7a3b43.png" alt="110193df8ff741deaf86cff67b7a3b43.png"></p><p><img src="/assets/71e1aa7b657c428d946b3cf61cf8a39c.png" alt="71e1aa7b657c428d946b3cf61cf8a39c.png"></p><p><img src="/assets/a7a1272ec0724c1db98149da1afc6ce3.png" alt="a7a1272ec0724c1db98149da1afc6ce3.png"></p><blockquote><p><strong>核心线程</strong>都在处理任务，队伍中也已经排满了，此时才会创建<strong>临时线程</strong>去处理任务。</p><p>任务的执行不会按照提交的顺序去执行。</p></blockquote><p><img src="/assets/9b88ce4525dc49578d6921b95e2d81e1.png" alt="9b88ce4525dc49578d6921b95e2d81e1.png"></p><blockquote><p>核心线程和临时线程都在工作，队伍中也排满了，此时线程池就会触发<strong>任务拒绝策略</strong>。</p></blockquote><h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><p><img src="/assets/166fdb7e0c654fcb956a927b8be1a833.png" alt="166fdb7e0c654fcb956a927b8be1a833.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/assets/1df5bad3e7984d07a11a58beb0b75dd3.png" alt="1df5bad3e7984d07a11a58beb0b75dd3.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// 核心线程数量</span></span><br><span class="line">                <span class="number">6</span>,<span class="comment">// 最大线程数量</span></span><br><span class="line">                <span class="number">60</span>,<span class="comment">// 空闲线程最大存活时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">// 任务队列</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 创建线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 任务的拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 同步异步 </tag>
            
            <tag> javase </tag>
            
            <tag> 多线程 </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-不可变集合</title>
      <link href="/post/9e7d9a7f.html"/>
      <url>/post/9e7d9a7f.html</url>
      
        <content type="html"><![CDATA[<p>JDK9以后才有不可变集合</p><hr><h1 id="创建不可变集合的应用场景"><a href="#创建不可变集合的应用场景" class="headerlink" title="创建不可变集合的应用场景"></a>创建不可变集合的应用场景</h1><ol><li>如果某个数据不能被修改，可以把他拷贝到不可变集合。</li><li>当集合对象被不可信的库调用，不可变形式是安全的。</li></ol><h1 id="创建不可变集合的书写方式"><a href="#创建不可变集合的书写方式" class="headerlink" title="创建不可变集合的书写方式"></a>创建不可变集合的书写方式</h1><p>在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合<br><img src="/assets/d6832a15c2d74a54a1dd59ce05bb85f1.png" alt="d6832a15c2d74a54a1dd59ce05bb85f1.png"></p><blockquote><p>这个集合不能添加，不能删除，不能修改。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 一旦创建完毕，是无法修改的，只能进行查询操作</span></span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">// 在Set集合中，里边的参数要保证唯一，否则就会报错</span></span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">// 在Map集合中，键也不能重复 且 参数有上限（最多只能传递10个键值对）</span></span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于Map.of()方法最多只能传递10个键值对，如果想存储超过10个的键值对，可以使用Map.ofEntries()方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取所有的entry对象</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">    <span class="comment">// 把entries变成数组</span></span><br><span class="line">    <span class="comment">// toArray底层会把集合的长度和数组的长度做一个比较</span></span><br><span class="line">    <span class="comment">// 如果集合的长度 &gt; 数组的长度，会根据实际数据的个数，重新创建新的数组</span></span><br><span class="line">    <span class="comment">// 如果集合的长度 ≤ 数组的长度，表示数据在数组中放得下，不会创建新的数组，直接使用数组的长度</span></span><br><span class="line">    Map.Entry[] arr = entries.toArray(<span class="keyword">new</span> <span class="title class_">Map</span>.Entry[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 不可变的map集合</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">res</span> <span class="operator">=</span> Map.ofEntries(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK10如果想存储超过10个的键值对，可以用Map.copyOf()方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">res</span> <span class="operator">=</span> Map.copyOf(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-反射</title>
      <link href="/post/94e71cae.html"/>
      <url>/post/94e71cae.html</url>
      
        <content type="html"><![CDATA[<p>反射允许对成员变量，成员方法、构造方法的信息进行编程访问。<br>反射 &#x3D; 获取 + 解剖</p><ul><li>获取：获取class对象</li><li>解剖：解剖class对象的一些方法信息</li></ul><h1 id="获取class对象的三种方式"><a href="#获取class对象的三种方式" class="headerlink" title="获取class对象的三种方式"></a>获取class对象的三种方式</h1><ul><li>Class.forName(“全类名”)：最常用。</li><li>类名.class：当作参数进行传递</li><li>对象.getClass()：当已经有了这个类的对象时可以使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Class.forName(&quot;全类名&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Student&quot;</span>);<span class="comment">// 全类名 = 包名 + 类名</span></span><br><span class="line">        <span class="comment">// 类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 对象.getClass()</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用反射获取构造方法Constructor"><a href="#利用反射获取构造方法Constructor" class="headerlink" title="利用反射获取构造方法Constructor"></a>利用反射获取构造方法Constructor</h1><p><img src="/assets/ddcb8d18273a47d9a97f16a5da85b511.png" alt="ddcb8d18273a47d9a97f16a5da85b511.png"></p><h2 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Stu</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Stu</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有公共的构造方法</span></span><br><span class="line">        Constructor[] cons1 = clazz.getConstructors();</span><br><span class="line">        <span class="comment">// 获取所有的构造方法</span></span><br><span class="line">        Constructor[] cons2 = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 获取单个构造方法对象【只能获取公共的】</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con1</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> clazz.getConstructor(String.class);</span><br><span class="line">        <span class="comment">// 获取单个构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con4</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(con4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取权限修饰符"><a href="#获取权限修饰符" class="headerlink" title="获取权限修饰符"></a>获取权限修饰符</h2><blockquote><p>getDeclaredConstructor()如果获取的是私有的构造方法，正常情况不能用获取的构造方法创建对象，但是使用<strong>暴力反射</strong>就可以使用私有的构造方法创建对象了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor con = clazz.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">con.setAccessible(true);</span><br><span class="line">Stu stu = (Stu) con.newInstance(&quot;zhangsan&quot;, 23);</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取构造方法对象【私有的】</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="comment">// 暴力反射：临时取消权限校验【如果使用私有的构造方法，需要加上这行】</span></span><br><span class="line">        con.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> (Stu) con.newInstance(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取构造方法的权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> con.getModifiers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取构造方法的参数</span></span><br><span class="line">        Parameter[] ps = con.getParameters();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用反射获取成员变量Field"><a href="#利用反射获取成员变量Field" class="headerlink" title="利用反射获取成员变量Field"></a>利用反射获取成员变量Field</h1><p><img src="/assets/200774045d0b4aaa8d4fd770a9ad92ec.png" alt="200774045d0b4aaa8d4fd770a9ad92ec.png"></p><h2 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">// 获取class字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu2&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有公共的成员变量</span></span><br><span class="line">        Field[] fields1 = clazz.getFields();</span><br><span class="line">        <span class="comment">// 获取所有的成员变量</span></span><br><span class="line">        Field[] fields2 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 获取公共的单个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">gender</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取单个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取权限修饰符-1"><a href="#获取权限修饰符-1" class="headerlink" title="获取权限修饰符"></a>获取权限修饰符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取单个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取成员变量记录的值</span></span><br><span class="line">        <span class="comment">// 暴力反射：临时取消权限校验【如果要获取私有的成员变量，需要加上这行】</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) name.get(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改成员变量的值</span></span><br><span class="line">        name.set(stu, <span class="string">&quot;linsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> name.getModifiers();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员变量名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> name.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据类型</span></span><br><span class="line">        Class&lt;?&gt; type = name.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用反射获取成员方法Method"><a href="#利用反射获取成员方法Method" class="headerlink" title="利用反射获取成员方法Method"></a>利用反射获取成员方法Method</h1><p><img src="/assets/034ce5f995e2439daf61435975e0e494.png" alt="034ce5f995e2439daf61435975e0e494.png"></p><h2 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">eat</span><span class="params">(String something)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在吃&quot;</span> + something);</span><br><span class="line">        <span class="keyword">return</span> something;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something, <span class="type">int</span> a)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在吃&quot;</span> + something);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu3&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有公共的方法【包含父类中所有的公共方法】</span></span><br><span class="line">        Method[] methods1 = clazz.getMethods();</span><br><span class="line">        <span class="comment">// 获取所有本类中的方法【包括私有方法】</span></span><br><span class="line">        Method[] methods2 = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// 获取公共的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">sleep</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取指定的单一方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取权限修饰符-2"><a href="#获取权限修饰符-2" class="headerlink" title="获取权限修饰符"></a>获取权限修饰符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu3&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 获取方法的修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> eat.getModifiers();</span><br><span class="line">        <span class="comment">// 获取方法的名字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> eat.getName();</span><br><span class="line">        <span class="comment">// 获取方法的形参</span></span><br><span class="line">        Parameter[] parameters = eat.getParameters();</span><br><span class="line">        <span class="comment">// 获取方法抛出的异常</span></span><br><span class="line">        Class&lt;?&gt;[] exceptionTypes = eat.getExceptionTypes();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行方法：</span></span><br><span class="line"><span class="comment">         * Object invoke(Object obj, Object... args)：运行方法</span></span><br><span class="line"><span class="comment">         * 参数1：用obj对象调用该方法</span></span><br><span class="line"><span class="comment">         * 参数2：调用方法的传递的参数（如果没有就不写）</span></span><br><span class="line"><span class="comment">         * 返回值：方法的返回值（如果没有就不写）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Stu3</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu3</span>();</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>); <span class="comment">// 取消访问权限</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String) eat.invoke(stu, <span class="string">&quot;火锅&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h1><ol><li>获取一个类里面所有的信息，获取到之后，再执行其他的业务逻辑</li><li>结合配置文件，动态的创建对象并调用方法</li></ol><blockquote><p>总结：</p><ul><li><strong>get</strong>：获取</li><li><strong>set</strong>：设置</li><li><strong>Constructor</strong>：构造方法</li><li><strong>Field</strong>：成员变量</li><li><strong>Method</strong>：方法</li><li><strong>Parameter</strong>：参数</li><li><strong>Modifiers</strong>：修饰符</li><li><strong>Declared</strong>：私有的</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-方法引用</title>
      <link href="/post/4b4db8e0.html"/>
      <url>/post/4b4db8e0.html</url>
      
        <content type="html"><![CDATA[<p><strong>方法引用</strong>：就是把已经有的方法拿过来用，当作函数式接口抽象方法的方法体。<br><strong>条件</strong>：</p><ol><li>引用处必须是函数式接口</li><li>被引用的方法必须已经存在</li><li>被引用方法的形参和返回值需要和抽象方法保持一致</li><li>被引用的方法要满足当前需求</li></ol><p><strong>格式</strong>：类名::方法名</p><hr><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="comment">// 被引用的方法：可以是java已经写好的，也可以是第三方工具类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">// lambda表达式</span></span><br><span class="line">        Arrays.sort(arr, (o1, o2) -&gt; o1 - o2);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// 改进：方法引用</span></span><br><span class="line">        Arrays.sort(arr, Demo01::sub); <span class="comment">// 类名::方法名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h1><p>格式：类名::静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; list1 = list.stream().map(Integer::parseInt)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h1><p>格式：对象::成员方法</p><ol><li>其他类：其它类对象::方法名</li><li>本类：this::方法名</li><li>父类：super::方法名</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">StringJudge</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; s.length() == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = list.stream().filter(<span class="keyword">new</span> <span class="title class_">Demo03</span>()::StringJudge)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：引用本类成员方法、父类成员方法处不能是静态方法</p></blockquote><h1 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h1><p>格式：类名::new</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer no;</span><br><span class="line">    <span class="comment">// 流里边的数据是string，所以这里形参需要写string</span></span><br><span class="line">    Student(String str) &#123;</span><br><span class="line">        String[] split = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = split[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.no = Integer.valueOf(split[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌-1&quot;</span>, <span class="string">&quot;周芷若-2&quot;</span>, <span class="string">&quot;赵敏-3&quot;</span>, <span class="string">&quot;张三丰-4&quot;</span>, <span class="string">&quot;张翠山-5&quot;</span>, <span class="string">&quot;张良-6&quot;</span>, <span class="string">&quot;王二麻子-7&quot;</span>, <span class="string">&quot;谢广坤-8&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; list1 = list.stream().map(Student::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他调用方式"><a href="#其他调用方式" class="headerlink" title="其他调用方式"></a>其他调用方式</h1><h2 id="使用类名引用成员方法"><a href="#使用类名引用成员方法" class="headerlink" title="使用类名引用成员方法"></a>使用类名引用成员方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = list.stream()</span><br><span class="line">        <span class="comment">// 拿着流里的数据，去调用String类中的toUpperCase方法，返回值就是转换后的结果</span></span><br><span class="line">                .map(String::toUpperCase)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：被引用方法的形参需要跟抽象方法的<strong>第二个形参到最后一个形参</strong>保持一致<br><img src="/assets/13727fe029cd4c4b97be59bd9718328f.png" alt="13727fe029cd4c4b97be59bd9718328f.png"></p><ol><li>第一个参数：表示被引用方法的调用者，决定了可以引用哪些类中的方法<br>在stream流中，第一个参数一般都表示流里边每个数据，假设流里边的数据是字符串，那么只能引用String这个类中的方法</li><li>第二个参数到最后一个参数：和被引用方法的形参保持一致，如果没有第二个参数，说明被引用的方法需要是无参的成员方法</li></ol></blockquote><h2 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h2><p>格式：数据类型[]::new</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        String[] array = list.stream()</span><br><span class="line">                .toArray(String[]::<span class="keyword">new</span>); <span class="comment">// 数组中的类型需要和流中数据的类型保持一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 方法引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-可变集合</title>
      <link href="/post/53e9807a.html"/>
      <url>/post/53e9807a.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合的体系结构"><a href="#集合的体系结构" class="headerlink" title="集合的体系结构"></a>集合的体系结构</h1><p><img src="/assets/225e05bdb27e4545a5bc6c774b3d21f2.png" alt="225e05bdb27e4545a5bc6c774b3d21f2.png"><br>List：添加的元素是有序、可重复、有索引的。<br>Set：添加的元素是无序、不重复、无索引的。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>是单列集合的祖宗<strong>接口</strong>，它的功能是所有单列集合都可以继承使用。</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p><img src="/assets/1d4ba5478768419eafc91c126267031c.png" alt="1d4ba5478768419eafc91c126267031c.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 增：</span></span><br><span class="line"><span class="comment">         * 往List集合里添加数据，方法永远返回true</span></span><br><span class="line"><span class="comment">         * 往Set集合里添加数据</span></span><br><span class="line"><span class="comment">         *      元素已经存在：返回false</span></span><br><span class="line"><span class="comment">         *      元素不存在：返回true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.remove(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 删</span></span><br><span class="line">        coll.clear();<span class="comment">// 删：清空集合</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断要删除的元素是否存在</span></span><br><span class="line"><span class="comment">         * contains底层是依赖equals()方法进行判断的</span></span><br><span class="line"><span class="comment">         * 如果集合中存储的是自定义的对象，一定要重写equals方法</span></span><br><span class="line"><span class="comment">         * 如果没有重写equals方法，默认使用Object中的equals方法【通过地址值判断】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isExists</span> <span class="operator">=</span> coll.contains(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> coll.isEmpty();<span class="comment">// 判断集合是否为空</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> coll.size(); <span class="comment">// 获取集合长度 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>迭代器Iterator是集合专用的遍历方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator(); <span class="comment">// 获取迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123; <span class="comment">// 是否还有元素</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next(); <span class="comment">// 获取元素，移动指针</span></span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>迭代器遍历<strong>不依赖索引</strong></li><li>如果迭代器遍历到最后一个位置了，还强行使用it.next()，会报错：<strong>NoSuchElementException</strong></li><li>迭代器遍历完毕，<strong>指针不会复位</strong></li><li>循环中只能用一次next方法【如果想要使用第二次，最好在循环里多判断一次hasNext()】</li><li>迭代器遍历时，<strong>不能使用集合的方法进行添加或删除</strong>，会报错：ConcurrentModificationException<ul><li>但是可以用迭代器提供的remove()方法进行删除</li><li>添加暂时无解</li></ul></li></ul></blockquote><h3 id="增强for遍历"><a href="#增强for遍历" class="headerlink" title="增强for遍历"></a>增强for遍历</h3><p>增强for是为了简化迭代器的书写，内部原理就是迭代器，<strong>单列集合、数组</strong>才能用增强for遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 变量名 : 数组或集合)&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改增强for中的变量（第三方变量），不会改变集合原本的数据</p></blockquote><h3 id="lambda表达式遍历"><a href="#lambda表达式遍历" class="headerlink" title="lambda表达式遍历"></a>lambda表达式遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>forEach的底层就是增强for</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>迭代器：删除元素<br>读：增强for 或 lambda</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>有序、有索引、可重复<br>List集合的方法 &#x3D; Collection的方法  + 索引操作的方法</p><h2 id="List中特有的方法"><a href="#List中特有的方法" class="headerlink" title="List中特有的方法"></a>List中特有的方法</h2><p>Collection的方法List都继承了</p><blockquote><ul><li>删除元素：</li></ul><ul><li>如果在调用remove()方法时，remove(int idx) 和 remove(Object obj)都可以匹配上，那么优先调用实际参数和形参保持一致的方法。</li></ul></blockquote><h3 id="索引操作的方法"><a href="#索引操作的方法" class="headerlink" title="索引操作的方法"></a>索引操作的方法</h3><p><img src="/assets/4173a3a2d709400d9bfcad56fb999510.png" alt="4173a3a2d709400d9bfcad56fb999510.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 在指定索引添加元素【原来索引上的元素会依次往后移】</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素，通过索引删除【返回被删除索引的元素】</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">remove</span> <span class="operator">=</span> list.remove(<span class="number">1</span>); <span class="comment">// 优先调用实参和形参保持一致的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素，通过元素删除【返回bool值判断是否删除成功】</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>); <span class="comment">// 手动装箱，把基本类型变成Integer类型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isRemove</span> <span class="operator">=</span> list.remove(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指定索引的元素【返回修改前的元素】</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">res</span> <span class="operator">=</span> list.set(<span class="number">0</span>, <span class="number">33</span>);</span><br><span class="line">        <span class="comment">// 返回指定索引的元素</span></span><br><span class="line">        res = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List中独有的遍历方式"><a href="#List中独有的遍历方式" class="headerlink" title="List中独有的遍历方式"></a>List中独有的遍历方式</h2><p> Collection的遍历方式List都可以用<br> List集合的遍历方式 &#x3D; Collection中的遍历方式 + 列表迭代器遍历 + 普通for遍历</p><h3 id="Collection中的遍历方式-普通for遍历"><a href="#Collection中的遍历方式-普通for遍历" class="headerlink" title="Collection中的遍历方式 + 普通for遍历"></a>Collection中的遍历方式 + 普通for遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. Lambda表达式遍历</span></span><br><span class="line">        list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">// 4.普通for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表迭代器"><a href="#列表迭代器" class="headerlink" title="列表迭代器"></a>列表迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.列表迭代器遍历</span></span><br><span class="line">        ListIterator&lt;String&gt; it = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;bbb&quot;</span>.equals(str)) &#123;</span><br><span class="line">                it.add(<span class="string">&quot;zzz&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>列表迭代器 相比 迭代器多出了<strong>添加元素</strong>的方法</p></blockquote><h3 id="五种方式的对比"><a href="#五种方式的对比" class="headerlink" title="五种方式的对比"></a>五种方式的对比</h3><p>迭代器：需要删除元素<br>列表迭代器：需要添加元素<br>增强for、lambda：仅遍历元素<br> 普通for：想操作索引</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList的底层是<strong>数组</strong>的，ArrayList中的方法 &#x3D; List中的方法</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ol><li>利用空参创建的集合，在底层创建一个默认长度为0的数组。</li><li>添加第一个元素，底层会创建一个长度为10的数组。</li><li>存满时，会扩容1.5倍。</li><li>如果一次添加多个元素，1.5倍放不下，则新数组的长度以实际长度为准。</li></ol><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p> LinkedList的底层是<strong>双链表</strong>，查询慢、增删快。<br> LinkedList中的方法 &#x3D; List中的方法 + LinkedList中独有的方法（少用）</p><h3 id="LinkedList中独有的方法"><a href="#LinkedList中独有的方法" class="headerlink" title="LinkedList中独有的方法"></a>LinkedList中独有的方法</h3><p><img src="/assets/93a6bab83fb94913856e6be23387bc9c.png" alt="93a6bab83fb94913856e6be23387bc9c.png"></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>泛型：在编译阶段约束操作的数据类型</li><li>泛型只支持<strong>引用数据类型</strong>（基本数据类型要转成包装类才行）</li><li>不写泛型，默认是Object类型</li><li>如果没有给集合指定泛型，默认所有的数据类型都是Object类型，此时可以往集合中添加任意类型的数据，在获取数据的时候，无法使用元素的特有行为。</li></ul><blockquote><p>Java中的泛型是伪泛型<br><img src="/assets/130435e5f1bb415b8ed9e9c6fca8fd0d.png" alt="130435e5f1bb415b8ed9e9c6fca8fd0d.png"></p></blockquote><h2 id="泛型可以定义的地方"><a href="#泛型可以定义的地方" class="headerlink" title="泛型可以定义的地方"></a>泛型可以定义的地方</h2><h3 id="泛型类（类后边）"><a href="#泛型类（类后边）" class="headerlink" title="泛型类（类后边）"></a>泛型类（类后边）</h3><p>使用场景：当定义一个类时，某个变量的数据类型不确定，就可以定义带有泛型的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;类型&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&lt;E&gt; &#123; <span class="comment">// E可以理解成变量</span></span><br><span class="line">E sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    Object[] obj = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// E：是不确定的数据类型，该类型在类名后已经定义过了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        obj[size] = e;</span><br><span class="line">        ++size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E)obj[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyArrayList&lt;String&gt; list =  <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法（方法上边）"><a href="#泛型方法（方法上边）" class="headerlink" title="泛型方法（方法上边）"></a>泛型方法（方法上边）</h3><p>方法中形参类型不确定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;T&gt; list, T...elements)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(T e : elements) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ListUtil.addAll(list, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口（接口后边）"><a href="#泛型接口（接口后边）" class="headerlink" title="泛型接口（接口后边）"></a>泛型接口（接口后边）</h3><ul><li>方式1：实现类给出具体类型</li><li>方式2：实现类延续泛型，创建对象时再确定</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyList</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K element)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList1</span> <span class="keyword">implements</span> <span class="title class_">MyList</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String element)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList2</span>&lt;K&gt; <span class="keyword">implements</span> <span class="title class_">MyList</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K element)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1：实现类给出具体类型</span></span><br><span class="line">        <span class="type">MyArrayList1</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyArrayList1</span>(); <span class="comment">// 不需要指定泛型了</span></span><br><span class="line">        <span class="comment">// 方式2：实现类延续泛型，创建对象时再确定</span></span><br><span class="line">        MyArrayList2&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyArrayList2</span>(); <span class="comment">// 需要指定泛型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><ul><li>泛型不具备继承性，但是数据具备继承性</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ye</span>&#123;&#125; <span class="comment">// 爷爷</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> <span class="keyword">extends</span> <span class="title class_">Ye</span>&#123;&#125; <span class="comment">// 父亲</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;&#125; <span class="comment">// 儿子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.泛型不具备继承性</span></span><br><span class="line"><span class="comment">     * 此时泛型里面写的是什么类型，只能传递什么类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;Ye&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        method(list1);</span><br><span class="line">        <span class="comment">// method(list2); // 代码报错</span></span><br><span class="line">        <span class="comment">// method(list3); // 代码报错</span></span><br><span class="line">        <span class="comment">// 2.数据具备继承性</span></span><br><span class="line">        list1.add(<span class="keyword">new</span> <span class="title class_">Ye</span>());</span><br><span class="line">        list1.add(<span class="keyword">new</span> <span class="title class_">Fu</span>());</span><br><span class="line">        list1.add(<span class="keyword">new</span> <span class="title class_">Zi</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果方法形参是一个集合，集合中的数据类型不确定，可以用<strong>泛型方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;T&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        method(list1);</span><br><span class="line">        method(list2);</span><br><span class="line">        method(list3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><blockquote><p>上边代码存在一个问题：这种情况下它可以接受任意的数据类型<br>如果希望以后这个参数的数据类型只能是：Ye、Fu、Zi类，可以用<strong>泛型的通配符</strong></p><ul><li>? extends E：表示可以传递E或E所有的子类类型</li><li>? super E：表示可以传递E或E所有的父类类型</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;E&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(ArrayList&lt;? extends Ye&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Zi&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        method1(list1);</span><br><span class="line">        method1(list2);</span><br><span class="line">        method1(list3);</span><br><span class="line">        method2(list1);</span><br><span class="line">        method2(list2);</span><br><span class="line">        method2(list3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>如果定义类、方法、接口时，类型不确定，可以定义<strong>泛型类、泛型方法、泛型接口</strong>。<br>如果类型不确定，但是能知道以后只能传递某个继承体系中的，可以使用<strong>泛型通配符</strong>。</p></blockquote><h1 id="单列集合Set"><a href="#单列集合Set" class="headerlink" title="单列集合Set"></a>单列集合Set</h1><p>无序、不重复、无索引<br>Set集合的方法 &#x3D; Collection的方法</p><blockquote><p>【注】：所有Set集合的底层原理都是new Map()</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 第一次添加，添加成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r1</span> <span class="operator">=</span> st.add(<span class="string">&quot;A&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 第二次添加，添加失败</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r2</span> <span class="operator">=</span> st.add(<span class="string">&quot;A&quot;</span>); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 1.迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = st.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String s : st) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.Lambda表达式遍历</span></span><br><span class="line">        st.forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Set集合的实现类：</p><ul><li>HashSet：无序、不重复、无索引</li><li>LinkedHashSet：有序、不重复、无索引</li><li>TreeSet：可排序、不重复、无索引</li></ul></blockquote><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet底层采用<strong>哈希表</strong>存储数据</p><ul><li>哈希表的组成：<ul><li>JDK8之前：数组 + 链表</li><li>JDK8开始：数组 + 链表 + 红黑树</li></ul></li></ul><h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><ul><li><p>对象的整数表现形式，根据hashCode()算出来的int类型的整数</p></li><li><p>hashCode()定义在<strong>Object类中</strong>，所有的对象都可以调用，<strong>默认使用地址值</strong>进行计算</p></li><li><p>一般情况需要<strong>重写hashCode()方法</strong>，利用对象内部的属性值计算哈希值</p><ul><li>如果没有重写hashCode()方法，不同对象计算出的hashCode是不不同的</li><li>如果重写hashCode()方法，不同对象只要属性值相同，计算出的哈希值是一样的</li><li>小概率：不同属性值或不同地址值计算出来的哈希值也可能一样（哈希碰撞）</li></ul></li></ul><h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><ol><li>创建一个默认长度为16，默认加载因子为0.75的数组</li></ol><blockquote><p>hashSet的扩容时机：</p><ul><li>16 * 0.75 &#x3D; 12，当数组中元素达到12个元素，就会扩容成原先的2倍</li><li><strong>（JDK8开始）</strong>链表的长度 &gt; 8 且 数组长度 ≥ 64，当前链表会自动转成红黑树</li></ul></blockquote><ol start="2"><li>根据数组的哈希值与数组的长度计算元素应存入的位置</li></ol><blockquote><p>int idx &#x3D; (数组长度 - 1) &amp; 哈希值;</p></blockquote><ol start="3"><li>判断当前位置是否为null<ul><li>如果是null，直接存入</li><li>如果不是null，调用equals()方法比较属性值<ul><li>一样：不存</li><li>不一样：存入数组，形成链表 <ul><li>JDK8以前：新数组存入数组，老元素挂在新数组下边</li><li>JDK8开始：新元素直接挂在老元素下边</li></ul></li></ul></li></ul></li></ol><blockquote><p>如果集合中存储的是自定义对象，必须重写hashCode和equals方法</p></blockquote><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li>有序、不重复、无索引</li><li>有序：存储和取出元素的顺序一致</li><li>原理：底层仍然是哈希表，只是每个元素有额外多了一个<strong>双链表</strong>的机制记录存储的顺序</li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li>可排序、不重复、无索引</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">4</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">5</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet集合默认排序规则"><a href="#TreeSet集合默认排序规则" class="headerlink" title="TreeSet集合默认排序规则"></a>TreeSet集合默认排序规则</h3><ul><li>数值类型（Integer、Double）：默认按照从小到大顺序排序</li><li>字符、字符串类型：默认按照字符在ASCII码表中的顺序升序排序</li></ul><h3 id="TreeSet集合的两种比较方式"><a href="#TreeSet集合的两种比较方式" class="headerlink" title="TreeSet集合的两种比较方式"></a>TreeSet集合的两种比较方式</h3><blockquote><p>【注】：<br>如果使用TreeSet集合存储自定义类型，不需要重写HashCode和equals方法，但是需要在类里边指定排序规则。</p></blockquote><h4 id="方式1：默认排序-自然排序"><a href="#方式1：默认排序-自然排序" class="headerlink" title="方式1：默认排序 &#x2F; 自然排序"></a>方式1：默认排序 &#x2F; 自然排序</h4><p>Javabean<strong>实现Comparable接口</strong>指定比较规则。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Stu&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义排序规则</span></span><br><span class="line"><span class="comment">     * this：表示当前要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 表示已经在红黑树中存在的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 负数-要添加的元素是小的-存左边</span></span><br><span class="line"><span class="comment">     *         正数-要添加的元素是大的-存右边</span></span><br><span class="line"><span class="comment">     *         0-要添加的元素已经存在-舍弃不存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAge() - o.getAge(); <span class="comment">// 升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaoshi&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaohan&quot;</span>, <span class="number">19</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaolin&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;03&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式2：比较器排序"><a href="#方式2：比较器排序" class="headerlink" title="方式2：比较器排序"></a>方式2：比较器排序</h4><p>创建TreeSet对象时，传递比较器Compartor指定规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span><span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o1 当前要添加的元素</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o2 已经在红黑树中存在的元素</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">                // 按照长度排序，如果长度一样，按照首字母排序</span></span><br><span class="line"><span class="comment">                return o1.length() == o2.length() ? o1.compareTo(o2) : o1.length() - o2.length();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1, o2) -&gt; o1.length() == o2.length() ? o1.compareTo(o2) : o1.length() - o2.length());</span><br><span class="line">        set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;df&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;quer&quot;</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种比较规则的使用场景"><a href="#两种比较规则的使用场景" class="headerlink" title="两种比较规则的使用场景"></a>两种比较规则的使用场景</h4><p>默认使用第一种，如果第一种不能满足规则，就使用第二种。</p><h1 id="List、Set的使用场景"><a href="#List、Set的使用场景" class="headerlink" title="List、Set的使用场景"></a>List、Set的使用场景</h1><ol><li>如果想要集合中的元素可重复：<strong>ArrayList</strong>、基于数组</li><li>如果想要集合中的元素可重复，且增删操作多余查询：LinkedList、基于链表</li><li>如果想对集合中的元素去重：<strong>HashSet</strong>、基于哈希表</li><li>如果想对集合中的元素去重，且保证存储顺序：LinkedHashSet、基于哈希表和双链表，效率低于HashSet</li><li>如果想对集合中的元素进行排序：TreeSet、基于红黑树</li></ol><h1 id="双列集合Map"><a href="#双列集合Map" class="headerlink" title="双列集合Map"></a>双列集合Map</h1><ul><li>一次需要存一对数据（键-值）</li><li>键不能重复，值可以重复</li><li>键值是一一对应的，每个键只能找到对应的值</li><li>键 + 值 称为“键值对”，在java中叫做“Entry对象”</li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><img src="/assets/6a6e69213a3f4aff87d018d374245b9a.png" alt="6a6e69213a3f4aff87d018d374245b9a.png"></p><h2 id="常见的API"><a href="#常见的API" class="headerlink" title="常见的API"></a>常见的API</h2><p>Map是双列集合的顶层接口，他的功能是全部双列集合都可以继承使用的。<br><img src="/assets/9d96c5d979ea4613ba1398638ebe771d.png" alt="9d96c5d979ea4613ba1398638ebe771d.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加 / 覆盖：</span></span><br><span class="line"><span class="comment">         * 如果键不存在：直接添加，返回null</span></span><br><span class="line"><span class="comment">         * 如果键存在：会把原有的键值对覆盖，返回这个键原来对应的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        map.put(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰1&quot;</span>);</span><br><span class="line">        res = map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否存在【键/值】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">keyResult</span> <span class="operator">=</span> map.containsKey(<span class="string">&quot;工藤新一&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valueResult</span> <span class="operator">=</span> map.containsValue(<span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断集合是否为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> map.isEmpty();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取集合的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> map.size();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除：</span></span><br><span class="line"><span class="comment">         * 返回删除的键对应的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">removeValue</span> <span class="operator">=</span> map.remove(<span class="string">&quot;杨过&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 清空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;怪盗基德&quot;</span>, <span class="string">&quot;中森青子&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有的键，把这些键放到一个单列集合中</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历单列集合，得到每一个键</span></span><br><span class="line">        keys.forEach(k -&gt; System.out.println(k + <span class="string">&quot;-&quot;</span> + map.get(k)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;怪盗基德&quot;</span>, <span class="string">&quot;中森青子&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过一个方法获取所有的Entry对象</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;-&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;怪盗基德&quot;</span>, <span class="string">&quot;中森青子&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;-&quot;</span> + v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap中的方法 &#x3D; Map中的方法</p><h3 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h3><p>同HashSet，就是在计算hash值的时候调用的是键的hashCode()方法</p><ul><li>底层也是哈希表结构</li><li>依赖hashCode()和equals()方法保证键的唯一</li><li>如果<strong>键存储</strong>的是<strong>自定义对象</strong>，需要重写hashCode()和equals()方法</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><strong>有序</strong>、不重复、无索引<br>原理：底层数据结构仍是哈希表，只是每一个键值对元素又额外多了一个双链表机制记录存储的顺序。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>底层同TreeSet，都是红黑树结构。</li><li>由键决定特性：不重复、无索引、可排序（对键排序）</li><li>默认按照键从小到大排序，也可以自己规定键的排序规则。</li></ul><h4 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h4><h5 id="方法1：默认排序-自定义排序"><a href="#方法1：默认排序-自定义排序" class="headerlink" title="方法1：默认排序&#x2F;自定义排序"></a>方法1：默认排序&#x2F;自定义排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Stu&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.age != o.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Stu, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>), <span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">24</span>), <span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;wangwu&quot;</span>, <span class="number">25</span>), <span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法2：比较器排序"><a href="#方法2：比较器排序" class="headerlink" title="方法2：比较器排序"></a>方法2：比较器排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Integer、Double...默认是升序</span></span><br><span class="line">    <span class="comment">// String默认按照字母在ASCII码表中对应的数字升序排列</span></span><br><span class="line">        TreeMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((k1, k2) -&gt; k2 - k1);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// 降序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map的使用场景"><a href="#Map的使用场景" class="headerlink" title="Map的使用场景"></a>Map的使用场景</h2><p>HashMap：默认（效率最高）<br>LinkedHashMap：保证存取有序<br>TreeMap：保证排序</p><h1 id="Collections：集合的工具类"><a href="#Collections：集合的工具类" class="headerlink" title="Collections：集合的工具类"></a>Collections：集合的工具类</h1><p><img src="/assets/58c138358244477d9ab1add8f380094e.png" alt="58c138358244477d9ab1add8f380094e.png"></p>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的可变参数</title>
      <link href="/post/c1521b0d.html"/>
      <url>/post/c1521b0d.html</url>
      
        <content type="html"><![CDATA[<p>可变参数：方法形参的个数可以发生变化</p><blockquote><p>格式：<br>属性类型…名字</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> ...args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> arg : args) &#123;</span><br><span class="line">            sum += arg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getSum());</span><br><span class="line">        System.out.println(getSum(<span class="number">1</span>));</span><br><span class="line">        System.out.println(getSum(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(getSum(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数的底层就是一个数组，就是不需要我们再创建了，java会帮我们创建好</p><blockquote><p>【注】：</p><ol><li>在方法的形参中最多<strong>只能写一个可变参数</strong>。</li><li>如果方法中有多个形参，可变参数要<strong>写在最后</strong>。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 函数传参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="/assets/86ce0a77e3a242f493d740b3a7bc615e.png" alt="86ce0a77e3a242f493d740b3a7bc615e.png"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="/assets/be6f6e0058b14d0eaced342c6160c8ac.png" alt="be6f6e0058b14d0eaced342c6160c8ac.png"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="/assets/e0c5fb89dfd84977a33ba998567a74f7.png" alt="e0c5fb89dfd84977a33ba998567a74f7.png"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="/assets/75ccadc7eac740b0a2dfec05731a4136.png" alt="75ccadc7eac740b0a2dfec05731a4136.png"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="/assets/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="fe985ab6ad1b49668ecde4ac68f34ce7.png"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="/assets/7d44413b38b94fe98df341556698d3c7.png" alt="7d44413b38b94fe98df341556698d3c7.png"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="/assets/185030e49e7d43409502a8c48db5b469.png" alt="185030e49e7d43409502a8c48db5b469.png"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="/assets/1c0a9b60a73f4b40a655257f72e188b6.png" alt="1c0a9b60a73f4b40a655257f72e188b6.png"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="/assets/25c8751bd3024b3ca43d05051e22735c.png" alt="25c8751bd3024b3ca43d05051e22735c.png"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="/assets/c6dab1985c4b44fbacb3ac92514492b7.png" alt="c6dab1985c4b44fbacb3ac92514492b7.png"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="/assets/4d93bc3624974d43951035b7b828d5c5.png" alt="4d93bc3624974d43951035b7b828d5c5.png"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="/assets/1403ed11ca8f49c0907b34d62a592c96.png" alt="1403ed11ca8f49c0907b34d62a592c96.png"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="/assets/1873509cc7b04927868a9fb188b42fd6.png" alt="1873509cc7b04927868a9fb188b42fd6.png"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br> <code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="/assets/5be5b756eaa847b095f13d98145cab10.png" alt="5be5b756eaa847b095f13d98145cab10.png"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="/assets/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="15c3fe4b606a4f1b9a023d9b7f64a144.png"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2379. 得到 K 个黑块的最少涂色次数</title>
      <link href="/post/43089fc2.html"/>
      <url>/post/43089fc2.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/25a2e86292cd4c6fa7ce290bd2052c3b.png" alt="25a2e86292cd4c6fa7ce290bd2052c3b.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/">2379. 得到 K 个黑块的最少涂色次数</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = blocks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curWcount = <span class="number">0</span>; <span class="comment">// 记录窗口内W字符的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; blocks.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blocks[r] == <span class="string">&#x27;W&#x27;</span>) &#123; <span class="comment">// 滑窗内有字符W</span></span><br><span class="line">                curWcount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, curWcount);</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(blocks[l++] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    curWcount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>题目想要求把白色块变成黑色块使得有k个连续的黑色块的最小次数，也就是求滑窗内白色块出现的最小次数。只要统计长度为k的滑窗内最少的白色字符数即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2090. 半径为 k 的子数组平均值</title>
      <link href="/post/8b141577.html"/>
      <url>/post/8b141577.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/12af681c4bc24b7b8e5d1c3c4b39190d.png" alt="12af681c4bc24b7b8e5d1c3c4b39190d.png"><br>【题目】：<a href="https://leetcode.cn/problems/k-radius-subarray-averages/">2090. 半径为 k 的子数组平均值</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> curSum = <span class="number">0</span>; <span class="comment">// 记录当前滑窗内的数值和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            curSum += nums[r];</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k * <span class="number">2</span> + <span class="number">1</span>) &#123; <span class="comment">// 窗口长度满足条件</span></span><br><span class="line">                res[r - k] = curSum / (k * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 当长度满足时，此时对应的半径中心坐标是：r - k</span></span><br><span class="line">                curSum -= nums[l++]; <span class="comment">// 缩小窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>半径为 k 的子数组：说明滑窗的长度（r - l + 1）必须要达到2 * k + 1。但是当r下标到达半径中心的时候，还不知道此时数组内元素和，所以可以等到滑窗长度达到条件时，再去反推半径中心。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1461. 检查一个字符串是否包含所有长度为 K 的二进制子串</title>
      <link href="/post/b541a47.html"/>
      <url>/post/b541a47.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/ebb6bd124ee440cab48c47a7395956d3.png" alt="ebb6bd124ee440cab48c47a7395956d3.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/">1461. 检查一个字符串是否包含所有长度为 K 的二进制子串</a></p><p> 直接存储滑动窗口内的字符串，这样虽然方便，但是时间复杂度和k相关，如果k &#x3D; n，此时会达到O(n^2)的复杂度。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAllCodes</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">                ss.<span class="built_in">insert</span>(s.<span class="built_in">substr</span>(l, k));</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">size</span>() == <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n*k)</li><li>空间复杂度: O(1&lt;&lt;k)</li></ul><blockquote><p>1&lt;&lt;k：相当于pow(2, k)<br>substr(截取的字符串起始位置, 截取字符串的长度)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1456. 定长子串中元音的最大数目</title>
      <link href="/post/6afae9e.html"/>
      <url>/post/6afae9e.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/8ef7122a0698439c80ae7f976c73683b.png" alt="8ef7122a0698439c80ae7f976c73683b.png"><br>【链接】：<a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">1456. 定长子串中元音的最大数目</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录整个过程中的最大值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前滑动窗口内元音字母的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123; <span class="comment">// 右侧元素进入窗口</span></span><br><span class="line">        <span class="comment">// 上来先判断是否是元音字母</span></span><br><span class="line">            <span class="keyword">if</span>(s[r] == <span class="string">&#x27;a&#x27;</span> || s[r] == <span class="string">&#x27;e&#x27;</span> || s[r] == <span class="string">&#x27;i&#x27;</span> || s[r] == <span class="string">&#x27;o&#x27;</span> || s[r] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(count, res); </span><br><span class="line">            <span class="comment">// 看看是否超过了窗口的长度</span></span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">            <span class="comment">// 左边要离开滑动窗口，看看s[l]是否是元音字母</span></span><br><span class="line">                <span class="keyword">if</span>(s[l] == <span class="string">&#x27;a&#x27;</span> || s[l] == <span class="string">&#x27;e&#x27;</span> || s[l] == <span class="string">&#x27;i&#x27;</span> || s[l] == <span class="string">&#x27;o&#x27;</span> || s[l] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++; <span class="comment">// 左侧元素离开窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>这是一个<code>定长滑动窗口</code>的题，一般会有l、r两个指针，这一过程主要有三个问题：</p><ol><li>右侧元素进入窗口：只要r &lt; s.size()，每次都会进入窗口</li><li>左侧元素离开窗口：当前窗口长度 &#x3D; k</li><li>更新res的最大值</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1343. 大小为 K 且平均值大于等于阈值的子数组数目</title>
      <link href="/post/e9cb7dc4.html"/>
      <url>/post/e9cb7dc4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/9a7f8baf21f243779595bc6a89f043be.png" alt="9a7f8baf21f243779595bc6a89f043be.png"><br>【题目】：<a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/">1343. 大小为 K 且平均值大于等于阈值的子数组数目</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 计算满足条件的数</span></span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>; <span class="comment">// 计算当前滑窗内的总数</span></span><br><span class="line">        <span class="type">int</span> targetSum = k * threshold; <span class="comment">// 当前滑窗内的总数满足条件的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; arr.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            curSum += arr[r];</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123; <span class="comment">// 条件1. 长度为k</span></span><br><span class="line">                <span class="keyword">if</span>(curSum &gt;= targetSum) &#123; <span class="comment">// 条件2. 平均值大于等于threshold</span></span><br><span class="line">                    ++count;<span class="comment">// 满足条件1和2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                curSum -= arr[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题有两个条件，长度为k、平均值大于等于threshold。所以需要依次满足这两个条件后，才能更新count值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1052. 爱生气的书店老板</title>
      <link href="/post/cc4621fb.html"/>
      <url>/post/cc4621fb.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/bf841e57b01a4e23bf1a35d4d00f5e23.png" alt="bf841e57b01a4e23bf1a35d4d00f5e23.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/grumpy-bookstore-owner/description/">1052. 爱生气的书店老板</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxAddCount = <span class="number">0</span>; <span class="comment">// 在minutes长度内，还能增加的最大顾客满意人数</span></span><br><span class="line">        <span class="type">int</span> curAddCount = <span class="number">0</span>; <span class="comment">// 当前窗口内还能增加的顾客满意数</span></span><br><span class="line">        <span class="type">int</span> curCount = <span class="number">0</span>; <span class="comment">// 原本有的顾客满意数</span></span><br><span class="line">        <span class="type">int</span> n = customers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[r] == <span class="number">1</span>) &#123; <span class="comment">// 把老板从生气变成不生气</span></span><br><span class="line">                curAddCount += customers[r]; </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                curCount += customers[r]; <span class="comment">// 原有的顾客满意数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == minutes) &#123;</span><br><span class="line">                maxAddCount = <span class="built_in">max</span>(maxAddCount, curAddCount);</span><br><span class="line">                <span class="keyword">if</span>(grumpy[l] == <span class="number">1</span>) &#123;</span><br><span class="line">                    curAddCount -= customers[l];</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAddCount + curCount; <span class="comment">// 当天内最大顾客满意数 = 可以增加的最大顾客满意数 + 原本有的顾客满意数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>当天内最大顾客满意数 &#x3D; 可以增加的最大顾客满意数 + 原本有的顾客满意数<br>原本有的顾客满意数是动不了的，所以只需要求可以增加的最大顾客满意数。<br>书店老板可以让自己连续minutes分钟不生气，说明滑动窗口的长度为minutes<br>所以本题只需要求在minutes的滑动窗口内，可以增加的最大顾客满意数，即在滑动窗口内，可以从grumpy[i]为1变为0后增加的最大顾客满意数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>643. 子数组最大平均数 I</title>
      <link href="/post/9730100f.html"/>
      <url>/post/9730100f.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/092c3f51831e422ead89e06101ad7c9f.png" alt="092c3f51831e422ead89e06101ad7c9f.png"><br>【链接】：<a href="https://blog.csdn.net/qq_57882997/article/details/145240772?spm=1001.2014.3001.5501">643. 子数组最大平均数 I</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxSum = INT_MIN, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            curSum += nums[r]; <span class="comment">// 更新curSum</span></span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">                maxSum = <span class="built_in">max</span>(maxSum, curSum); <span class="comment">// 更新maxSum(因为题目要求长度为k，所以需要在这里更新maxSum)</span></span><br><span class="line">                curSum -= nums[l]; <span class="comment">// 扣除左侧元素（保持一致）</span></span><br><span class="line">                ++l; <span class="comment">// 左侧元素离开</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum / (<span class="type">double</span>)k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>题目关键字：连续子数组，说明可以采用滑动窗口。<br>maxSum的初始值：因为数组内有负数，maxSum的初始值不应该设置成0，应该设置为int的最小值。<br>更新的位置：因为题目说明长度必须要为k，所以更新的位置应该在if里边，长度为k时才进行更新。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="/post/e192590d.html"/>
      <url>/post/e192590d.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/7c3fb12fc1d241d4af62180ff5fc4b04.png" alt="7c3fb12fc1d241d4af62180ff5fc4b04.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked">15. 三数之和</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 因为是升序排列，如果当前数&gt;0，三数值和一定&gt;0，后边的数字都可以做剪枝</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 去除重复的三元组</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line">            <span class="comment">// -4,-1,-1,0,1,2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r;) &#123;</span><br><span class="line">                <span class="type">int</span> cur = nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span>(target == cur) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) ++l;</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) --r;</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; cur) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题要求不能重复的三元组，只要三元组的三个数是按照顺序进行排列的，这样就可以不用借助set来去充了。<br>所以可以先把数组进行排序，用i指针从头到尾遍历数组，遍历的时候可以利用三元组和为0的特性进行剪枝。如果i遍历的元素已经是&gt;0，但是数组又是升序排列，后边不可能有和&lt;0的数字，所以当i遍历到元素&gt;0时，直接break。<br>遍历的时候要注意，可能会有相同的数字连续出现多次。<br>情况1. nums[i] &#x3D;&#x3D; nums[i - 1]，这种情况可以直接continue。<br>情况2. 当已经找到一个三元组后，可能nums[l] &#x3D;&#x3D; nums[l + 1]，此时都应该使用while循环（可能有多个）排除在外。但是要注意，退出循环的时候，如果是nums[l] !&#x3D; nums[l + 1]，但是此时nums[l] &#x3D;&#x3D; nums[l - 1]，这样就会出现死循环。所以一定要在推出while循环后再做一次++l的操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;tags:</span><br><span class="line"> - 算法</span><br><span class="line"> - LeetCode热题100</span><br><span class="line"> - 双指针</span><br><span class="line">&gt;categories: LeetCode热题100</span><br><span class="line">&gt;type: LeetCode热题100</span><br><span class="line">&gt;top_img: false</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. 字母异位词分组</title>
      <link href="/post/b390ba48.html"/>
      <url>/post/b390ba48.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/550eba79e4d6445a801eec931869ca85.png" alt="550eba79e4d6445a801eec931869ca85.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组</a></p><p>方法1：直接对字符串进行排序后使用map存储相同的字母异位词，再把map的value依次存放到结果中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(string str : strs) &#123;</span><br><span class="line">            string temp = str;</span><br><span class="line">            <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">            mp[str].<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [key, value] : mp) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n<em>k</em>logk)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>字母异位词对应的排序后的字符串是一样的，所以把每个字符串排序后插入以排序后字符串作为key，以原字符串作为value的map中。这个方法虽然简洁，但是取决于每个字符串的长度，排序的时间复杂度是k * logk</p></blockquote><p>方法2：自定义哈希函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(string str : strs) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : str) &#123;</span><br><span class="line">                count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            string key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                key += count[i] + i + <span class="string">&#x27;a&#x27;</span>;<span class="comment">// 使用：每个字符出现的次数 + 字符 作为key</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [key, value] : mp) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n*max(k, 26))</li><li>空间复杂度: O(n)</li></ul><blockquote><p>使用每个字符出现的次数 + 字符 作为key。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283. 移动零</title>
      <link href="/post/c150202b.html"/>
      <url>/post/c150202b.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/86dccd30c4424cccaf651f7c42d6becc.png" alt="86dccd30c4424cccaf651f7c42d6becc.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">283. 移动零</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[l++], nums[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>先把非0的元素移到前边，后边剩下的就是0了。<br>l：非0元素的末尾<br>r：0元素的开头</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="/post/d910afda.html"/>
      <url>/post/d910afda.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/30ceac9344b04484b321e1b32b48184f.png" alt="30ceac9344b04484b321e1b32b48184f.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = (n - <span class="number">1</span>) * <span class="built_in">min</span>(height[<span class="number">0</span>], height[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; r &gt; l;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt; height[r]) &#123; <span class="comment">// 移动更短的木棍</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, (r - l) * <span class="built_in">min</span>(height[l], height[r])); <span class="comment">// 每次记录当前遍历过的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>短板原理：可以容纳的水 &#x3D; min(height[l], height[r]) * (r - l)<br>因为可以容纳的水取决于高和宽，初始时，先让宽最大，即l &#x3D; 0，r &#x3D; n - 1，每次只要移动更短的木棍，虽然宽在缩小，但是有可能找到比当前更大的高。Z</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. 最长连续序列</title>
      <link href="/post/b4efa8b3.html"/>
      <url>/post/b4efa8b3.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/8bbb8394bc2c4ddfb91488e74e651c98.png" alt="8bbb8394bc2c4ddfb91488e74e651c98.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">ss</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s : ss) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ss.<span class="built_in">find</span>(s - <span class="number">1</span>) != ss.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 说明s一定不是开头</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s是开头</span></span><br><span class="line">            <span class="type">int</span> y = s + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(ss.<span class="built_in">find</span>(y) != ss.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(y - s, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>可以把这题理解成，有好多条不同长度的线段，要找到最长那条线，只需要找到所有线的线段头，从头开始计算。<br>例如：**[100,4,101,200,1,3,2]**<br>本题一共有三条线段，分别是：<code>100,101</code> 和 <code>200</code> 和 <code>1,2,3,4</code>，先把这些数存在set中，遍历set。<br>如果遍历到2，先判断2前面是否还有数字，由于2前边还有，说明2不是开头，直接跳过后续操作。<br>如果遍历到1，1前边已经没有数字了，说明1就是开头，从头开始计算，看看这个线段长度是多长。<br>这里虽然是两个循环，但是内循环只有遍历到线段头的时候才会执行，所以时间复杂度为O(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++算法</title>
      <link href="/post/6e93dd78.html"/>
      <url>/post/6e93dd78.html</url>
      
        <content type="html"><![CDATA[<h1 id="algorithm库函数"><a href="#algorithm库函数" class="headerlink" title="algorithm库函数"></a>algorithm库函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p><strong>排序</strong>：sort(beigin,end)   范围：[begin , end)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1.</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="comment">//一顿操作后...</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//例2.</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sort</span>(num,num<span class="number">+20</span>);</span><br></pre></td></tr></table></figure><p><strong>设置排序的规则</strong>：sort(begin,end,comp)</p><ul><li>comp相当于函数的函数名</li><li>bool comp(lhs,rhs)<ul><li>lhs、rhs是待排序元素</li><li>不发生交换：返回真</li><li>发生交换：返回假</li></ul></li></ul><blockquote><p>如果排序不是稳定的，但是题目要求定，可以加入int seq;用来记录录入的顺序，实现稳定排序</p></blockquote><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ol><li>关于字符数据的两种输入：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);<span class="comment">//只能读取一个单词（遇到空格停止）</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="built_in">fgets</span>(buf,<span class="number">100</span>,stdin);<span class="comment">//只能读取一整行（包括换行符）</span></span><br><span class="line"><span class="comment">//去掉末尾换行符：</span></span><br><span class="line">string str = buf;</span><br><span class="line">str.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li>C风格的字符串：字符数组（以’\0’结尾）<br>C++风格的字符串：string</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><ol start="3"><li>C风格&#x3D;&#x3D;&gt;C++风格： <code>str = char_str</code><br>C++风格&#x3D;&#x3D;&gt;C风格：<code>char_str = str.c_str()</code></li><li>输入输出都要先转化（都转成C风格的字符串）<ul><li>输入：<code>scanf(&quot;%s&quot;,char_str);</code></li><li>输出：<code>printf(&quot;%s&quot;,str.c_str());</code></li></ul></li></ol><blockquote><p>如果想用string[i] &#x3D; ‘h’来插入元素，必须先初始化大小：string s1(10,’c’); 否则会报异常</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;           <span class="comment">//默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;       <span class="comment">//s2是s1的副本(string类的拷贝构造)</span></span><br><span class="line">string s2 = s1;      <span class="comment">//等价于s2(s1)，s2是s1的副本(string类的拷贝赋值)</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;  <span class="comment">//s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外</span></span><br><span class="line">string s3 = <span class="string">&quot;value&quot;</span>; <span class="comment">//等价于s3(&quot;value&quot;)，s3是字面值&quot;value&quot;的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>;    <span class="comment">//把s4初始化为由连续n个字符c组成的串 </span></span><br></pre></td></tr></table></figure><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>判断相等：<code>str == &quot;hello&quot;</code></li><li>比较字典序：<code>str&gt;&quot;abandon&quot;</code></li><li>访问字符串长度：<code>str.size()</code> 或 <code>str.length()</code></li><li>访问字符串的每个元素：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.下标访问</span></span><br><span class="line"><span class="comment">// 2.迭代器访问</span></span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>();it!=str.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>连接操作：<code>+</code>（只对c++风格有效）</li><li>删除操作：<ul><li><code>str.erase(4)</code> 删除下标为4的元素</li><li><code>str.erase(str.size()-1)</code>删除最后一个元素</li></ul></li><li>清空操作：<code>str.clear()</code></li><li>字符串匹配：<code>find()</code>方法<ul><li>找到返回：匹配内容起点的下标</li><li>未找到返回：str::npos</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;how are you&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;are&quot;</span>)!=string::npos) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找到了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>字符串string截取：<code>str.substr(起始下标，截取长度)</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 得到el</span></span><br></pre></td></tr></table></figure><ol start="10"><li>数字转成字符串：<code>to_string(123);</code>&#x2F;&#x2F;“123”  &#x3D;&#x3D;&gt;返回string类型<ul><li>应用场景：如果想知道一个数字num的位数有几位，可以<code>to_string(num).size()</code></li></ul></li><li>字符串转成数字：<code>stoi(&quot;919&quot;);</code> &#x2F;&#x2F;919</li><li>字符串末尾加一个字符c：<code>str.push_back(c);</code></li><li>从字符串末尾弹出一个字符：<code>str.pop_back();</code></li><li>计算字符串某个字符数：<code>count(str.begin(),str.end(),&#39; &#39;);</code></li></ol><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>数组的限制：</p><ul><li>在定义的时候，就要指定大小（常量）</li><li>函数内部定义的数组不能太长（如果需要很长的，只能定义成全局变量）</li></ul><p>解决：引入向量（动态数组）</p><ul><li>顺序存储&#x2F;线性表</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br></pre></td></tr></table></figure><blockquote><p>如果想用vec[i] &#x3D; 5来插入元素，必须事先初始化大小：<code>vector&lt;int&gt; vec(10);</code> 否则会报异常</p></blockquote><hr><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="comment">// 给这100个地方都附上-1，即：&#123;-1,-1,-1,.....,-1&#125;</span></span><br><span class="line"><span class="built_in">fill</span>(vec<span class="number">2.</span><span class="built_in">begin</span>(),vec<span class="number">2.</span><span class="built_in">end</span>(),<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><h2 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>获取长度：<code>vec.size()</code> 或 <code>vec.length()</code></li><li>尾部扩容：<code>vec.push_back(1)</code></li><li>弹出最后一个元素：<code>vec.pop_back()</code></li><li>访问：<ul><li><code>vec[i]</code></li><li>迭代器访问：<ul><li><code>vec.begin()</code>：指向第一个元素</li><li><code>vec.end()</code>：指向最后一个元素的后一个元素</li></ul></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::it = vec.<span class="built_in">begin</span>();it&lt;vec.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>修改：<code>vec[i] = 3</code></li><li>随机位置的插入：<ul><li>假设有数组：1,2,3,4。在2号元素后面插入元素5，插入后&#x3D;&#x3D;&#x3D;&gt;1,2,5,3,4</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vec.begin<span class="number">+2</span>;<span class="comment">//找到3号元素的迭代器</span></span><br><span class="line">vec.<span class="built_in">insert</span>(it,<span class="number">5</span>);<span class="comment">//在3号元素的前面插入5</span></span><br></pre></td></tr></table></figure><ol start="7"><li>随机位置的删除：<ul><li>假设有数组：1,2,3,4。删除2号元素，删除后&#x3D;&#x3D;&#x3D;&gt;1,3,4</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vec.begin<span class="number">+1</span>;<span class="comment">//找到2号元素的迭代器</span></span><br><span class="line">vec.<span class="built_in">erase</span>(it);<span class="comment">//删除2号元素</span></span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map的底层是二叉搜索树：构建O(nlogn)、查找O(logn)<br><code>map&lt;string,int&gt; myMap;</code></p><h2 id="常见操作-2"><a href="#常见操作-2" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>判空：<code>myMap.empty()</code></li><li>获取键值对的个数：<code>myMap.size()</code></li><li>插入一对键值对：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap[<span class="string">&quot;xiaolin&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;03&quot;</span>,<span class="number">3</span>));</span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;33&quot;</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>删除一对键值对：<code>myMap.erase(&quot;xiaolin&quot;);</code></li><li>键值对的个数：<code>myMap.size();</code></li><li>迭代器：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt;::iterator beginIt = myMap.<span class="built_in">begin</span>(); <span class="comment">// 指向第一个元素</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::iterator endIt = myMap.<span class="built_in">end</span>();   <span class="comment">//指向最后一个元素的后一个元素（尾后）</span></span><br></pre></td></tr></table></figure><ol start="7"><li>遍历：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::iterator it = myMap.<span class="built_in">begin</span>();it!=myMap.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%c,value=%d&quot;</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; myMap;</span><br><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::iterator it = myMap.<span class="built_in">begin</span>();it!=myMap.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%c,value=%d&quot;</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;[key,value] : myMap) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%c,value=%d&quot;</span>,key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>某个键是否存在：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(myMap.<span class="built_in">find</span>(<span class="string">&quot;xiaolin&quot;</span>) == myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br></pre></td></tr></table></figure><h2 id="常见操作-3"><a href="#常见操作-3" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>插入：<code>s.insert(333);</code> 往集合中添加元素，它的参数也是只有一个，就是你想要添加的元素，无返回值。</li><li>删除：<code>s.erase(333);</code> 用来删除指定的元素，参数只有一个，并且是你想要删除的元素，无返回值</li><li>查找在集合中出现的元素个数：<code>s.count(333); </code> 因为集合的互异性，它的返回值要么是1要么是0，一般也可以用它来判断某个元素是否在该集合中。</li><li>查找某元素是否在集合中：<code>find()</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&quot;33&quot;</span>)!=s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在集合中&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不在集合中&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>得出集合中的元素个数：<code>s.size()</code></li><li>判断该集合是否为空：<code>s.empty()</code></li><li>清空集合中的元素：<code>a.clear()</code></li><li>遍历：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:s) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();it&lt;s.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>栈：先进后出（场景：“优先级差别”等待）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; myStack;</span><br></pre></td></tr></table></figure><ol><li>大小：<code>size()</code></li><li>压栈：<code>push()</code></li><li>取栈顶元素：top()&#96;</li><li>弹栈：<code>pop()</code></li><li>判断栈是否为空：<code>empty()</code></li></ol><h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; myQueue;</span><br></pre></td></tr></table></figure><ol><li>入队：push</li><li>出队：pop</li><li>判断为空：empty</li><li>队首元素：front</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql语法中not in会把null值过滤掉</title>
      <link href="/post/cfa2118.html"/>
      <url>/post/cfa2118.html</url>
      
        <content type="html"><![CDATA[<p>null在SQL中表示“未知”或“不存在”，所以not in会认为null是一个具体的值，需要被排除。</p><hr><p>在这个查询中，所有的column列为null值得都会被排除。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> temp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span> <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><hr><p>如果不希望not in过滤null值，可以使用 <strong>not in 结合 or</strong> </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> temp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>) </span><br><span class="line">      <span class="keyword">or</span> <span class="keyword">column</span> <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
            <tag> null值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本的ResultMap</title>
      <link href="/post/d634e4f9.html"/>
      <url>/post/d634e4f9.html</url>
      
        <content type="html"><![CDATA[<p>在 MyBatis 中，resultMap用来将数据库查询结果映射到 Java 对象。定义了如何将 SQL 查询结果的列与 Java 对象的属性进行映射。它支持复杂的映射关系，如一对多、多对一等。</p><hr><h1 id="基本的ResultMap"><a href="#基本的ResultMap" class="headerlink" title="基本的ResultMap"></a>基本的ResultMap</h1><p>假设有一个User类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>id表示主键映射，通常对应数据库表中的主键字段。【<strong>要放在第一行</strong>】</p><p>result表示普通字段映射，property是Java类的属性，column是数据库表中的列名</p><p>上边的resultMap对应的select语句就可以这么写：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id &quot;user_id&quot;, username &quot;user_name&quot;</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h2 id="开启autoMapping映射"><a href="#开启autoMapping映射" class="headerlink" title="开启autoMapping映射"></a>开启autoMapping映射</h2><p>autoMapping映射是一种自动映射机制，用于自动将 SQL 查询结果的列与 Java 对象的属性进行匹配。它简化了映射的配置，不需要显式地为每个属性定义映射关系。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上边的resultMap对应的select语句就可以这么写：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, username</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在启用了 <code>autoMapping</code> 后，<code>user_id</code> 会自动映射到 <code>userId</code>。</p></blockquote><h1 id="复杂的ResultMap"><a href="#复杂的ResultMap" class="headerlink" title="复杂的ResultMap"></a>复杂的ResultMap</h1><h2 id="一对多映射-collection"><a href="#一对多映射-collection" class="headerlink" title="一对多映射[collection]"></a>一对多映射[collection]</h2><p>场景：有一个user对象，和一个Order对象，一个用户可以有多个订单。</p><p>一个User类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String User;</span><br><span class="line">    List&lt;Order&gt; orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date orderDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>User</code> 类有一个 <code>orders</code> 属性（一个 <code>List&lt;Order&gt;</code>）。<code>collection</code> 元素用于指定一对多的映射关系，<code>ofType</code> 属性指定集合中元素的类型。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Mybatis-Plus的分页插件进行分页查询时，如果结果需要使用<code>&lt;collection&gt;</code>进行映射，只能使用<strong>嵌套查询</strong>，而不能使用嵌套结果映射。</p><h2 id="多对一映射-association"><a href="#多对一映射-association" class="headerlink" title="多对一映射[association]"></a>多对一映射[association]</h2><p>场景：有一个 <code>Order</code> 对象，它关联到一个 <code>User</code> 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String User;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date orderDate;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Order</code> 对象的 <code>user</code> 属性是通过 <code>association</code> 映射的，它表示多对一关系。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ResultMap中的属性"><a href="#ResultMap中的属性" class="headerlink" title="ResultMap中的属性"></a>ResultMap中的属性</h1><ul><li><strong>property</strong>：映射的 Java 类的属性名称。</li><li><strong>column</strong>：数据库表中的列名。</li><li><strong>javaType</strong>：用于指定映射的 Java 类型。</li><li><strong>typeHandler</strong>：用于指定类型处理器，处理数据库列和 Java 属性之间的转换。</li><li><strong>ofType</strong>：用于集合映射时，指定集合中元素的类型。</li><li><strong>association</strong>：用于表示一对多或多对一关系映射。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> ResultMap </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
