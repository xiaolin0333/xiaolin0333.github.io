<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2379. 得到 K 个黑块的最少涂色次数</title>
      <link href="/post/43089fc2.html"/>
      <url>/post/43089fc2.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/25a2e86292cd4c6fa7ce290bd2052c3b.png" alt="25a2e86292cd4c6fa7ce290bd2052c3b.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description/">2379. 得到 K 个黑块的最少涂色次数</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = blocks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> curWcount = <span class="number">0</span>; <span class="comment">// 记录窗口内W字符的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; blocks.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(blocks[r] == <span class="string">&#x27;W&#x27;</span>) &#123; <span class="comment">// 滑窗内有字符W</span></span><br><span class="line">                curWcount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, curWcount);</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                <span class="keyword">if</span>(blocks[l++] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    curWcount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>题目想要求把白色块变成黑色块使得有k个连续的黑色块的最小次数，也就是求滑窗内白色块出现的最小次数。只要统计长度为k的滑窗内最少的白色字符数即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2090. 半径为 k 的子数组平均值</title>
      <link href="/post/8b141577.html"/>
      <url>/post/8b141577.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/12af681c4bc24b7b8e5d1c3c4b39190d.png" alt="12af681c4bc24b7b8e5d1c3c4b39190d.png"><br>【题目】：<a href="https://leetcode.cn/problems/k-radius-subarray-averages/">2090. 半径为 k 的子数组平均值</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> curSum = <span class="number">0</span>; <span class="comment">// 记录当前滑窗内的数值和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            curSum += nums[r];</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k * <span class="number">2</span> + <span class="number">1</span>) &#123; <span class="comment">// 窗口长度满足条件</span></span><br><span class="line">                res[r - k] = curSum / (k * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">// 当长度满足时，此时对应的半径中心坐标是：r - k</span></span><br><span class="line">                curSum -= nums[l++]; <span class="comment">// 缩小窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>半径为 k 的子数组：说明滑窗的长度（r - l + 1）必须要达到2 * k + 1。但是当r下标到达半径中心的时候，还不知道此时数组内元素和，所以可以等到滑窗长度达到条件时，再去反推半径中心。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1461. 检查一个字符串是否包含所有长度为 K 的二进制子串</title>
      <link href="/post/b541a47.html"/>
      <url>/post/b541a47.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/ebb6bd124ee440cab48c47a7395956d3.png" alt="ebb6bd124ee440cab48c47a7395956d3.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/check-if-a-string-contains-all-binary-codes-of-size-k/description/">1461. 检查一个字符串是否包含所有长度为 K 的二进制子串</a></p><p> 直接存储滑动窗口内的字符串，这样虽然方便，但是时间复杂度和k相关，如果k &#x3D; n，此时会达到O(n^2)的复杂度。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasAllCodes</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; ss;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">                ss.<span class="built_in">insert</span>(s.<span class="built_in">substr</span>(l, k));</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">size</span>() == <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n*k)</li><li>空间复杂度: O(1&lt;&lt;k)</li></ul><blockquote><p>1&lt;&lt;k：相当于pow(2, k)<br>substr(截取的字符串起始位置, 截取字符串的长度)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1456. 定长子串中元音的最大数目</title>
      <link href="/post/6afae9e.html"/>
      <url>/post/6afae9e.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/8ef7122a0698439c80ae7f976c73683b.png" alt="8ef7122a0698439c80ae7f976c73683b.png"><br>【链接】：<a href="https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/">1456. 定长子串中元音的最大数目</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxVowels</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录整个过程中的最大值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 记录当前滑动窗口内元音字母的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123; <span class="comment">// 右侧元素进入窗口</span></span><br><span class="line">        <span class="comment">// 上来先判断是否是元音字母</span></span><br><span class="line">            <span class="keyword">if</span>(s[r] == <span class="string">&#x27;a&#x27;</span> || s[r] == <span class="string">&#x27;e&#x27;</span> || s[r] == <span class="string">&#x27;i&#x27;</span> || s[r] == <span class="string">&#x27;o&#x27;</span> || s[r] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(count, res); </span><br><span class="line">            <span class="comment">// 看看是否超过了窗口的长度</span></span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">            <span class="comment">// 左边要离开滑动窗口，看看s[l]是否是元音字母</span></span><br><span class="line">                <span class="keyword">if</span>(s[l] == <span class="string">&#x27;a&#x27;</span> || s[l] == <span class="string">&#x27;e&#x27;</span> || s[l] == <span class="string">&#x27;i&#x27;</span> || s[l] == <span class="string">&#x27;o&#x27;</span> || s[l] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++; <span class="comment">// 左侧元素离开窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>这是一个<code>定长滑动窗口</code>的题，一般会有l、r两个指针，这一过程主要有三个问题：</p><ol><li>右侧元素进入窗口：只要r &lt; s.size()，每次都会进入窗口</li><li>左侧元素离开窗口：当前窗口长度 &#x3D; k</li><li>更新res的最大值</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1343. 大小为 K 且平均值大于等于阈值的子数组数目</title>
      <link href="/post/e9cb7dc4.html"/>
      <url>/post/e9cb7dc4.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/9a7f8baf21f243779595bc6a89f043be.png" alt="9a7f8baf21f243779595bc6a89f043be.png"><br>【题目】：<a href="https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/">1343. 大小为 K 且平均值大于等于阈值的子数组数目</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numOfSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> k, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 计算满足条件的数</span></span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>; <span class="comment">// 计算当前滑窗内的总数</span></span><br><span class="line">        <span class="type">int</span> targetSum = k * threshold; <span class="comment">// 当前滑窗内的总数满足条件的最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; arr.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            curSum += arr[r];</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123; <span class="comment">// 条件1. 长度为k</span></span><br><span class="line">                <span class="keyword">if</span>(curSum &gt;= targetSum) &#123; <span class="comment">// 条件2. 平均值大于等于threshold</span></span><br><span class="line">                    ++count;<span class="comment">// 满足条件1和2</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 缩小窗口</span></span><br><span class="line">                curSum -= arr[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题有两个条件，长度为k、平均值大于等于threshold。所以需要依次满足这两个条件后，才能更新count值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1052. 爱生气的书店老板</title>
      <link href="/post/cc4621fb.html"/>
      <url>/post/cc4621fb.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/bf841e57b01a4e23bf1a35d4d00f5e23.png" alt="bf841e57b01a4e23bf1a35d4d00f5e23.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/grumpy-bookstore-owner/description/">1052. 爱生气的书店老板</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSatisfied</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; customers, vector&lt;<span class="type">int</span>&gt;&amp; grumpy, <span class="type">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxAddCount = <span class="number">0</span>; <span class="comment">// 在minutes长度内，还能增加的最大顾客满意人数</span></span><br><span class="line">        <span class="type">int</span> curAddCount = <span class="number">0</span>; <span class="comment">// 当前窗口内还能增加的顾客满意数</span></span><br><span class="line">        <span class="type">int</span> curCount = <span class="number">0</span>; <span class="comment">// 原本有的顾客满意数</span></span><br><span class="line">        <span class="type">int</span> n = customers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; n; ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grumpy[r] == <span class="number">1</span>) &#123; <span class="comment">// 把老板从生气变成不生气</span></span><br><span class="line">                curAddCount += customers[r]; </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                curCount += customers[r]; <span class="comment">// 原有的顾客满意数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == minutes) &#123;</span><br><span class="line">                maxAddCount = <span class="built_in">max</span>(maxAddCount, curAddCount);</span><br><span class="line">                <span class="keyword">if</span>(grumpy[l] == <span class="number">1</span>) &#123;</span><br><span class="line">                    curAddCount -= customers[l];</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAddCount + curCount; <span class="comment">// 当天内最大顾客满意数 = 可以增加的最大顾客满意数 + 原本有的顾客满意数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>当天内最大顾客满意数 &#x3D; 可以增加的最大顾客满意数 + 原本有的顾客满意数<br>原本有的顾客满意数是动不了的，所以只需要求可以增加的最大顾客满意数。<br>书店老板可以让自己连续minutes分钟不生气，说明滑动窗口的长度为minutes<br>所以本题只需要求在minutes的滑动窗口内，可以增加的最大顾客满意数，即在滑动窗口内，可以从grumpy[i]为1变为0后增加的最大顾客满意数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>643. 子数组最大平均数 I</title>
      <link href="/post/9730100f.html"/>
      <url>/post/9730100f.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/092c3f51831e422ead89e06101ad7c9f.png" alt="092c3f51831e422ead89e06101ad7c9f.png"><br>【链接】：<a href="https://blog.csdn.net/qq_57882997/article/details/145240772?spm=1001.2014.3001.5501">643. 子数组最大平均数 I</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMaxAverage</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxSum = INT_MIN, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            curSum += nums[r]; <span class="comment">// 更新curSum</span></span><br><span class="line">            <span class="keyword">if</span>(r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">                maxSum = <span class="built_in">max</span>(maxSum, curSum); <span class="comment">// 更新maxSum(因为题目要求长度为k，所以需要在这里更新maxSum)</span></span><br><span class="line">                curSum -= nums[l]; <span class="comment">// 扣除左侧元素（保持一致）</span></span><br><span class="line">                ++l; <span class="comment">// 左侧元素离开</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum / (<span class="type">double</span>)k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><blockquote><p>题目关键字：连续子数组，说明可以采用滑动窗口。<br>maxSum的初始值：因为数组内有负数，maxSum的初始值不应该设置成0，应该设置为int的最小值。<br>更新的位置：因为题目说明长度必须要为k，所以更新的位置应该在if里边，长度为k时才进行更新。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 三数之和</title>
      <link href="/post/e192590d.html"/>
      <url>/post/e192590d.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/7c3fb12fc1d241d4af62180ff5fc4b04.png" alt="7c3fb12fc1d241d4af62180ff5fc4b04.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked">15. 三数之和</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 因为是升序排列，如果当前数&gt;0，三数值和一定&gt;0，后边的数字都可以做剪枝</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 去除重复的三元组</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line">            <span class="comment">// -4,-1,-1,0,1,2</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>; l &lt; r;) &#123;</span><br><span class="line">                <span class="type">int</span> cur = nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span>(target == cur) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l + <span class="number">1</span>]) ++l;</span><br><span class="line">                    <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r - <span class="number">1</span>]) --r;</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; cur) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n^2)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>这题要求不能重复的三元组，只要三元组的三个数是按照顺序进行排列的，这样就可以不用借助set来去充了。<br>所以可以先把数组进行排序，用i指针从头到尾遍历数组，遍历的时候可以利用三元组和为0的特性进行剪枝。如果i遍历的元素已经是&gt;0，但是数组又是升序排列，后边不可能有和&lt;0的数字，所以当i遍历到元素&gt;0时，直接break。<br>遍历的时候要注意，可能会有相同的数字连续出现多次。<br>情况1. nums[i] &#x3D;&#x3D; nums[i - 1]，这种情况可以直接continue。<br>情况2. 当已经找到一个三元组后，可能nums[l] &#x3D;&#x3D; nums[l + 1]，此时都应该使用while循环（可能有多个）排除在外。但是要注意，退出循环的时候，如果是nums[l] !&#x3D; nums[l + 1]，但是此时nums[l] &#x3D;&#x3D; nums[l - 1]，这样就会出现死循环。所以一定要在推出while循环后再做一次++l的操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;tags:</span><br><span class="line"> - 算法</span><br><span class="line"> - LeetCode热题100</span><br><span class="line"> - 双指针</span><br><span class="line">&gt;categories: LeetCode热题100</span><br><span class="line">&gt;type: LeetCode热题100</span><br><span class="line">&gt;top_img: false</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>49. 字母异位词分组</title>
      <link href="/post/b390ba48.html"/>
      <url>/post/b390ba48.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/550eba79e4d6445a801eec931869ca85.png" alt="550eba79e4d6445a801eec931869ca85.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/group-anagrams/description/?envType=study-plan-v2&envId=top-100-liked">49. 字母异位词分组</a></p><p>方法1：直接对字符串进行排序后使用map存储相同的字母异位词，再把map的value依次存放到结果中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(string str : strs) &#123;</span><br><span class="line">            string temp = str;</span><br><span class="line">            <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">            mp[str].<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [key, value] : mp) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n<em>k</em>logk)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>字母异位词对应的排序后的字符串是一样的，所以把每个字符串排序后插入以排序后字符串作为key，以原字符串作为value的map中。这个方法虽然简洁，但是取决于每个字符串的长度，排序的时间复杂度是k * logk</p></blockquote><p>方法2：自定义哈希函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(string str : strs) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : str) &#123;</span><br><span class="line">                count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            string key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                key += count[i] + i + <span class="string">&#x27;a&#x27;</span>;<span class="comment">// 使用：每个字符出现的次数 + 字符 作为key</span></span><br><span class="line">            &#125;</span><br><span class="line">            mp[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [key, value] : mp) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n*max(k, 26))</li><li>空间复杂度: O(n)</li></ul><blockquote><p>使用每个字符出现的次数 + 字符 作为key。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>283. 移动零</title>
      <link href="/post/c150202b.html"/>
      <url>/post/c150202b.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/86dccd30c4424cccaf651f7c42d6becc.png" alt="86dccd30c4424cccaf651f7c42d6becc.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked">283. 移动零</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[r] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[l++], nums[r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>先把非0的元素移到前边，后边剩下的就是0了。<br>l：非0元素的末尾<br>r：0元素的开头</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="/post/d910afda.html"/>
      <url>/post/d910afda.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/30ceac9344b04484b321e1b32b48184f.png" alt="30ceac9344b04484b321e1b32b48184f.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/container-with-most-water/description/?envType=study-plan-v2&envId=top-100-liked">11. 盛最多水的容器</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = (n - <span class="number">1</span>) * <span class="built_in">min</span>(height[<span class="number">0</span>], height[n - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; r &gt; l;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(height[l] &lt; height[r]) &#123; <span class="comment">// 移动更短的木棍</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, (r - l) * <span class="built_in">min</span>(height[l], height[r])); <span class="comment">// 每次记录当前遍历过的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(1)</li></ul><blockquote><p>短板原理：可以容纳的水 &#x3D; min(height[l], height[r]) * (r - l)<br>因为可以容纳的水取决于高和宽，初始时，先让宽最大，即l &#x3D; 0，r &#x3D; n - 1，每次只要移动更短的木棍，虽然宽在缩小，但是有可能找到比当前更大的高。Z</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>128. 最长连续序列</title>
      <link href="/post/b4efa8b3.html"/>
      <url>/post/b4efa8b3.html</url>
      
        <content type="html"><![CDATA[<p><img src="/assets/8bbb8394bc2c4ddfb91488e74e651c98.png" alt="8bbb8394bc2c4ddfb91488e74e651c98.png"></p><p>【题目】：<a href="https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked">128. 最长连续序列</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">ss</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s : ss) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ss.<span class="built_in">find</span>(s - <span class="number">1</span>) != ss.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 说明s一定不是开头</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s是开头</span></span><br><span class="line">            <span class="type">int</span> y = s + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(ss.<span class="built_in">find</span>(y) != ss.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(y - s, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(n)</li></ul><blockquote><p>可以把这题理解成，有好多条不同长度的线段，要找到最长那条线，只需要找到所有线的线段头，从头开始计算。<br>例如：**[100,4,101,200,1,3,2]**<br>本题一共有三条线段，分别是：<code>100,101</code> 和 <code>200</code> 和 <code>1,2,3,4</code>，先把这些数存在set中，遍历set。<br>如果遍历到2，先判断2前面是否还有数字，由于2前边还有，说明2不是开头，直接跳过后续操作。<br>如果遍历到1，1前边已经没有数字了，说明1就是开头，从头开始计算，看看这个线段长度是多长。<br>这里虽然是两个循环，但是内循环只有遍历到线段头的时候才会执行，所以时间复杂度为O(n)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode热题100 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode热题100 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++算法</title>
      <link href="/post/6e93dd78.html"/>
      <url>/post/6e93dd78.html</url>
      
        <content type="html"><![CDATA[<h1 id="algorithm库函数"><a href="#algorithm库函数" class="headerlink" title="algorithm库函数"></a>algorithm库函数</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><p><strong>排序</strong>：sort(beigin,end)   范围：[begin , end)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例1.</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="comment">//一顿操作后...</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//例2.</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sort</span>(num,num<span class="number">+20</span>);</span><br></pre></td></tr></table></figure><p><strong>设置排序的规则</strong>：sort(begin,end,comp)</p><ul><li>comp相当于函数的函数名</li><li>bool comp(lhs,rhs)<ul><li>lhs、rhs是待排序元素</li><li>不发生交换：返回真</li><li>发生交换：返回假</li></ul></li></ul><blockquote><p>如果排序不是稳定的，但是题目要求定，可以加入int seq;用来记录录入的顺序，实现稳定排序</p></blockquote><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ol><li>关于字符数据的两种输入：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);<span class="comment">//只能读取一个单词（遇到空格停止）</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="built_in">fgets</span>(buf,<span class="number">100</span>,stdin);<span class="comment">//只能读取一整行（包括换行符）</span></span><br><span class="line"><span class="comment">//去掉末尾换行符：</span></span><br><span class="line">string str = buf;</span><br><span class="line">str.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li>C风格的字符串：字符数组（以’\0’结尾）<br>C++风格的字符串：string</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><ol start="3"><li>C风格&#x3D;&#x3D;&gt;C++风格： <code>str = char_str</code><br>C++风格&#x3D;&#x3D;&gt;C风格：<code>char_str = str.c_str()</code></li><li>输入输出都要先转化（都转成C风格的字符串）<ul><li>输入：<code>scanf(&quot;%s&quot;,char_str);</code></li><li>输出：<code>printf(&quot;%s&quot;,str.c_str());</code></li></ul></li></ol><blockquote><p>如果想用string[i] &#x3D; ‘h’来插入元素，必须先初始化大小：string s1(10,’c’); 否则会报异常</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1;           <span class="comment">//默认初始化，s1是一个空串</span></span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(s1)</span></span>;       <span class="comment">//s2是s1的副本(string类的拷贝构造)</span></span><br><span class="line">string s2 = s1;      <span class="comment">//等价于s2(s1)，s2是s1的副本(string类的拷贝赋值)</span></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(<span class="string">&quot;value&quot;</span>)</span></span>;  <span class="comment">//s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外</span></span><br><span class="line">string s3 = <span class="string">&quot;value&quot;</span>; <span class="comment">//等价于s3(&quot;value&quot;)，s3是字面值&quot;value&quot;的副本</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(n,<span class="string">&#x27;c&#x27;</span>)</span></span>;    <span class="comment">//把s4初始化为由连续n个字符c组成的串 </span></span><br></pre></td></tr></table></figure><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>判断相等：<code>str == &quot;hello&quot;</code></li><li>比较字典序：<code>str&gt;&quot;abandon&quot;</code></li><li>访问字符串长度：<code>str.size()</code> 或 <code>str.length()</code></li><li>访问字符串的每个元素：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.下标访问</span></span><br><span class="line"><span class="comment">// 2.迭代器访问</span></span><br><span class="line"><span class="keyword">for</span>(string::iterator it = str.<span class="built_in">begin</span>();it!=str.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>连接操作：<code>+</code>（只对c++风格有效）</li><li>删除操作：<ul><li><code>str.erase(4)</code> 删除下标为4的元素</li><li><code>str.erase(str.size()-1)</code>删除最后一个元素</li></ul></li><li>清空操作：<code>str.clear()</code></li><li>字符串匹配：<code>find()</code>方法<ul><li>找到返回：匹配内容起点的下标</li><li>未找到返回：str::npos</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;how are you&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;are&quot;</span>)!=string::npos) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找到了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>字符串string截取：<code>str.substr(起始下标，截取长度)</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 得到el</span></span><br></pre></td></tr></table></figure><ol start="10"><li>数字转成字符串：<code>to_string(123);</code>&#x2F;&#x2F;“123”  &#x3D;&#x3D;&gt;返回string类型<ul><li>应用场景：如果想知道一个数字num的位数有几位，可以<code>to_string(num).size()</code></li></ul></li><li>字符串转成数字：<code>stoi(&quot;919&quot;);</code> &#x2F;&#x2F;919</li><li>字符串末尾加一个字符c：<code>str.push_back(c);</code></li><li>从字符串末尾弹出一个字符：<code>str.pop_back();</code></li><li>计算字符串某个字符数：<code>count(str.begin(),str.end(),&#39; &#39;);</code></li></ol><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>数组的限制：</p><ul><li>在定义的时候，就要指定大小（常量）</li><li>函数内部定义的数组不能太长（如果需要很长的，只能定义成全局变量）</li></ul><p>解决：引入向量（动态数组）</p><ul><li>顺序存储&#x2F;线性表</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br></pre></td></tr></table></figure><blockquote><p>如果想用vec[i] &#x3D; 5来插入元素，必须事先初始化大小：<code>vector&lt;int&gt; vec(10);</code> 否则会报异常</p></blockquote><hr><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">100</span>)</span></span>; </span><br><span class="line"><span class="comment">// 给这100个地方都附上-1，即：&#123;-1,-1,-1,.....,-1&#125;</span></span><br><span class="line"><span class="built_in">fill</span>(vec<span class="number">2.</span><span class="built_in">begin</span>(),vec<span class="number">2.</span><span class="built_in">end</span>(),<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><h2 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>获取长度：<code>vec.size()</code> 或 <code>vec.length()</code></li><li>尾部扩容：<code>vec.push_back(1)</code></li><li>弹出最后一个元素：<code>vec.pop_back()</code></li><li>访问：<ul><li><code>vec[i]</code></li><li>迭代器访问：<ul><li><code>vec.begin()</code>：指向第一个元素</li><li><code>vec.end()</code>：指向最后一个元素的后一个元素</li></ul></li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::it = vec.<span class="built_in">begin</span>();it&lt;vec.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>修改：<code>vec[i] = 3</code></li><li>随机位置的插入：<ul><li>假设有数组：1,2,3,4。在2号元素后面插入元素5，插入后&#x3D;&#x3D;&#x3D;&gt;1,2,5,3,4</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vec.begin<span class="number">+2</span>;<span class="comment">//找到3号元素的迭代器</span></span><br><span class="line">vec.<span class="built_in">insert</span>(it,<span class="number">5</span>);<span class="comment">//在3号元素的前面插入5</span></span><br></pre></td></tr></table></figure><ol start="7"><li>随机位置的删除：<ul><li>假设有数组：1,2,3,4。删除2号元素，删除后&#x3D;&#x3D;&#x3D;&gt;1,3,4</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = vec.begin<span class="number">+1</span>;<span class="comment">//找到2号元素的迭代器</span></span><br><span class="line">vec.<span class="built_in">erase</span>(it);<span class="comment">//删除2号元素</span></span><br></pre></td></tr></table></figure><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map的底层是二叉搜索树：构建O(nlogn)、查找O(logn)<br><code>map&lt;string,int&gt; myMap;</code></p><h2 id="常见操作-2"><a href="#常见操作-2" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>判空：<code>myMap.empty()</code></li><li>获取键值对的个数：<code>myMap.size()</code></li><li>插入一对键值对：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myMap[<span class="string">&quot;xiaolin&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">myMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;(<span class="string">&quot;03&quot;</span>,<span class="number">3</span>));</span><br><span class="line">myMap.<span class="built_in">insert</span>(&#123;<span class="string">&quot;33&quot;</span>, <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure><ol start="4"><li>删除一对键值对：<code>myMap.erase(&quot;xiaolin&quot;);</code></li><li>键值对的个数：<code>myMap.size();</code></li><li>迭代器：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt;::iterator beginIt = myMap.<span class="built_in">begin</span>(); <span class="comment">// 指向第一个元素</span></span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::iterator endIt = myMap.<span class="built_in">end</span>();   <span class="comment">//指向最后一个元素的后一个元素（尾后）</span></span><br></pre></td></tr></table></figure><ol start="7"><li>遍历：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::iterator it = myMap.<span class="built_in">begin</span>();it!=myMap.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%c,value=%d&quot;</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; myMap;</span><br><span class="line"><span class="comment">// 法1</span></span><br><span class="line"><span class="keyword">for</span>(map&lt;string,<span class="type">int</span>&gt;::iterator it = myMap.<span class="built_in">begin</span>();it!=myMap.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%c,value=%d&quot;</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 法2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp;[key,value] : myMap) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%c,value=%d&quot;</span>,key,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>某个键是否存在：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(myMap.<span class="built_in">find</span>(<span class="string">&quot;xiaolin&quot;</span>) == myMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br></pre></td></tr></table></figure><h2 id="常见操作-3"><a href="#常见操作-3" class="headerlink" title="常见操作"></a>常见操作</h2><ol><li>插入：<code>s.insert(333);</code> 往集合中添加元素，它的参数也是只有一个，就是你想要添加的元素，无返回值。</li><li>删除：<code>s.erase(333);</code> 用来删除指定的元素，参数只有一个，并且是你想要删除的元素，无返回值</li><li>查找在集合中出现的元素个数：<code>s.count(333); </code> 因为集合的互异性，它的返回值要么是1要么是0，一般也可以用它来判断某个元素是否在该集合中。</li><li>查找某元素是否在集合中：<code>find()</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&quot;33&quot;</span>)!=s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在集合中&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;不在集合中&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>得出集合中的元素个数：<code>s.size()</code></li><li>判断该集合是否为空：<code>s.empty()</code></li><li>清空集合中的元素：<code>a.clear()</code></li><li>遍历：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i:s) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：</span></span><br><span class="line"><span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>();it&lt;s.<span class="built_in">end</span>();++it) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>栈：先进后出（场景：“优先级差别”等待）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; myStack;</span><br></pre></td></tr></table></figure><ol><li>大小：<code>size()</code></li><li>压栈：<code>push()</code></li><li>取栈顶元素：top()&#96;</li><li>弹栈：<code>pop()</code></li><li>判断栈是否为空：<code>empty()</code></li></ol><h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; myQueue;</span><br></pre></td></tr></table></figure><ol><li>入队：push</li><li>出队：pop</li><li>判断为空：empty</li><li>队首元素：front</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql语法中not in会把null值过滤掉</title>
      <link href="/post/cfa2118.html"/>
      <url>/post/cfa2118.html</url>
      
        <content type="html"><![CDATA[<p>null在SQL中表示“未知”或“不存在”，所以not in会认为null是一个具体的值，需要被排除。</p><hr><p>在这个查询中，所有的column列为null值得都会被排除。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> temp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span> <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><hr><p>如果不希望not in过滤null值，可以使用 <strong>not in 结合 or</strong> </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> temp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">column</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>) </span><br><span class="line">      <span class="keyword">or</span> <span class="keyword">column</span> <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> null值 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本的ResultMap</title>
      <link href="/post/d634e4f9.html"/>
      <url>/post/d634e4f9.html</url>
      
        <content type="html"><![CDATA[<p>在 MyBatis 中，resultMap用来将数据库查询结果映射到 Java 对象。定义了如何将 SQL 查询结果的列与 Java 对象的属性进行映射。它支持复杂的映射关系，如一对多、多对一等。</p><hr><h1 id="基本的ResultMap"><a href="#基本的ResultMap" class="headerlink" title="基本的ResultMap"></a>基本的ResultMap</h1><p>假设有一个User类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>id表示主键映射，通常对应数据库表中的主键字段。【<strong>要放在第一行</strong>】</p><p>result表示普通字段映射，property是Java类的属性，column是数据库表中的列名</p><p>上边的resultMap对应的select语句就可以这么写：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id &quot;user_id&quot;, username &quot;user_name&quot;</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><h2 id="开启autoMapping映射"><a href="#开启autoMapping映射" class="headerlink" title="开启autoMapping映射"></a>开启autoMapping映射</h2><p>autoMapping映射是一种自动映射机制，用于自动将 SQL 查询结果的列与 Java 对象的属性进行匹配。它简化了映射的配置，不需要显式地为每个属性定义映射关系。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上边的resultMap对应的select语句就可以这么写：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, username</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在启用了 <code>autoMapping</code> 后，<code>user_id</code> 会自动映射到 <code>userId</code>。</p></blockquote><h1 id="复杂的ResultMap"><a href="#复杂的ResultMap" class="headerlink" title="复杂的ResultMap"></a>复杂的ResultMap</h1><h2 id="一对多映射-collection"><a href="#一对多映射-collection" class="headerlink" title="一对多映射[collection]"></a>一对多映射[collection]</h2><p>场景：有一个user对象，和一个Order对象，一个用户可以有多个订单。</p><p>一个User类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String User;</span><br><span class="line">    List&lt;Order&gt; orders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date orderDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>User</code> 类有一个 <code>orders</code> 属性（一个 <code>List&lt;Order&gt;</code>）。<code>collection</code> 元素用于指定一对多的映射关系，<code>ofType</code> 属性指定集合中元素的类型。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">autoMapping</span> = <span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用Mybatis-Plus的分页插件进行分页查询时，如果结果需要使用<code>&lt;collection&gt;</code>进行映射，只能使用<strong>嵌套查询</strong>，而不能使用嵌套结果映射。</p><h2 id="多对一映射-association"><a href="#多对一映射-association" class="headerlink" title="多对一映射[association]"></a>多对一映射[association]</h2><p>场景：有一个 <code>Order</code> 对象，它关联到一个 <code>User</code> 对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String User;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Date orderDate;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Order</code> 对象的 <code>user</code> 属性是通过 <code>association</code> 映射的，它表示多对一关系。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Order&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">autoMapping</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="ResultMap中的属性"><a href="#ResultMap中的属性" class="headerlink" title="ResultMap中的属性"></a>ResultMap中的属性</h1><ul><li><strong>property</strong>：映射的 Java 类的属性名称。</li><li><strong>column</strong>：数据库表中的列名。</li><li><strong>javaType</strong>：用于指定映射的 Java 类型。</li><li><strong>typeHandler</strong>：用于指定类型处理器，处理数据库列和 Java 属性之间的转换。</li><li><strong>ofType</strong>：用于集合映射时，指定集合中元素的类型。</li><li><strong>association</strong>：用于表示一对多或多对一关系映射。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> ResultMap </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生命周期&amp;数据共享</title>
      <link href="/post/567bfae1.html"/>
      <url>/post/567bfae1.html</url>
      
        <content type="html"><![CDATA[<h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><h2 id="生命周期-生命周期函数"><a href="#生命周期-生命周期函数" class="headerlink" title="生命周期&amp;生命周期函数"></a>生命周期&amp;生命周期函数</h2><ul><li>生命周期：指一个组件从<strong>创建 -&gt; 运行 -&gt; 销毁</strong>的整个阶段，强调的是一个<strong>时间段</strong>。</li><li>生命周期函数：由vue框架提供的<strong>内置函数</strong>，会伴随着组件的生命周期，自动<strong>按序执行</strong>。</li></ul><h2 id="生命周期函数的分类"><a href="#生命周期函数的分类" class="headerlink" title="生命周期函数的分类"></a>生命周期函数的分类</h2><p>如果没有声明这些函数，运行的时候也会执行这些函数，只是函数体为空。<br><img src="/assets/7a1cc381946d47dd9631da27ce20eced.png" alt="7a1cc381946d47dd9631da27ce20eced.png"></p><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><ol><li>创建阶段（只执行1次）：</li></ol><ul><li>beforeCreate()：基本不用，啥也做不了。</li><li><strong>created()：</strong><ul><li>调用methods中的方法来发起ajax请求服务器中的数据。</li><li>把请求到的数据转存到data中，供template模板使用。</li><li>在created方法里不能操作DOM元素。</li></ul></li><li>beforeMount()：没什么意义，也不能操作DOM元素。</li><li><strong>mounted()：</strong>内存中的DOM结构被渲染到页面上，可以操作DOM结构。</li></ul><ol start="2"><li>运行阶段（用户和组件会产生交互、最少执行0次、最多执行N次）：</li></ol><ul><li>beforeUpdate()：<ul><li>数据发生变化后触发。</li><li>data数据是新的，UI结构是旧的。（新数据还没有渲染到页面中）</li></ul></li><li><strong>updated()：</strong><ul><li>data数据是新的，UI结构也是最新的。</li><li>当数据变化后，为了能够操作到最新的DOM，把代码写到updated里。</li></ul></li></ul><ol start="3"><li>销毁阶段（只执行一次）：</li></ol><ul><li>beforeDestroy()：此时组件仍处于工作状态，尚未销毁。</li><li>destroyed()：组件在浏览器中对应的DOM结构已被完全移除。<br><img src="/assets/22eb9458008f49259e5e46623c7918b7.png" alt="22eb9458008f49259e5e46623c7918b7.png"></li></ul><h1 id="组件之间的数据共享"><a href="#组件之间的数据共享" class="headerlink" title="组件之间的数据共享"></a>组件之间的数据共享</h1><h2 id="组件之间常见的关系"><a href="#组件之间常见的关系" class="headerlink" title="组件之间常见的关系"></a>组件之间常见的关系</h2><ul><li>父子关系</li><li>兄弟关系<br><img src="/assets/77eb444a57fb499783bd0e7fe76cb8c6.png" alt="77eb444a57fb499783bd0e7fe76cb8c6.png"></li></ul><h2 id="父子组件之间的数据共享"><a href="#父子组件之间的数据共享" class="headerlink" title="父子组件之间的数据共享"></a>父子组件之间的数据共享</h2><ol><li>父组件向子组件的数据共享</li></ol><ul><li>需要使用自定义属性props。</li><li>要使用v-bind！</li><li>不要直接去修改props里面的数据。<br><img src="/assets/3fb529ec80c64850a98deeaa047ac767.png" alt="3fb529ec80c64850a98deeaa047ac767.png"></li></ul><ol start="2"><li>子组件向父组件的数据共享</li></ol><ul><li>使用自定义事件</li><li>在子组件中调用$emit来自定义事件</li><li>在父组件中，使用@+在子组件中自定义的事件，来绑定事件，此时的形参就是传递的值。<br><img src="/assets/c78e880e71c043f2b54921d7a4ded8a6.png" alt="c78e880e71c043f2b54921d7a4ded8a6.png"></li></ul><h2 id="兄弟组件之间的数据共享"><a href="#兄弟组件之间的数据共享" class="headerlink" title="兄弟组件之间的数据共享"></a>兄弟组件之间的数据共享</h2><ul><li>兄弟组件之间数据共享的方案是EventBus</li><li>步骤：<ul><li>创建<strong>eventBus.js</strong>模块，并向外共享一个Vue实例对象</li><li>在<strong>数据发送方</strong>，调用<strong>bus.$emit</strong>(‘事件名称’,要发送的数据)方法<strong>触发自定义事件</strong></li><li>在<strong>数据接收方</strong>，在created()中调用<strong>bus.$on</strong>(‘事件名称’,事件处理函数)方法<strong>注册一个自定义事件</strong><br><img src="/assets/ba947b2b158647e2a933ed8f3cdb5bb1.png" alt="ba947b2b158647e2a933ed8f3cdb5bb1.png"></li></ul></li></ul><blockquote><p>如果两个组件之间嵌套关系比较深的话，也可以认为是兄弟组件之间的数据共享。</p></blockquote><h1 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h1><ul><li>jQuery：简化了程序员操作DOM的过程</li><li>vue优势：MVVM 在vue中，程序员不需要操作DOM，只需要把数据维护好即可（数据驱动视图）<ul><li>结论：在vue项目中，强烈不建议安装和使用jQuery</li></ul></li><li>假设：在vue中，需要操作DOM，需要拿到页面上某个DOM元素的应用，此时怎么办？？？<ul><li>vue给程序员提供了ref，可以让程序员在不调用DOM API的前提下，拿到DOM元素的引用。</li></ul></li></ul><hr><h2 id="什么是ref引用"><a href="#什么是ref引用" class="headerlink" title="什么是ref引用"></a>什么是ref引用</h2><p>用来辅助开发者在不依赖于jQuery的情况下，获取DOM元素或组件的引用。</p><ul><li>每个vue组件实例上，都包含一个 $ref 对象，里面存储着对应的DOM元素或组件的引用。</li><li>默认情况：组件的 $ref 指向一个空对象。</li></ul><h2 id="使用ref引用DOM元素"><a href="#使用ref引用DOM元素" class="headerlink" title="使用ref引用DOM元素"></a>使用ref引用DOM元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;div ref=<span class="string">&quot;divRef&quot;</span>&gt;helloworld&lt;/div&gt;</span><br><span class="line">methods:&#123;</span><br><span class="line">    change() &#123;</span><br><span class="line">        <span class="built_in">this</span>.$ref.divRef.style.color = <span class="string">&quot;blue&quot;</span>;<span class="comment">//操作DOM元素  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用ref引用组件实例"><a href="#使用ref引用组件实例" class="headerlink" title="使用ref引用组件实例"></a>使用ref引用组件实例</h2><p><img src="/assets/ee246a5055834471b7f2f8a7e236b67e.png" alt="ee246a5055834471b7f2f8a7e236b67e.png"></p><blockquote><p>使用场景：在父组件中要调用子组件中的方法，最方便的就是用ref<br>让文本框自动获得焦点：当文本框显示出来之后，如果希望它立刻获得焦点，则可以为文本框添加ref引用，并调用原生DOM对象的.focus()方法即可。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> 生命周期 </tag>
            
            <tag> 数据共享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装和配置Vant组件库</title>
      <link href="/post/c29e9402.html"/>
      <url>/post/c29e9402.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装和配置Vant组件库"><a href="#安装和配置Vant组件库" class="headerlink" title="安装和配置Vant组件库"></a>安装和配置Vant组件库</h1><p>vant官网：<a href="https://vant-ui.github.io/vant/v2/#/zh-CN/">vant2</a></p><ol><li>执行：<code>npm i vant@latest-v2</code>    安装组件库</li><li>在<strong>开发阶段</strong>，直接导入所有组件，不用考虑体积问题（怎么快怎么来）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vant</span> <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span> <span class="comment">//导入所有组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;vant/lib/index.css&#x27;</span> <span class="comment">//导入所有组件对应的样式</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vant</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>在<strong>发布阶段</strong>，再进行项目体积的优化。</li></ol><h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><ul><li>某个属性的值如果是true，可以简写</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;van-nav-bar title=<span class="string">&quot;黑马头条&quot;</span> :fixed=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//以上代码可以简写成：</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">van-nav-bar</span> <span class="attr">title</span>=<span class="string">&quot;黑马头条&quot;</span> <span class="attr">fixed</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>覆盖第三方组件样式时，如果直接覆盖不生效，可以考虑在样式前面加上<code>/deep/</code></li></ul><h1 id="Vant定制主题"><a href="#Vant定制主题" class="headerlink" title="Vant定制主题"></a>Vant定制主题</h1><p>核心：less变量的覆盖<br>为了能够覆盖默认的less变量，一定要在main.js文件中把后缀名改成.less<br><code>import &#39;vant/lib/index.less&#39;</code><br>方法1：直接覆盖样式变量（不用）</p><ol><li>新建：vue.config.js文件</li></ol><ul><li>vue.config.js文件是vue-cli创建出来的配置文件</li><li>在vue.config.js这个配置文件中，可以对整个项目的打包、构建进行全局性的配置</li></ul><ol start="2"><li>在文件中把官方文档中的代码复制过去</li></ol><blockquote><p>缺点：每次修改都需要重启服务器</p></blockquote><p>方法2：less文件覆盖</p><ol><li>在src目录下创建theme.less文件<br><img src="/assets/4ecff25ab3a64f7a8da784cc92617b6a.png" alt="4ecff25ab3a64f7a8da784cc92617b6a.png"></li><li>在theme.less文件中，覆盖Vant官方的Less变量值<br><img src="/assets/2ee311095cd34d4db82360c2de8adcc5.png" alt="2ee311095cd34d4db82360c2de8adcc5.png"></li><li>把主题文件的绝对路径填充到vue.config.js中的一个地方：在vue.config.js配置文件中，导入node.js中的核心模块path，来进行绝对路径的拼接</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="comment">// __dirname表示：vue.config.js所在项目根目录</span></span><br><span class="line"><span class="keyword">const</span> themePath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./src/theme.less&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/assets/1b42f6d364ad4c19a59d960f02d392af.png" alt="1b42f6d364ad4c19a59d960f02d392af.png"></p>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> Vant </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中的方法</title>
      <link href="/post/36579f38.html"/>
      <url>/post/36579f38.html</url>
      
        <content type="html"><![CDATA[<h1 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h1><ul><li>一旦开始，无法在中间被停止</li><li>效率低</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;工藤新一&#x27;</span>,<span class="string">&#x27;服部平次&#x27;</span>,<span class="string">&#x27;怪盗基德&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;  <span class="comment">//循环3次，return也不会起效果</span></span><br><span class="line">    <span class="keyword">if</span>(item==<span class="string">&#x27;工藤新一&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(index);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="some循环"><a href="#some循环" class="headerlink" title="some循环"></a>some循环</h1><ul><li>从数组里找元素，用some循环比较合适</li><li>找到对应的项后，通过return true来终止some循环</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;工藤新一&#x27;</span>,<span class="string">&#x27;服部平次&#x27;</span>,<span class="string">&#x27;怪盗基德&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;   <span class="comment">//循环2次</span></span><br><span class="line">    <span class="keyword">if</span>(item==<span class="string">&#x27;工藤新一&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//固定写法  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="every循环"><a href="#every循环" class="headerlink" title="every循环"></a>every循环</h1><ul><li>判断每一项是否满足需求</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;西瓜&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;榴莲&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;草莓&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//需求：判断数组中水果是否被全选</span></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">every</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">state</span>)</span><br><span class="line"><span class="comment">//括号里是个箭头函数，其实就是判断的简写</span></span><br><span class="line"><span class="comment">//括号里相当于   arr.every(item =&gt; item.state===true)</span></span><br><span class="line"><span class="comment">//如果每一项的state都是true，返回true；只要有一个是false，返回false。</span></span><br></pre></td></tr></table></figure><h1 id="reduce循环"><a href="#reduce循环" class="headerlink" title="reduce循环"></a>reduce循环</h1><ul><li>把每次循环的结果累加起来（累加器）</li><li>格式：reduce( (累加结果, 当前循环项)&#x3D;&gt;{} , 初始值 )</li><li>每次循环，都要返回当前的累加结果，作为累加结果</li><li>返回最后一次循环的累加结果</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;西瓜&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>,<span class="attr">price</span>:<span class="number">10</span>,<span class="attr">count</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;榴莲&#x27;</span>,<span class="attr">state</span>:<span class="literal">false</span>,<span class="attr">price</span>:<span class="number">80</span>,<span class="attr">count</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">&#x27;草莓&#x27;</span>,<span class="attr">state</span>:<span class="literal">true</span>,<span class="attr">price</span>:<span class="number">20</span>,<span class="attr">count</span>:<span class="number">3</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">//需求：把购物车数组中，已勾选的水果，总价累加出来。</span></span><br><span class="line"><span class="keyword">let</span> sum=<span class="number">0</span>;<span class="comment">//总价</span></span><br><span class="line">arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">state</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    sum += item.<span class="property">price</span> * item.<span class="property">count</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//reduce循环</span></span><br><span class="line"><span class="comment">//arr.filter(item =&gt; item.state)：返回state=true的结果（数组形式）</span></span><br><span class="line"><span class="comment">//reduce( (累加结果, 当前循环项)=&gt;&#123;&#125; , 初始值 )</span></span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">state</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">totalprice,item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//第一次循环 totalprice = 0</span></span><br><span class="line">    <span class="comment">//第二次循环 totalprice = 返回的结果值</span></span><br><span class="line">    <span class="keyword">return</span> totalprice += item.<span class="property">price</span> * item.<span class="property">count</span>;</span><br><span class="line">&#125;,<span class="number">0</span>) <span class="comment">//初始值为0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态组件&amp;插槽&amp;自定义指令&amp;ESLint&amp;axios补充</title>
      <link href="/post/704e3643.html"/>
      <url>/post/704e3643.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h1><h2 id="什么是动态组件"><a href="#什么是动态组件" class="headerlink" title="什么是动态组件"></a>什么是动态组件</h2><p>动态切换组件的显示与隐藏</p><h2 id="如何实现动态组件渲染——component组件"><a href="#如何实现动态组件渲染——component组件" class="headerlink" title="如何实现动态组件渲染——component组件"></a>如何实现动态组件渲染——component组件</h2><p>vue提供了一个内置的component组件，专门用来实现动态组件的渲染。</p><ul><li>component组件类似于占位符</li></ul><h3 id="is属性的值"><a href="#is属性的值" class="headerlink" title="is属性的值"></a>is属性的值</h3><ul><li>表示要渲染组件的名字</li><li>组件在components节点下的注册名称。</li></ul><h3 id="keep-alive标签"><a href="#keep-alive标签" class="headerlink" title="keep-alive标签"></a>keep-alive标签</h3><ul><li>可以把内部的组件进行缓存，而不是销毁组件。</li><li>可以保留之前在这个组件上的操作。</li><li>对应的生命周期函数：<ul><li>当组件<strong>被缓存</strong>时，会自动触发组件的<strong>deactivated</strong>生命周期函数</li><li>当组件<strong>被激活</strong>时，会自动触发组件的<strong>activated</strong>生命周期函数</li><li>当组件<strong>第一次被创建</strong>的时候，即执行created也会执行activated</li><li>当组件<strong>被激活</strong>时，只会触发activated，不再触发created，因为组件没有被创建。</li></ul></li></ul><blockquote><p>可以使用include指定哪些组件需要被缓存，或者使用exclude属性指定哪些组件不需要被缓存，但是<strong>不要同时使用include和exclude这两个属性。</strong><br>include属性：只有<strong>名称匹配</strong>的组件<strong>会被缓存</strong>、多个组件之间使用逗号分割<br>exclude属性：只有<strong>名称匹配</strong>的组件<strong>不会被缓存</strong></p></blockquote><blockquote><p>如果在声明组件的时候，没有为组件指定 name 名称，则组件的名称默认为注册时候的名称。当提供了name属性之后，组件的名称就是name属性的值。</p><ol><li>组件的<strong>注册名称</strong>（在components节点下）的主要应用场景是：<br>以标签的形式，把注册好的组件，渲染和使用到页面结构中。</li><li>组件<strong>声明</strong>（定义组件的时候）时候的“name”名称的主要应用场景是：<br>结合keep-alive标签实现组件的缓存功能<br>在调试工具中看到组件的name名称</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;Left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">comName</span>:<span class="string">&#x27;Left&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">components</span>:&#123;</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h1><p>插槽（slot）是vue为组件的封装者提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望由用户指定的部分</strong>定义为插槽。<br><img src="/assets/bccfb8a88b7246fda48ee533f905426f.png" alt="bccfb8a88b7246fda48ee533f905426f.png"></p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p><img src="/assets/67b6c08cac6b4f0d8c545d333e2da0f6.png" alt="67b6c08cac6b4f0d8c545d333e2da0f6.png"></p><h2 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h2><h3 id="slot标签"><a href="#slot标签" class="headerlink" title="slot标签"></a>slot标签</h3><p>vue官方规定，每一个slot插槽，都要有一个name名称；如果省略了slot的name属性，则有一个默认的名称叫做default。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot name=&quot;default&quot;&gt;&lt;/slot&gt;</span><br></pre></td></tr></table></figure><p>如果只有一个插槽，一般也会省略name名称。<br>默认情况下，在使用组件的时候，提供的内容都会被填充到名字为default的插槽之中。</p><h3 id="v-slot属性"><a href="#v-slot属性" class="headerlink" title="v-slot属性"></a>v-slot属性</h3><p>v-slot只能用于template元素上。</p><ul><li>如果要把内容填充到指定名称的插槽中，需要使用v-slot: 这个指令</li><li>v-slot: 后面要跟上插槽的名字</li><li>v-slot: 指令不能直接用在元素身上，必须用在template标签上，或者用在一个组件上。</li><li>template这个标签是一个虚拟的标签，只起到包裹性质的作用，但是不会被渲染为任何实质性的html元素。</li><li>v-slot: 指令的简写形式是：**#**</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Left</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是在Left组件的内容区域，声明的p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h2><p>封装组件时，可以为预留的<slot>插槽提供后备内容。<br>如果使用者没有为插槽提供任何内容，则后备内容会生效。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;slot&gt;后备内容&lt;/slot&gt;</span><br></pre></td></tr></table></figure><h2 id="具名插槽、作用域插槽"><a href="#具名插槽、作用域插槽" class="headerlink" title="具名插槽、作用域插槽"></a>具名插槽、作用域插槽</h2><p><strong>具名插槽：</strong>为slot插槽指定了name值。<br><strong>作用域插槽：</strong>在封装组件时，为预留的slot标签提供属性对应的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Left组件</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content-box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">msg</span>=<span class="string">&quot;helloworld.js&quot;</span> <span class="attr">:user</span>=<span class="string">&quot;userinfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">userinfo</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">20</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用Left组件</span></span><br><span class="line">&lt;<span class="title class_">Left</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content-box</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>content-box的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;scope.msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;scope.user.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content-box</span>=<span class="string">&quot;&#123;msg,user&#125;&quot;</span>&gt;</span>   //解构赋值</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>content-box的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>content的内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Left</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>约定：一般用一个叫做scope的对象来接收传送过来的值，也可以使用解构赋值来传值。</p></blockquote><h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p>vue官方提供了v-tex、v-for、v-model、v-if等常用指令，此外，vue还允许开发者自定义指令。</p><h2 id="自定义指令分类"><a href="#自定义指令分类" class="headerlink" title="自定义指令分类"></a>自定义指令分类</h2><h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><ul><li>每个vue组件中，可以在<strong>directives</strong>节点下声明私有自定义指令。</li><li>指令定义的时候不加 v-xxx ，但是使用的时候，需要加上v-xxx<br><code>&lt;div v-xxx&gt;&lt;/div&gt;</code></li></ul><h4 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h4><p>当指令<strong>第一次</strong>被绑定到元素上时，就会立即触发<strong>bind函数</strong>。</p><ul><li>bind的形参：<ul><li>第一个形参el：表示当前指令所绑定到的那个DOM对象</li><li>第二个形参binding（一般叫做binding）：获取指令绑定的值。<ul><li>在binding对象中：value是程序员可以使用的值，expression的值是用户在等号后写的表达式。</li></ul></li></ul></li><li>bind函数缺点：只在元素第一次绑定到元素上时才会触发，如果DOM更新时，bind函数不会重新执行。</li></ul><h4 id="update函数"><a href="#update函数" class="headerlink" title="update函数"></a>update函数</h4><p>第一次绑定元素不会调用，但是会在每次<strong>DOM更新</strong>时被调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-color=<span class="string">&quot;color&quot;</span>&gt;<span class="number">12</span>&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-color</span>=<span class="string">&quot;&#x27;red&#x27;&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">color</span>:blue    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">directives</span>:&#123;</span><br><span class="line">    <span class="attr">color</span>:&#123;</span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">            <span class="comment">//binding对象中：value是程序员可以使用的值，expression的值是用户在等号后写的表达式</span></span><br><span class="line">            el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;        </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//在DOM更新时调用</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params">el,binding</span>)&#123;</span><br><span class="line">             el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;         </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函数简写：如果bind和update函数中的逻辑完全相同，则对象格式的自定义指令可以简写成函数格式：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以上代码相当于：</span></span><br><span class="line"><span class="attr">directives</span>:&#123;</span><br><span class="line">    <span class="title function_">color</span>(<span class="params">el,binding</span>) &#123;</span><br><span class="line">        el.<span class="property">style</span>.<span class="property">color</span> = binding.<span class="property">value</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><ul><li>全局共享的自定义指令需要通过Vue.directive()进行声明</li><li>全局自定义指令要放到main.js文件中<br><img src="/assets/03b1e683ca50430abb7abe0c1c348264.png" alt="03b1e683ca50430abb7abe0c1c348264.png"></li></ul><blockquote><p>一般来说，定义自定义指令，都是定义全局自定义指令。</p></blockquote><h1 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h1><p><img src="/assets/10561f37113b44cd9d5f2e0cdfb31ac8.png" alt="10561f37113b44cd9d5f2e0cdfb31ac8.png"><br>规则搜索网址：<a href="https://eslint.nodejs.cn/docs/latest/">ESLint中文文档</a></p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p><img src="/assets/443a9135317a47868603d5df4c920c8f.png" alt="443a9135317a47868603d5df4c920c8f.png"><br><img src="/assets/43b6cc86c5e54b408f92fe0a441d9b73.png" alt="43b6cc86c5e54b408f92fe0a441d9b73.png"></p><h2 id="很好用的插件"><a href="#很好用的插件" class="headerlink" title="很好用的插件"></a>很好用的插件</h2><p><img src="/assets/6d7676d4bfaa42559c2dfa4770bae1e6.png" alt="6d7676d4bfaa42559c2dfa4770bae1e6.png"><br>配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ESLint插件的配置</span></span><br><span class="line"><span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="/assets/93d54fb8eef5475cb0e6caf6e80515b7.png" alt="93d54fb8eef5475cb0e6caf6e80515b7.png"><br>配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;prettier.configPath&quot;</span>: <span class="string">&quot;C:\\Users\\林诗涵\\.prettierrc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 每行文字个数超出此限制将会被迫换行</span></span><br><span class="line">    <span class="string">&quot;prettier.printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="comment">// 使用单引号替换双引号</span></span><br><span class="line">    <span class="string">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">    <span class="comment">// 设置 .vue 文件中，HTML代码的格式化插件</span></span><br><span class="line">    <span class="string">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>,</span><br><span class="line">    <span class="comment">// 忽略项目中的警告和弹窗</span></span><br><span class="line">    <span class="string">&quot;vetur.ignoreProjectWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;wrap_attributes&quot;</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line">            <span class="string">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">            <span class="string">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">&quot;arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// ESLint插件的配置</span></span><br><span class="line">    <span class="string">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;source.fixAll&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//导入文件时是否携带文件的扩展名</span></span><br><span class="line">    <span class="string">&quot;path-autocomplete.extensionOnImport&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//配置@的路径提示</span></span><br><span class="line">    <span class="string">&quot;path-autocomplete.pathMappings&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;@&quot;</span>: <span class="string">&quot;$&#123;folder&#125;/src&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;editor.tabSize&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;[vue]&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="挂在axios"><a href="#挂在axios" class="headerlink" title="挂在axios"></a>挂在axios</h1><p>如果很多.vue组件中要发起请求，每次导入axios会很麻烦，此时可以<strong>把axios挂载到Vue的原型上，并配置请求根路径。</strong></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在main.js文件中：</p><ol><li>引入axios：import axios from ‘axios’</li><li>全局配置axios的请求根路径：axios.defaults.baseURL &#x3D; ‘请求根路径’</li><li>把axios挂载到Vue原型上，供每个.vue组件的实例直接调用：Vue.prototype.$http &#x3D; axios</li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>在某个.vue组件中需要使用axios，就不需要导入，直接调用this.$http.xxx</li><li>在某个发送axios请求的组件中就不需要写完整的请求地址了。<br><code>例：this.$http.get(&#39;/top/get&#39;);</code></li></ul><blockquote><p>好处：在vue的组件中，使用this.$http就可以发起请求<br>坏处：不利于API接口的复用</p></blockquote><p>在实际开发中，封装一个request.js模块，创建小axios，并共享出去<br><img src="/assets/7079b9d967044d43965164cccf23c051.png" alt="7079b9d967044d43965164cccf23c051.png"><br><img src="/assets/e5c3299d3a504ed2a62c8e430c9f3b5b.png" alt="e5c3299d3a504ed2a62c8e430c9f3b5b.png"><br>request.js内容：<br><img src="/assets/97d317e3d1394b4b8f5d5056f9cde071.png" alt="97d317e3d1394b4b8f5d5056f9cde071.png"><br>今后如果要调接口，就导入utils&#x2F;request.js，就可以得到request实例，也不需要指定根路径，填URL地址即可。（封装API步骤如下）</p><h3 id="封装API"><a href="#封装API" class="headerlink" title="封装API"></a>封装API</h3><ol><li>在src目录下新建一个api文件夹，在下面存放封装的api接口<br><img src="/assets/6964f4e813e0415fa2034a6b9410242d.png" alt="6964f4e813e0415fa2034a6b9410242d.png"></li></ol><ul><li>因为API需要发送请求，所以先导入上面封装的utils&#x2F;request.js<br><img src="/assets/3ae5be252f074e94bc3af1ef5edcd935.png" alt="3ae5be252f074e94bc3af1ef5edcd935.png"></li><li>向外导出API函数，调用request.xxx方法</li><li>一定要把Promise的返回值return出去</li></ul><ol start="2"><li>如果需要使用API的话：先导入API，再调用方法（注意点：传参、await、async）<br><img src="/assets/ca83c91e152a46249e7f880f1d9182d2.png" alt="ca83c91e152a46249e7f880f1d9182d2.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue2 </tag>
            
            <tag> 动态组件 </tag>
            
            <tag> 插槽 </tag>
            
            <tag> 自定义指令 </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2-vue基础入门（二）</title>
      <link href="/post/fdb563fa.html"/>
      <url>/post/fdb563fa.html</url>
      
        <content type="html"><![CDATA[<h1 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h1><h2 id="什么是watch侦听器"><a href="#什么是watch侦听器" class="headerlink" title="什么是watch侦听器"></a>什么是watch侦听器</h2><p>允许开发者监视数据的变化，从而针对数据的变化做特定的操作。</p><ul><li>数据值发生变化，就会自动触发侦听器。 </li><li>所有侦听器都被定义到watch节点下。</li><li>侦听器本质是个函数，要监视哪个数据的变化，就把数据名作为方法名即可。 </li><li>侦听器的参数是新值在前，旧值在后。</li><li>典型应用场景：判断用户名是否被占用。</li></ul><h2 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h2><h3 id="方法格式的侦听器（先考虑）"><a href="#方法格式的侦听器（先考虑）" class="headerlink" title="方法格式的侦听器（先考虑）"></a>方法格式的侦听器（先考虑）</h3><ul><li>缺点1：无法在刚进入页面的时候立即触发。</li><li>缺点2：如果真听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器。<ul><li>如果要侦听的是对象子属性的变化，可以使用该方法，但是注意：必须包裹一层单引号。</li></ul></li></ul><h3 id="对象格式的侦听器"><a href="#对象格式的侦听器" class="headerlink" title="对象格式的侦听器"></a>对象格式的侦听器</h3><ul><li>好处1：可以通过<strong>immediate</strong>选项，让侦听器自动触发。<ul><li>immediate作用：控制侦听器是否自动触发一次。</li><li>默认值是false，true表示一进入页面就会触发一次侦听器。</li></ul></li><li>好处2：可以通过<strong>deep</strong>选项，让侦听器深度侦听对象中每个属性的变化。<ul><li>deep作用：只要对象中任何一个属性变化了，都会触发“对象的侦听器”。</li><li>默认值是false。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法格式的侦听器</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;<span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;</span><br><span class="line">        <span class="comment">//newVal:变化后的新值，oldVal:变化前的旧值</span></span><br><span class="line">        <span class="comment">//监听username值的变化</span></span><br><span class="line">        <span class="title function_">username</span>(<span class="params">newVal,oldVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象格式的侦听器</span></span><br><span class="line"><span class="comment">//（immediate）</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>:&#123;</span><br><span class="line">        <span class="comment">//侦听器的处理函数(只要监视到username值的变化，就会触发该函数)</span></span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal);                            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//immediate选项的默认值是false，true表示一进入页面就会触发一次侦听器。</span></span><br><span class="line">        <span class="comment">//作用：控制侦听器是否自动触发一次。</span></span><br><span class="line">        <span class="attr">immediate</span>:<span class="literal">true</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（deep）</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;info.username&quot;</span>/&gt;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="attr">username</span>:<span class="string">&#x27;admin&#x27;</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="attr">info</span>:&#123;</span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal.<span class="property">username</span>);        </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//开启深度监听，只要对象中任何一个属性变化了，都会触发“对象的侦听器”</span></span><br><span class="line">        <span class="attr">deep</span>:<span class="literal">true</span>,    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果只监听username，也可以用如下代码</span></span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span> (newVal) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal); <span class="comment">//得到的就是info对象里的username值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或：</span></span><br><span class="line"><span class="attr">watch</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;info.username&#x27;</span>:&#123;</span><br><span class="line">        <span class="title function_">handler</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal);     </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>计算属性指<strong>通过一系列运算</strong>后，最终得到一个<strong>属性值</strong>，这个<strong>动态计算出来的属性值</strong>可以被模板结构或methods方法使用。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>定义的时候，要被定义成“方法”</li><li>使用的时候，当普通属性使用即可。</li><li>被定义到computed节点下。</li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>实现了代码的复用。</li><li>当计算属性所依赖的数据源发生变化，计算属性会自动重新求值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123;rgb&#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">    <span class="title function_">rgb</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`rgb&#123;$(this.r),$(this.g),$(this.b)&#125;`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>axios是一个专注于数据请求的库。</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>调用axios方法得到的返回值result是个Promise对象【axios在请求到数据之后，在真正的数据之外套了一层壳】。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">config:&#123;&#125;,</span><br><span class="line">data:&#123;真实的数据&#125;,</span><br><span class="line">header:&#123;&#125;,</span><br><span class="line">request:&#123;&#125;,</span><br><span class="line">status:xxx,</span><br><span class="line">statusText:&#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h2><ul><li>调用axios之后，使用 async&#x2F;await 进行简化。<ul><li>如果调用某个方法的返回值是Promise实例，则前面可以添加await</li><li>await只能用在被 async “修饰”的方法中</li></ul></li><li>使用解构赋值，从axios封装的大对象中，把data属性解构出来。</li><li>把解构出来的data属性，使用 冒号 进行重命名，一般都重命名为 { data: res }</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法如下：</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;请求的类型&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;请求的URL地址&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;<span class="variable constant_">URL</span>中的查询参数&#125;, <span class="comment">//GET传参</span></span><br><span class="line">    <span class="attr">data</span>:&#123;请求体参数&#125; <span class="comment">//POST传参</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(result) =&gt; &#123;</span><br><span class="line">    <span class="comment">// .then用来指定成功之后的回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//发起GET请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">methos</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;<span class="attr">id</span>:<span class="number">1</span>&#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//发起POST请求</span></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">methosd</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>:<span class="number">20</span>    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化：!!!!!</span></span><br><span class="line"><span class="comment">//规则：如果调用某个方法的返回值是Promise实例，则前面可以添加await</span></span><br><span class="line"><span class="comment">//await只能用在被 async “修饰”的方法中</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//解构赋值的时候，使用 : 进行重命名</span></span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>:res &#125; = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;  <span class="comment">//解构赋值</span></span><br><span class="line">        <span class="attr">methosd</span>:<span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:&#123;</span><br><span class="line">           <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">           <span class="attr">age</span>:<span class="number">20</span>    </span><br><span class="line">       &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br></pre></td></tr></table></figure><h2 id="axios直接发起GET和POST请求"><a href="#axios直接发起GET和POST请求" class="headerlink" title="axios直接发起GET和POST请求"></a>axios直接发起GET和POST请求</h2><p>请求数据发GET，传输数据发POST</p><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;url地址&#x27;</span> [,&#123;</span><br><span class="line">    <span class="attr">params</span>:&#123;<span class="variable constant_">GET</span>参数&#125;</span><br><span class="line">&#125;] )</span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>:res &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://www.liulongbin.top:3306/api/getbooks&#x27;</span>,&#123;</span><br><span class="line">        <span class="attr">params</span>:&#123;</span><br><span class="line">            <span class="attr">id</span>:<span class="number">1</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;url地址&#x27;</span> [,&#123; <span class="variable constant_">POST</span>请求体数据 &#125;] )</span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="attr">data</span>:res &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;&#x27;</span><span class="attr">http</span>:<span class="comment">//www.liulongbin.top:3306/api/getbooks&#x27;&#x27;,&#123;</span></span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">    &#125;,<span class="attr">headers</span>:&#123;<span class="string">&#x27;Authorization&#x27;</span>:<span class="string">&#x27;本机token&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h1 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h1><h2 id="单页面应用程序（SPA）"><a href="#单页面应用程序（SPA）" class="headerlink" title="单页面应用程序（SPA）"></a>单页面应用程序（SPA）</h2><p>指<strong>一个web网站中只有唯一的一个HTML页面</strong>，所有的功能与交互都在这唯一的一个页面内完成。</p><h2 id="什么是vue-cli"><a href="#什么是vue-cli" class="headerlink" title="什么是vue-cli"></a>什么是vue-cli</h2><p>vue-cli是Vue.js开发的标准工具，它简化了程序员基于webpack创建工程化的Vue项目的过程。因此，程序员可以专注在撰写应用上，而不必纠结webpack配置的问题。<br>网址：<a href="https://cli.vuejs.org/zh/guide/">介绍 | Vue CLI (vuejs.org)</a></p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><ul><li>vue-cli是npm上的全局包，在终端上输入 npm install -g @vue&#x2F;cli 就可以安装成功了。<ul><li>使用 vue–V 指令可以判断是否安装成功</li></ul></li><li>vue-cli的使用：<ul><li>在终端下运行如下命令，创建指定名称的项目： vue create 项目名<br><img src="/assets/e14baa3852e342578e631a74d8453c6b.png" alt="e14baa3852e342578e631a74d8453c6b.png"><br><img src="/assets/7175be17ef9b470fae6adf67ef2ca418.png" alt="7175be17ef9b470fae6adf67ef2ca418.png"><br><img src="/assets/587c36e7a7a94f7fafd78ee209517a5c.png" alt="587c36e7a7a94f7fafd78ee209517a5c.png"><br><img src="/assets/ac3239327e20486c9ac0729d48d6346c.png" alt="ac3239327e20486c9ac0729d48d6346c.png"><br><img src="/assets/fd489e1b7129498c9fc14cc22533b39f.png" alt="fd489e1b7129498c9fc14cc22533b39f.png"><br><img src="/assets/2592a4676d9c437c8cbaa806d92de3b0.png" alt="2592a4676d9c437c8cbaa806d92de3b0.png"></li></ul></li></ul><h3 id="vue项目中src目录的构成"><a href="#vue项目中src目录的构成" class="headerlink" title="vue项目中src目录的构成"></a>vue项目中src目录的构成</h3><p><img src="/assets/4bdf91a9d1cd41eba7d3ed858a68fd65.png" alt="4bdf91a9d1cd41eba7d3ed858a68fd65.png"></p><ul><li>assets文件夹： 存放项目中用到的静态资源文件。（css样式表、图片资源）</li><li>components文件夹：程序员封装的、可复用的组件，都要放在components目录下。</li><li>main.js：是项目的入口文件，整个项目的运行，要先执行main.js。</li><li>APP.vue：是项目的根组件。</li></ul><h2 id="vue项目的运行流程"><a href="#vue项目的运行流程" class="headerlink" title="vue项目的运行流程"></a>vue项目的运行流程</h2><p>在工程化的项目中，vue通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。<br><img src="/assets/aaded890e40f4fe9b688c0a250beac3b.png" alt="aaded890e40f4fe9b688c0a250beac3b.png"></p><ul><li><strong>App.vue</strong> 用来编写待渲染的<strong>模板结构</strong> （render函数中，渲染的是哪个.vue组件，这个组件就叫做根组件）</li><li><strong>index.html</strong>中需要预留一个<strong>el区域</strong></li><li><strong>main.js</strong>把App.vue渲染到index.html所预留的区域中</li></ul><h1 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h1><h2 id="什么是组件化开发"><a href="#什么是组件化开发" class="headerlink" title="什么是组件化开发"></a>什么是组件化开发</h2><p>根据封装的思想，把页面上可复用的UI结构封装为组件。</p><h2 id="vue项目中的组件化开发"><a href="#vue项目中的组件化开发" class="headerlink" title="vue项目中的组件化开发"></a>vue项目中的组件化开发</h2><ol><li>vue是个支持组件化开发的前端框架</li><li>vue规定：组建的后缀名是.vue</li></ol><h3 id="组件的三个组成部分"><a href="#组件的三个组成部分" class="headerlink" title="组件的三个组成部分"></a>组件的三个组成部分</h3><h4 id="template：组件的模板结构（要复用的UI结构）"><a href="#template：组件的模板结构（要复用的UI结构）" class="headerlink" title="template：组件的模板结构（要复用的UI结构）"></a>template：组件的模板结构（要复用的UI结构）</h4><ol start="3"><li>组件的模板元素中，只能有一个根节点！</li><li>一般根节点的类名就是xxx-container（xxx为组件名）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pink&quot;</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeName&quot;</span>&gt;</span>修改用户名<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="script：-组件的JavaScript行为"><a href="#script：-组件的JavaScript行为" class="headerlink" title="script： 组件的JavaScript行为"></a>script： 组件的JavaScript行为</h4><ol start="5"><li>使用export default默认导出</li><li>组件中的data必须是个函数   data() {  return { 定义数据 }   }</li><li>在组件中，this表示当前组件的实例对象</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="comment">//默认导出！固定写法！</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//注意！！ .vue中的data，不能像之前一样，不能指向对象。</span></span><br><span class="line">    <span class="comment">//组件中的data数据源必须是个函数</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//这个return 出去的&#123; &#125;可以定义数据。</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">             <span class="attr">username</span>:<span class="string">&#x27;lsh&#x27;</span>       </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="title function_">changeName</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">username</span>=<span class="string">&quot;33&quot;</span>      </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//当前组件中的计算属性、侦听器、过滤器</span></span><br><span class="line">    <span class="attr">computed</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">watch</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">filters</span>:&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="style：组件的样式"><a href="#style：组件的样式" class="headerlink" title="style：组件的样式"></a>style：组件的样式</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//style中启动less语法</span></span><br><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span>&gt;</span><br><span class="line">.<span class="property">pink</span> &#123;</span><br><span class="line">    <span class="attr">color</span>:pink;</span><br><span class="line">    h3 &#123;</span><br><span class="line">        <span class="attr">color</span>:red;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="组件之间的父子关系"><a href="#组件之间的父子关系" class="headerlink" title="组件之间的父子关系"></a>组件之间的父子关系</h2><p><img src="/assets/23de26cfde744602ad2c63820c0777c2.png" alt="23de26cfde744602ad2c63820c0777c2.png"></p><h3 id="使用组件的三个步骤"><a href="#使用组件的三个步骤" class="headerlink" title="使用组件的三个步骤"></a>使用组件的三个步骤</h3><ol><li>使用import语法导入需要的组件。（在script里面导入）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Left</span> <span class="keyword">from</span> <span class="string">&#x27;@/components/Left.vue&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用components结点注册组件</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">components</span>:&#123;</span><br><span class="line">        <span class="title class_">Left</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>以标签形式使用刚才注册的组件</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Left</span>&gt;</span><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通过components注册的是<strong>私有子组件</strong><br>    缺点：如果某个组件使用频率高，会很麻烦</p></blockquote><blockquote><p>注册全局组件：在vue项目的main.js入口文件中，通过Vue.components()方法，可以注册全局组件。<br>import Count from ‘@&#x2F;components&#x2F;Count.vue’<br>Vue.component(‘Count’,Count);</p></blockquote><h2 id="组件的props"><a href="#组件的props" class="headerlink" title="组件的props"></a>组件的props</h2><p>props是组件的自定义属性，在封装通用组件的时候，合理地使用props可以极大地提高组件的复用性。</p><h3 id="v-bind（父传子，加了准没错！）"><a href="#v-bind（父传子，加了准没错！）" class="headerlink" title="v-bind（父传子，加了准没错！）"></a>v-bind（父传子，加了准没错！）</h3><ul><li>当传递的是个数字，而不是data里的数据时：<ul><li>不使用v-bind传递的是字符串。</li><li>使用v-bind传递的是数字。</li></ul></li><li>当传递的是个data里面的数据时：<ul><li>不使用v-bind传递的是该数据的变量名。</li><li>使用v-bind传递的是该数据的属性值。</li></ul></li></ul><h3 id="props中的数据"><a href="#props中的数据" class="headerlink" title="props中的数据"></a>props中的数据</h3><ul><li>props中的数据，可以直接在模板结构中被使用</li><li>props中的数据是只读的，程序员不能修改props的值，否则终端会报错。<ul><li>想要修改props的值，可以把props的值转存到data中，因为data中的数据都是可读可写的。</li></ul></li></ul><h3 id="default设置默认值"><a href="#default设置默认值" class="headerlink" title="default设置默认值"></a>default设置默认值</h3><ul><li>把props改成<strong>对象形式</strong>，里面通过default指定默认值。</li><li>外界如果没有传递属性，则默认值生效</li><li>如果要给对象设置默认值：<br><img src="/assets/86269b196606447a9dc81b98e62d7831.png" alt="86269b196606447a9dc81b98e62d7831.png"></li></ul><h3 id="type定义属性的值"><a href="#type定义属性的值" class="headerlink" title="type定义属性的值"></a>type定义属性的值</h3><ul><li>在声明自定义属性时，可以通过type来定义属性的值类型</li><li>如果传递过来的值不符合此类型，则会在终端报错</li><li>Number、Boolean、String、Array、Object…</li><li>可以通过数组形式，为当前属性定义多个可能的类型。type: [Number, String]</li></ul><h3 id="require必填项"><a href="#require必填项" class="headerlink" title="require必填项"></a>require必填项</h3><ul><li>某个属性如果设置required的值为true，则必须要传递改属性。</li><li>required只关心是否传值，不关心传递类型是否符合。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">//组件的自定义属性</span></span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;自定义属性A&#x27;</span>,<span class="string">&#x27;自定义属性B&#x27;</span>,<span class="string">&#x27;其他自定义属性...&#x27;</span>],</span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="comment">//外界使用该组件，没有传这些属性，则默认值生效</span></span><br><span class="line">        自定义属性<span class="attr">A</span>:&#123;</span><br><span class="line">        <span class="attr">default</span>:默认值<span class="number">1</span>,</span><br><span class="line">         <span class="attr">type</span>:<span class="title class_">Number</span>, <span class="comment">//规定传值类型</span></span><br><span class="line">           <span class="attr">required</span>:<span class="literal">true</span> <span class="comment">//必填项校验</span></span><br><span class="line">         &#125;,</span><br><span class="line">        自定义属性<span class="attr">B</span>:&#123;<span class="attr">defalt</span>:默认值<span class="number">2</span>&#125;,   </span><br><span class="line">        自定义属性<span class="attr">C</span>:&#123;<span class="attr">defalt</span>:默认值<span class="number">3</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//组件的私有数据</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//Count.vue文件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Count的值：&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">props</span>:[<span class="string">&#x27;init&#x27;</span>],<span class="comment">//这样如果别的组件想要给Count传值的话，可以通过init来传</span></span><br><span class="line">    <span class="comment">//或</span></span><br><span class="line">    <span class="attr">props</span>:&#123;</span><br><span class="line">        <span class="attr">init</span>:&#123;</span><br><span class="line">            <span class="comment">//用default属性定义属性的默认值</span></span><br><span class="line">            <span class="attr">default</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="title class_">Number</span>,</span><br><span class="line">            <span class="attr">required</span>:<span class="literal">true</span>        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> &#123;</span><br><span class="line">           <span class="attr">count</span>:<span class="variable language_">this</span>.<span class="property">init</span>       </span><br><span class="line">       &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.vue文件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="comment">//不使用v-bind 传递的是字符串</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//使用v-bind 传递的是数字</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Count</span> <span class="attr">:init</span>=<span class="string">&quot;6&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="组件之间的样式冲突"><a href="#组件之间的样式冲突" class="headerlink" title="组件之间的样式冲突"></a>组件之间的样式冲突</h2><p>默认情况下，写在.vue里的组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。</p><h3 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h3><ul><li>单页面应用程序中，所有组件的DOM结构，都是基于唯一的index.html页面进行呈现的。</li><li>每个组件的样式，都会影响整个index.html页面的DOM元素。</li></ul><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><ul><li>给当前组件的style添加 scoped 属性。</li><li>当使用给第三方组件库的时候，如果有修改组件默认样式的需求，需要用到**&#x2F;deep&#x2F;**</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style lang=<span class="string">&quot;less&quot;</span> scoped&gt;&lt;/style&gt;</span><br></pre></td></tr></table></figure><blockquote><p>【补】：浏览器无法正常解析.vue结尾的文件<br>“vue-template-compiler”: “^2.6.11”：vue模板编译器（帮助程序员将.vue结尾的文件编译成js，再交给浏览器去解析）</p></blockquote><blockquote><p>【关于自定义属性的传值问题】：一般来说，传值不要传对象，传的是对象里的每个属性。这样可复用性强。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue2-vue基础入门（一）</title>
      <link href="/post/cda38f22.html"/>
      <url>/post/cda38f22.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue简介"><a href="#vue简介" class="headerlink" title="vue简介"></a>vue简介</h1><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><p>1.构建用户界面 </p><ul><li>用vue往html页面中填充数据，非常方便</li></ul><p>2.框架</p><ul><li>是一套现成的解决方案，程序员只能遵守框架的规范去编写自己的业务功能。</li><li>要学习vue，就是在学习vue框架中规定的用法</li><li>vue的指令、组件（对UI结构的复用）、路由、Vuex</li></ul><h2 id="vue的特性"><a href="#vue的特性" class="headerlink" title="vue的特性"></a>vue的特性</h2><h3 id="1-数据驱动视图"><a href="#1-数据驱动视图" class="headerlink" title="1.数据驱动视图"></a>1.<strong>数据</strong>驱动视图</h3><ul><li>数据的变化会驱动视图自动更新</li><li>好处：程序员只管把数据维护好，页面结构会被vue<strong>自动</strong>渲染出来。</li><li>数据驱动视图是<strong>单向的数据绑定</strong>。（页面结构的变化不会同步到数据中去）</li></ul><p><img src="/assets/c10cfbffc2504956b50579fe8e30b3e8.png" alt="c10cfbffc2504956b50579fe8e30b3e8.png"></p><h3 id="2-双向数据绑定"><a href="#2-双向数据绑定" class="headerlink" title="2.双向数据绑定"></a>2.双向<strong>数据</strong>绑定</h3><ul><li>在网页中，form表单负责<strong>采集数据</strong>，Ajax负责<strong>提交数据</strong>。</li><li>js数据的变化，会被自动渲染到页面上。</li><li>页面上表单采集的数据发生变化，会被vue自动获取，并更新到js数据中心。</li></ul><p><img src="/assets/44be56c67c1c4f308bc2cc1af57f40af.png" alt="44be56c67c1c4f308bc2cc1af57f40af.png"></p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM是vue实现<strong>数据驱动视图</strong>和<strong>双向数据绑定</strong>的核心原理。MVVM指的是<strong>M</strong>odel（数据源）、<strong>V</strong>iew（视图）、<strong>V</strong>iew<strong>M</strong>odel（vue的实例）。</p><p>他把每个HTML页面都拆成了三部分，如图：</p><p><img src="/assets/1b92f982d04042edb3f23956be6dca56.png" alt="1b92f982d04042edb3f23956be6dca56.png"></p><p>ViewModel作为MVVM的核心，他把当前页面的<strong>数据源</strong>（Model）和<strong>页面的结构</strong>（View）连接到了一起。</p><p><img src="/assets/47c551c8af3b4fca921482e5e1ec5029.png" alt="47c551c8af3b4fca921482e5e1ec5029.png"></p><h1 id="vue的基本使用"><a href="#vue的基本使用" class="headerlink" title="vue的基本使用"></a>vue的基本使用</h1><h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><p>1.导入vue.js的script脚本文件</p><p>2.在页面中声明一个将要被vue所控制的DOM区域</p><p>3.创建vm实例对象（vue实例对象）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希望vue能够控制下面这个div，帮我们填充数据</span></span><br><span class="line">&lt;div id = <span class="string">&quot;app&quot;</span>&gt;&#123;&#123; username &#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.导入vue的库文件，在window全局就有了Vue这个构造函数</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//2.创建Vue的实例对象</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//创建Vue的实例对象</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//el属性是固定写法，表示当前vm实例要控制页面上的哪个区域，接收的值是一个选择器</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//如果传的是个标签名，那么vue只会控制第一个标签。</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//data对象就是要渲染到页面上的数据</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">username</span>:<span class="string">&#x27;03&#x27;</span>        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：实际开发的时候，一般在最外层加一个div标签，id&#x3D;”app”，然后让vue控制这个最外层的div即可</p></blockquote><h2 id="基本代码和MVVM的对应关系"><a href="#基本代码和MVVM的对应关系" class="headerlink" title="基本代码和MVVM的对应关系"></a>基本代码和MVVM的对应关系</h2><p><img src="/assets/793b138f56ce4604b62a87da9524dfff.png" alt="793b138f56ce4604b62a87da9524dfff.png"></p><h1 id="vue的调试工具"><a href="#vue的调试工具" class="headerlink" title="vue的调试工具"></a>vue的调试工具</h1><p>vue-devtools工具很好用，自己去网上搜下载步骤，别忘了配置才能使用。</p><p>下载完就可以如下图所示看到了：</p><p><img src="/assets/3478b3e9f7f14ada8eeae4a107026705.png" alt="3478b3e9f7f14ada8eeae4a107026705.png"></p><h1 id="vue的指令"><a href="#vue的指令" class="headerlink" title="vue的指令"></a>vue的指令</h1><h2 id="指令的概念"><a href="#指令的概念" class="headerlink" title="指令的概念"></a>指令的概念</h2><p>指令是vue为开发者提供的模板语法，辅助开发者渲染页面的基本结构。（最基础）</p><h2 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h2><p>辅助开发者<strong>渲染DOM元素</strong>的文本内容。</p><h3 id="1）v-text指令"><a href="#1）v-text指令" class="headerlink" title="1）v-text指令"></a>1）v-text指令</h3><ul><li>缺点：会覆盖元素内部原有的内容。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//覆盖“姓名”</span></span><br><span class="line">&lt;p v-text=<span class="string">&quot;username&quot;</span>&gt;姓名&lt;/p&gt; </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="2）语法"><a href="#2）语法" class="headerlink" title="2）语法"></a>2）语法</h3><ul><li>语法的专业名称是**插值表达式**（英文名是：Mustache）</li><li>专门用来解决v-text的内容覆盖问题，只是内容的占位符，不会覆盖原有内容。</li><li>注意：插值表达式只能用于元素的内容结点中，不能用于元素的属性节点中。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;姓名：&#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="3）v-html指令"><a href="#3）v-html指令" class="headerlink" title="3）v-html指令"></a>3）v-html指令</h3><p><strong>v-text</strong>和<strong>插值表达式</strong>只能渲染<strong>纯文本</strong>内容。如果要把<strong>包含HTML标签的字符串</strong>渲染为页面的HTML元素，则使用v-html指令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//info里面包含了HTML标签</span></span><br><span class="line">&lt;p v-html=<span class="string">&quot;info&quot;</span>&gt;姓名&lt;/p&gt; </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h2><p>需要为元素的属性<strong>动态绑定属性值</strong>，则用到<strong>v-bind</strong>属性绑定指令。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-<span class="attr">bind</span>:placeholder=<span class="string">&quot;tips&quot;</span>&gt;</span><br><span class="line"><span class="comment">//vue 规定 &quot;v-bind:&quot; 指令可以简写为 &quot;:&quot;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:placeholder</span>=<span class="string">&quot;tips&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="使用JavaScript表达式"><a href="#使用JavaScript表达式" class="headerlink" title="使用JavaScript表达式"></a>使用JavaScript表达式</h2><p>在vue提供的模板渲染语法中，除了支持<strong>绑定简单的数据值</strong>之外，还支持<strong>JavaScript表达式的运算</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number+<span class="number">1</span> &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? <span class="string">&#x27;YES&#x27;</span> : <span class="string">&#x27;NO&#x27;</span> &#125;&#125;</span><br><span class="line"><span class="comment">//在使用v-bind属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号</span></span><br><span class="line">&lt;div :title=<span class="string">&quot; &#x27;box-&#x27; + index &quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="事件绑定指令"><a href="#事件绑定指令" class="headerlink" title="事件绑定指令"></a>事件绑定指令</h2><h3 id="1-事件绑定指令"><a href="#1-事件绑定指令" class="headerlink" title="1.事件绑定指令"></a>1.事件绑定指令</h3><p>vue提供了v-on事件绑定指令，来辅助程序员为DOM元素监听事件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id = <span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//如果没有参数的话，可以不加()</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span> = <span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span> = <span class="string">&quot;sub(2)&quot;</span>&gt;</span>-2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//v-on: 指令可以被简写成 @</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&quot;sub(3)&quot;</span>&gt;</span>-3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="comment">//vue提供了内置变量，叫做$event，他就是原生DOM的事件对象e</span></span><br><span class="line">    <span class="comment">//如果默默认的事件对象e被覆盖了，则可以手动传一个$event</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span> = <span class="string">&quot;add(2,$event)&quot;</span>&gt;</span>+2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">count</span>:<span class="number">0</span>        </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//定义事件的处理函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">add</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//vm.count++;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="comment">//this可以替代vm</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">count</span>++;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//以上代码可以简写成：</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">sub</span>(<span class="params">n</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">count</span>-=<span class="number">2</span>;         </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="comment">//按下按钮后自增2，并且按钮颜色变为红色</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="title function_">red</span>(<span class="params">n,e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="variable language_">this</span>.<span class="property">count</span>+=<span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;red&#x27;</span>;            </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;    </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：原生DOM对象有onclick、oninput、onkeyup等原生事件，替换为vue的事件绑定形式后，分别为@click、@input、@keyup</p></blockquote><h3 id="2-事件修饰符"><a href="#2-事件修饰符" class="headerlink" title="2.事件修饰符"></a>2.事件修饰符</h3><p>在事件处理函数中调用event.preventDefault()或event.stopPropagation()是非常常见的需求。因此，vue提供了事件修饰符的概念，用来辅助程序员更方便的对事件的触发进行控制。</p><p><img src="/assets/a9c17ac39605413bb53b6fd10087d4cb.png" alt="a9c17ac39605413bb53b6fd10087d4cb.png"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阻止默认行为  阻止a链接跳转</span></span><br><span class="line">&lt;a @click.<span class="property">prevent</span>=<span class="string">&quot;show&quot;</span>&gt;a链接&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻止事件冒泡（点击里面的标签，会先触发里面的click再触发外面的click）</span></span><br><span class="line"><span class="comment">//不阻止冒泡的话：点击button按钮，会先调用fun1()，再调用fun2()</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;fun2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span> = <span class="string">&quot;fun1&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="3-按键修饰符"><a href="#3-按键修饰符" class="headerlink" title="3.按键修饰符"></a>3.按键修饰符</h3><p>在监听键盘事件时，我们需要判断详细的按键。此时，可以为键盘相关的事件添加按键修饰符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> @keyup.<span class="property">esc</span>=<span class="string">&quot;clearInput&quot;</span> @click.<span class="property">enter</span>=<span class="string">&quot;commitAjax&quot;</span>&gt;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//清空文本框操作</span></span><br><span class="line">    <span class="title function_">clearInput</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        e.<span class="property">target</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">commitAjax</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;enter键按下,commitAjax()方法被调用&quot;</span>)    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="双向绑定指令"><a href="#双向绑定指令" class="headerlink" title="双向绑定指令"></a>双向绑定指令</h2><p>vue提供了v-model双向数据绑定指令，用来辅助开发者在不操作DOM的前提下，快速获取表单的数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v-model是双向的数据绑定（此时可以不用在使用value属性了）</span></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line"><span class="comment">//v-blind是单向的数据绑定（数据源的变化会同步到页面上，但是页面上的变化不会同步到数据源）</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：只有表单元素使用v-model才有意义。div如果使用了v-model，没有意义；因为div并不能够修改它里面的数据。</p><p>使用范围：</p><ul><li>textarea</li><li>select</li><li>input输入框 <ul><li>type&#x3D;”xxx”</li><li>type&#x3D;”checkbox”</li><li>type&#x3D;”radio”</li></ul></li></ul></blockquote><h3 id="v-model指令的修饰符"><a href="#v-model指令的修饰符" class="headerlink" title="v-model指令的修饰符"></a>v-model指令的修饰符</h3><p>为了方便对用户输入的内容进行处理。</p><p><img src="/assets/b3929077e43d410e8710a5d134c6ee54.png" alt="b3929077e43d410e8710a5d134c6ee54.png"></p><h2 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h2><p>辅助开发者按需控制DOM的显示与隐藏。</p><ul><li>v-if（常用） <ul><li>原理：每次动态创建或移除元素，来实现元素的显示和隐藏</li><li>如果刚进入页面的时候，某些元素默认不需要被显示，而且后期这个元素很可能也不需要被展示出来，此时v-if性能会更好。</li><li>常与v-else-if（出现率低） 和 v-else （常用）配套使用 【v-else-if指令必须配合v-if一起使用，否则它将不会被识别！】</li></ul></li><li>v-show <ul><li>原理：动态为元素添加或移除 style&#x3D;”display:none;” 样式，来实现元素的显示和隐藏。</li><li>如果要频繁的切换元素的显示状态，用v-show性能更好</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p v-<span class="keyword">if</span>=<span class="string">&quot;flag&quot;</span>&gt;这是被v-<span class="keyword">if</span>控制的元素&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-ishow</span>=<span class="string">&quot;flag&quot;</span>&gt;</span>这是被v-show控制的元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h2><p>用来辅助开发者<strong>基于一个数组来循环渲染一个列表结构</strong>。</p><p>v-for指令需要使用 <strong>item in items</strong> 形式的特殊语法，其中：</p><ul><li>items是<strong>待循环的数组</strong></li><li>item是<strong>被循环的每一项</strong></li></ul><p>v-for中的索引：</p><ul><li>语法格式：**(item,index) in items**</li></ul><p>v-for中的key值：</p><ul><li>官方建议，只要用到v-for，一定要绑定一个 :key 属性，而且尽量<strong>把id作为key的值（避免重复）</strong>。</li><li>key的值只能是字符串或数字类型。</li><li>key值不能重复，否则会中断报错。【Duplicate keys detected】</li><li>使用index的值当做key的值没有任何意义（index的值不具有唯一性）。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="comment">//列表数据</span></span><br><span class="line">    <span class="attr">list</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">&#x27;小林&#x27;</span>&#125; ,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">&#x27;03&#x27;</span>&#125;   </span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&lt;ul v-<span class="keyword">for</span>=<span class="string">&quot;(item,index) in list&quot;</span> :key=<span class="string">&quot;item.id&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>   <span class="comment">//从0开始</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="过滤器（vue3无了）"><a href="#过滤器（vue3无了）" class="headerlink" title="过滤器（vue3无了）"></a>过滤器（vue3无了）</h1><h2 id="过滤器的概念"><a href="#过滤器的概念" class="headerlink" title="过滤器的概念"></a>过滤器的概念</h2><p>过滤器（Filter）是vue为开发者提供的功能，常用于文本的格式化。【本质：函数】</p><h2 id="过滤器注意点"><a href="#过滤器注意点" class="headerlink" title="过滤器注意点"></a>过滤器注意点</h2><ul><li>由“管道符”进行调用。</li><li>在过滤器的形参中，就可以获取到“管道符”前面待处理的那个值。</li><li>必须被定义到filters节点之下，且一定要有返回值。</li><li>可以串联调用过滤器。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前一个过滤器的返回值作为后一个过滤器的参数</span></span><br><span class="line">&#123;&#123; message | cap1 | cap2 &#125;&#125;  </span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul><li>插值表达式</li><li>v-bind属性绑定</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插值表达式：</span></span><br><span class="line"><span class="comment">//在双花括号中调用capitalize过滤器函数，对message的值进行格式化</span></span><br><span class="line"><span class="comment">//p标签里看到的是capitalize(message)函数的返回值</span></span><br><span class="line">&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="attr">data</span>:&#123;</span><br><span class="line">    <span class="attr">message</span>:<span class="string">&#x27;helloworld&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//过滤器函数必须被定义到filters节点之下</span></span><br><span class="line"><span class="attr">filters</span>:&#123;</span><br><span class="line">    <span class="comment">//val就是message的值</span></span><br><span class="line">    <span class="title function_">capitalize</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="comment">//字符串有charAt方法，表示从字符串中把索引对应的字符获取出来</span></span><br><span class="line">        <span class="keyword">const</span> first = val.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>();</span><br><span class="line">        <span class="comment">//字符串的slice方法，可以截取字符串，从指定索引往后截取</span></span><br><span class="line">        <span class="keyword">const</span> other = val.<span class="title function_">slice</span>(<span class="number">1</span>);<span class="comment">//从索引为1一直截取到最后</span></span><br><span class="line">        <span class="keyword">return</span> first+other;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="私有过滤器和全局过滤器"><a href="#私有过滤器和全局过滤器" class="headerlink" title="私有过滤器和全局过滤器"></a>私有过滤器和全局过滤器</h2><ul><li>私有过滤器 <ul><li>在filters里面定义的是全局过滤器。</li><li>只能在当前vm实例所控制的el区域内使用。</li><li>不会和别的vm实例共享过滤器。</li></ul></li><li>全局过滤器（常用） <ul><li>独立于每个vm实例之外</li><li>第2个参数：全局过滤器的“处理函数”</li><li>第1个参数：全局过滤器的“名字”</li></ul></li></ul><blockquote><p>【注】：全局过滤器和私有过滤器重名，此时调用的是私有过滤器。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capitalize&#x27;</span>,<span class="function">(<span class="params">str</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>【注】：编码规范：先指令，再属性，最后绑定事件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> vue2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> vue2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript6新特性</title>
      <link href="/post/daf3c6fd.html"/>
      <url>/post/daf3c6fd.html</url>
      
        <content type="html"><![CDATA[<h1 id="let变量声明以及声明特性"><a href="#let变量声明以及声明特性" class="headerlink" title="let变量声明以及声明特性"></a>let变量声明以及声明特性</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> a,b,c;</span><br><span class="line"><span class="keyword">let</span> a=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>let变量不能重复声明，但是var却可以。</li><li>块级作用域：变量只在代码块里有效，在代码块外无效。[全局、函数、eval]</li><li>不存在变量提升。（如果有变量提升，可以在变量未声明之前去使用这个变量）</li><li>不影响作用域链。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&quot;xiaolin0333&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name);<span class="comment">//会向上一级作用域里去找name变量    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const声明常量及其特点"><a href="#const声明常量及其特点" class="headerlink" title="const声明常量及其特点"></a>const声明常量及其特点</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">NAME</span> = <span class="string">&quot;xiaolin0333&quot;</span>;</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>一定要赋初始值。</li><li>一般常量使用大写（潜规则）</li><li>常量值不能修改。</li><li>块级作用域</li><li>对于数组和对象的元素修改，不算对常量的修改，不会报错</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">DATA</span> = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;cmb&#x27;</span>];</span><br><span class="line"><span class="variable constant_">DATA</span>.<span class="title function_">push</span>(<span class="string">&#x27;dog&#x27;</span>);<span class="comment">//正确 常量所指的地址没有发生变化</span></span><br><span class="line"><span class="variable constant_">DATA</span> = <span class="number">100</span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure><blockquote><p>以后声明数组或者对象的时候使用const来声明可以避免误操作</p><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><p>ES6允许按照一定模式从数组和对象中提取值，对变量进行操作。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组的解构</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">F2</span> = [<span class="string">&#x27;lsh&#x27;</span>,<span class="string">&#x27;cmb&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [lin, chai] = <span class="variable constant_">F2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lin + chai);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的解构</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiaolin0333&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">    <span class="attr">dadaima</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我可以打代码&#x27;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name,age,dadaima&#125; = lin;<span class="comment">//相当于声明了三个变量，还对他们进行了赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name + age);</span><br><span class="line"><span class="title function_">dadaima</span>();</span><br></pre></td></tr></table></figure><blockquote><p>【注】：一般函数使用解构的方法来写居多</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;dadaima&#125; = lin;<span class="comment">//但是let&#123;&#125;里面的dadaima需要和lin里面的dadaima函数同名才行</span></span><br><span class="line"><span class="title function_">dadaima</span>();</span><br></pre></td></tr></table></figure><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>ES6引入新的声明字符串的方式<code>``</code><br>ES5：<code>&#39; &#39;</code>或<code>&quot; &quot;</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">`我也是个字符串`</span>;</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>内容里可以直接出现换行符（单引号、双引号不能直接出现换行符、只能用+来连接）</li><li>可以通过<code>$&#123;变量名&#125;</code>进行变量拼接</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lin = <span class="string">&#x27;xiaolin0333&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> wo = <span class="string">`我是<span class="subst">$&#123;lin&#125;</span></span></span><br></pre></td></tr></table></figure><h1 id="简化对象写法"><a href="#简化对象写法" class="headerlink" title="简化对象写法"></a>简化对象写法</h1><p>ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法，这样的书写会更加简洁。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;xiaolin0333&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> dadaima = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我爱打代码&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    name,</span><br><span class="line">    dadaima</span><br><span class="line">    <span class="title function_">paobu</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我也爱跑步&#x27;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于如下代码</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    name = name,</span><br><span class="line">    dadaima = dadaima</span><br><span class="line">    <span class="attr">paobu</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我也爱跑步&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6允许使用箭头<code>=&gt;</code>来定义函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="keyword">let</span> 函数名 = <span class="function">(<span class="params">形参</span>) =&gt;</span> &#123;</span><br><span class="line">    代码体</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params">a,b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>特性：</p><ol><li>this是静态的，this始终指向函数声明时所在作用域下的 this的值。<br>（普通函数是：谁调用该函数，这个this就指向谁）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getName2</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置window对象的name属性</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">name</span> = <span class="string">&#x27;xiaolin0333&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;03&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接调用</span></span><br><span class="line"><span class="title function_">getName</span>();<span class="comment">//输出：xiaolin0333（普通函数直接调用this值指向window）</span></span><br><span class="line"><span class="title function_">getName2</span>();<span class="comment">//输出：xiaolin0333（箭头函数在全局作用域下声明的，this也是指向window）</span></span><br><span class="line"><span class="comment">//call()方法调用（可以改变函数内部的this值）</span></span><br><span class="line">getName.<span class="title function_">call</span>(lin);<span class="comment">//输出：03（此时函数内部的this值指向了lin这个对象）</span></span><br><span class="line">getName2.<span class="title function_">call</span>(lin);<span class="comment">//输出：xiaolin0333（箭头函数this值静态的，仍然指向函数在声明时所在作用域的this值）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>不能作为构造函数实例化对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = (name,age) = &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;lin&#x27;</span>,<span class="number">20</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ol start="3"><li>不能使用arguments变量</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(argument);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ol start="4"><li>箭头函数的简写</li></ol><ul><li>省略小括号。（当形参有且仅有一个的时候）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> n+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面代码可以简写成如下代码</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = n =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> n+n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>省略花括号。（当代码体仅有一条语句的时候）</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">pow</span> = (<span class="params">n</span>) =&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> n*n; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//上面代码可以简写成如下代码</span></span><br><span class="line"> <span class="keyword">let</span> <span class="title function_">pow</span> = n =&gt;n*n;</span><br></pre></td></tr></table></figure><blockquote><p>【注】此时return也必须省略，而且语句的结构就是函数的返回值</p></blockquote><p>【适用场景】：</p><ol><li>箭头函数适合与this无关的回调（定时器、数组的方法回调）</li><li>箭头函数不适合与this有关的回调（DOM元素的事件回调，对象的方法）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ad = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ad&#x27;</span>);</span><br><span class="line"><span class="comment">//绑定事件</span></span><br><span class="line">ad.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//保存this的值</span></span><br><span class="line">    <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">//定时器的this指向window 所以需要外面定义一个_this 才能在定时器回调函数里面使用</span></span><br><span class="line">        <span class="comment">//修改背景颜色 this</span></span><br><span class="line">        _this.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;pink&#x27;</span>;   </span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用箭头函数就可以解决这个问题</span></span><br><span class="line">ad.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//这里不能改成箭头函数，否则this就无法指向事件源</span></span><br><span class="line">    <span class="comment">//定时器</span></span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="comment">//箭头函数的this是静态的，指向声明时所在作用域下的值，而这个定时器函数是在外层作用域下声明的，外层作用域里的this指向事件源ad</span></span><br><span class="line">        _this.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;pink&#x27;</span>;   </span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="函数参数的默认值设置"><a href="#函数参数的默认值设置" class="headerlink" title="函数参数的默认值设置"></a>函数参数的默认值设置</h1><p>ES6允许给函数参数（形参）赋初始值<br>特性：</p><ol><li>具有默认值的参数，一般位置要靠后。（潜规则）【放前面意义不大，因为实参也会按顺序与实参对应】</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b,c=<span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>));<span class="comment">//13</span></span><br></pre></td></tr></table></figure><ol start="2"><li>默认值可以与解构赋值结合使用</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> host = options.<span class="property">host</span>;</span><br><span class="line">    <span class="keyword">let</span> username = options.<span class="property">username</span>; <span class="comment">//代码冗余度比较高  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用函数（传一个对象）</span></span><br><span class="line"><span class="title function_">connect</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">username</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">3306</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//函数声明简便写法如下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params">&#123;host=<span class="string">&quot;127.0.0.1&quot;</span>,username,password,port&#125;</span>) &#123;<span class="comment">//使用解构赋值就不是“实参按顺序与形参对应了”</span></span><br><span class="line">    <span class="keyword">let</span> host = host;</span><br><span class="line">    <span class="keyword">let</span> username = username; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h1><p>ES6引入rest（数组）参数，用于获取函数的实参，用来代替arguments（对象）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ES5获取实参的方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);<span class="comment">//是个对象形式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">data</span>(<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"><span class="comment">//rest参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">data</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args);<span class="comment">//是个数组的格式 可以使用数组的很多方法(filter some every map)使我们对参数处理更灵活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">data</span>(<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>);</span><br><span class="line"><span class="comment">//[注]rest参数必须放在参数最后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a,b,...args</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h1><p>扩展运算符<code>...</code> 能够将数组转化为逗号分割的参数序列</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lin = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>];</span><br><span class="line"><span class="comment">//把lin数组变成这种形式   &#x27;xiaolin&#x27;,&#x27;03&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">name</span>(...lin);<span class="comment">//等价于name(&#x27;xiaolin&#x27;,&#x27;03&#x27;)</span></span><br></pre></td></tr></table></figure><blockquote><p>扩展运算符和rest区别：rest参数的声明是放在了函数声明的形参位置，扩展运算符<code>...</code>是放在函数调用的实参位置</p></blockquote><p>【应用】</p><ol><li>数组的合并</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name1 = [<span class="string">&#x27;xiaolin&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> name2 = [<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;33&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> name = [...name1,...name2];<span class="comment">//合并name1和name2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>数组的克隆</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;33&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> me = [...name];<span class="comment">//克隆name数组到me数组里</span></span><br></pre></td></tr></table></figure><blockquote><p>【注】如果有引用类型，也是一个浅拷贝</p></blockquote><ol start="3"><li>将伪数组转为真正的数组</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);<span class="comment">//divs得到的是个伪数组</span></span><br><span class="line"><span class="keyword">const</span> divArr = [..<span class="property">divs</span>];<span class="comment">//divArr是真正的数组</span></span><br></pre></td></tr></table></figure><h1 id="Symbol的介绍与创建"><a href="#Symbol的介绍与创建" class="headerlink" title="Symbol的介绍与创建"></a>Symbol的介绍与创建</h1><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。他是JavaScript语言的第七种数据类型，是一种类似于字符串的数据类型。<br>【特点】：</p><ol><li>Symbol的值是唯一的，用来解决命名冲突的问题</li><li>Symbol值不能与其他数据类型进行运算（加减乘除、字符串拼接、比较）</li><li>Symbol定义的对象属性不能使用for…in循环遍历，但是可以使用Reflect.ownKeys来获取对象的所有键名</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Symbol</span></span><br><span class="line"><span class="comment">//法1</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="comment">//法2</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;xiaolin&#x27;</span>);<span class="comment">//Symbol里面的字符串（描述字符串）相当于是做一个注释</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;xiaolin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2===s3);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//法3</span></span><br><span class="line"><span class="keyword">let</span> s4 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;xiaolin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s5 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;xiaolin&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s4===s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = s+s;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><blockquote><p>【总结】：7种数据类型<br>undefined、string、symbol、object、null、number、boolean</p></blockquote><h2 id="Symbol的使用"><a href="#Symbol的使用" class="headerlink" title="Symbol的使用"></a>Symbol的使用</h2><p>向对象中添加属性和方法（如果给一个别人写的对象添加方法up()，不确定是否已经有这个方法，就可以使用Symbol来添加，更加简单高效安全。）<br>【例】：game是一个别人写的对象，我现在要添加up()和down()方法到这个对象里，但是不确定这个game对象里面是否已经存在这两个方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> game = &#123;...&#125;<span class="comment">//别人写的一个对象</span></span><br><span class="line"><span class="comment">//声明一个对象</span></span><br><span class="line"><span class="keyword">let</span> methods = &#123;</span><br><span class="line">    <span class="attr">up</span>:<span class="title class_">Symbol</span>(),</span><br><span class="line">    <span class="attr">down</span>:<span class="title class_">Symbol</span>()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将这两个方法添加到对象中</span></span><br><span class="line">game[methods.<span class="property">up</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是up()方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">game[methods.<span class="property">down</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是down()方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> youxi = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;狼人杀&quot;</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;say&#x27;</span>)]:<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//因为Symbol()是个表达式，所以这里要加上[]</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我可以发言&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;zibao&#x27;</span>)]:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我可以自爆&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Symbol内置值"><a href="#Symbol内置值" class="headerlink" title="Symbol内置值"></a>Symbol内置值</h2><p>除了定义自己使用的Symbol值之外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法<br>【例】Symbol.hasInstance：当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](param) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(param);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;类型检测的时候调用我&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(o <span class="keyword">instanceof</span> <span class="title class_">Person</span>);<span class="comment">//输出：&#123;&#125;</span></span><br><span class="line">    <span class="comment">//   类型检测的时候调用我</span></span><br><span class="line">           <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Symbol.hasInstance都是Symbol内部的属性，这个整体又作为对象里边的属性，来改变对象在特定场景下的表现（扩展对象功能）</p></blockquote><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器（Iterator）是一种接口，为不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p><ol><li>ES6创建了一种新的遍历命令for…of循环。（只要数据结构部署了Interator接口，就可以使用for…of来遍历数据）</li><li>原生具备Interator接口的数据（可用for…of遍历）：Array、Arguments、set、Map、String、TypedArray、NodeList</li></ol><p>Interator就是指：对象里的一个函数Symbol（Symbol.Interator)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个数组</span></span><br><span class="line"><span class="keyword">const</span> lin = [<span class="string">&#x27;xiaolin&#x27;</span>,<span class="string">&#x27;03&#x27;</span>,<span class="string">&#x27;33&#x27;</span>];</span><br><span class="line"><span class="comment">//使用for...of遍历数组(v是键值)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> lin) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lin);<span class="comment">//输出 xiaolin 03 33</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对比for...in遍历数组(v是键名)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">in</span> lin) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lin);<span class="comment">//输出 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【应用】：需要自定义遍历数据的时候，要想到迭代器。<br>【例】：使用for…of遍历对象，每次返回结果是数组stus的成员</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个对象</span></span><br><span class="line"><span class="keyword">const</span> banji = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;物联网二班&#x27;</span>,</span><br><span class="line">    <span class="attr">stus</span>:[</span><br><span class="line">        <span class="string">&#x27;xiaolin&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;03&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;33&#x27;</span>                    </span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">//自定义迭代器</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">interator</span>]() &#123;</span><br><span class="line">        <span class="comment">//索引变量</span></span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">next</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(index&lt;_this.<span class="property">stus</span>.<span class="property">length</span>) &#123;<span class="comment">//this指向的不是banji这个对象（也可以使用箭头函数） </span></span><br><span class="line">                    <span class="keyword">const</span> result = &#123;<span class="attr">value</span>:_this.<span class="property">stus</span>[index],<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">                    index++;                </span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="literal">undefined</span>,<span class="attr">done</span>:<span class="literal">true</span>&#125;;                </span><br><span class="line">                &#125;</span><br><span class="line">                           </span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//banji.stus.forEach();//也可以遍历stus数组的成员，但是不符合面向对象的思想。（不能直接对数据成员操作）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> banji) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义迭代器工作原理如下：</p><ol><li>创建一个对象，指向当前数据结构的起始位置</li><li>第一次调用对象的next方法(规定就叫做next方法)，指针自动指向数据结构的第一个成员</li><li>接下来不断调用next方法，指针一直向后移动，直到指向最后一个成员</li><li>每次调用next方法返回一个包含value和done属性的对象<br>如果指针所指向的成员有定义，{value:指针所指成员,done:false}，否则{value:undefined,done:true}</li></ol></blockquote><h1 id="生成器函数生命与调用"><a href="#生成器函数生命与调用" class="headerlink" title="生成器函数生命与调用"></a>生成器函数生命与调用</h1><p>生成器是一个特殊函数，用来进行异步编程（纯回调函数）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：function * 函数名() &#123;&#125;</span></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//yield等价于函数代码的分隔符（把函数代码分割成几块）</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;一只没有眼睛&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;一只没有尾巴&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;真奇怪&#x27;</span>;</span><br><span class="line">    <span class="comment">//gen()返回迭代器对象(如果里面有console.log的话，不会输出里面的内容，得调用next()方法才能执行)</span></span><br><span class="line">    <span class="keyword">let</span> interator = <span class="title function_">gen</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:&quot;一只没有眼睛&quot;,done:false&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:&quot;一只没有眼睛&quot;,done:false&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:&quot;真奇怪&quot;,done:false&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(interator.<span class="title function_">next</span>());<span class="comment">//&#123;value:undefined,done:true&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> <span class="title function_">gen</span>()) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(v); <span class="comment">//输出：一只没有眼睛     一只没有眼睛      真奇怪</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【参数传递】</p><ol><li>整体函数传参</li><li>next方法传参</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">gen</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg);</span><br><span class="line">    <span class="keyword">let</span> one = <span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(one);</span><br><span class="line">    <span class="keyword">let</span> two = <span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(two);</span><br><span class="line">    <span class="keyword">let</span> three = <span class="keyword">yield</span> <span class="number">333</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(three)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行迭代器对象</span></span><br><span class="line"><span class="keyword">let</span> interator = <span class="title function_">gen</span>(<span class="string">&#x27;AAA&#x27;</span>); <span class="comment">// 整体函数传参</span></span><br><span class="line"><span class="comment">// 以下都是next方法传参</span></span><br><span class="line">interator.<span class="title function_">next</span>();<span class="comment">//输出：AAA</span></span><br><span class="line"><span class="comment">//next方法可以传入实参（作为上一个yield的返回结果）</span></span><br><span class="line"><span class="comment">//下面代码传入BBB，作为第一个yield语句整个的返回结果</span></span><br><span class="line">interator.<span class="title function_">next</span>(<span class="string">&#x27;BBB&#x27;</span>);<span class="comment">//输出：BBB</span></span><br><span class="line"><span class="comment">//下面代码传入CCC，作为第二个yield语句整个的返回结果</span></span><br><span class="line">interator.<span class="title function_">next</span>(<span class="string">&#x27;CCC&#x27;</span>);<span class="comment">//输出：CCC</span></span><br><span class="line"><span class="comment">//下面代码传入DDD，作为第三个yield语句整个的返回结果</span></span><br><span class="line">interator.<span class="title function_">next</span>(<span class="string">&#x27;DDD&#x27;</span>);<span class="comment">//输出：DDD</span></span><br></pre></td></tr></table></figure><p>【生成器函数实例】：异步编程：文件操作、网络操作（ajax、requests）、数据库操作<br>【例】：定时器案例（1s后控制台输出111  2s后控制台输出222  3s后控制台输出333）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传统方法</span></span><br><span class="line"><span class="comment">//代码缩进不断向前缩进，阅读调试不方便（回调地狱）</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);        </span><br><span class="line">        &#125;,<span class="number">3000</span>);    </span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成器函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">one</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">        interator.<span class="title function_">next</span>();</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">two</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>);</span><br><span class="line">        interator.<span class="title function_">next</span>();    </span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">three</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">333</span>);    </span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">one</span>();</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">two</span>();</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">three</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用生成器函数</span></span><br><span class="line"><span class="keyword">let</span> interator = <span class="title function_">gen</span>();</span><br><span class="line">interator.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise是ES6引入的异步编程的解决方案（主要解决回调地狱的问题）。语法上Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化Promise对象（有三种状态：初始化、成功、失败）</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="comment">//异步操作</span></span><br><span class="line">        <span class="keyword">if</span>(成功)&#123;</span><br><span class="line">             <span class="keyword">let</span> data = <span class="string">&#x27;数据库中的用户数据&#x27;</span>;<span class="comment">//得到数据</span></span><br><span class="line">        <span class="comment">//调用resolve()和reject()方法可以改变Promise对象的状态</span></span><br><span class="line">       <span class="title function_">resolve</span>(data);<span class="comment">//调用resolve()方法，Promise对象p的状态为成功===&gt;then()方法执行第一个回调函数的内容       </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//失败</span></span><br><span class="line">        <span class="keyword">let</span> err = <span class="string">&#x27;数据读取失败&#x27;</span>;</span><br><span class="line">           <span class="title function_">reject</span>(err);<span class="comment">//调用reject()方法，Promise对象p的状态为失败===&gt;then()方法执行第二个回调函数的内容                  </span></span><br><span class="line">        &#125;                                                                                                             </span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用Promise对象的then方法(返回结果是Promise对象，对象状态由回调函数的执行结果决定)</span></span><br><span class="line">    <span class="comment">//1.如果回调函数中返回结果是：非Promise类型的属性(无返回值undefined 也算非Promise类型)，状态为成功。返回值为对象的成功值</span></span><br><span class="line">    <span class="comment">//2.如果回调函数中返回结果是：Promise对象，返回值和then方法返回的值类型是一样的</span></span><br><span class="line">    <span class="comment">//3.如果回调函数中返回的是：抛出错误，then方法返回值状态也是失败</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> result = p.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">value</span>) &#123;<span class="comment">//调用成功的形参</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value);<span class="comment">//成功时输出：数据库中的用户数据</span></span><br><span class="line">        <span class="comment">//1.非Promise类型的属性</span></span><br><span class="line">        <span class="comment">//return 123;  </span></span><br><span class="line">        <span class="comment">//2.是promise对象</span></span><br><span class="line">        <span class="comment">//return new Promise((resolve,reject)=&gt; &#123;</span></span><br><span class="line">            <span class="comment">//resolve(&#x27;ok&#x27;);//返回成功，then方法也返回成功        </span></span><br><span class="line">        <span class="comment">//&#125;)</span></span><br><span class="line">        <span class="comment">//3.抛出错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;出错啦&#x27;</span>);</span><br><span class="line">    &#125;,<span class="keyword">function</span>(<span class="params">reason</span>) &#123;<span class="comment">//调用失败的形参</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(reason);<span class="comment">//失败时输出：数据读取失败</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//综上所述</span></span><br><span class="line"><span class="comment">//then方法可以链式调用</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span> &#123;&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;,<span class="function"><span class="params">reason</span>=&gt;</span>&#123;&#125;)</span><br><span class="line"><span class="comment">//也可以只指定一个回调</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">value</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>ES6提供了新的数据结构Set（集合）。它类似于数组，但成员的值唯一，集合实现了Iterator接口，所以可以使用扩展运算符和for…of进行遍历。<br>【声明一个set】：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;大事&#x27;</span>,<span class="string">&#x27;小事&#x27;</span>,<span class="string">&#x27;坏事&#x27;</span>,<span class="string">&#x27;小事&#x27;</span>]);<span class="comment">//可以传入一个可迭代数据（一般传入数组）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2);<span class="comment">//&#x27;大事&#x27;,&#x27;小事&#x27;,&#x27;坏事&#x27;  ==&gt;  自动去重</span></span><br></pre></td></tr></table></figure><p>【元素个数】：不包括重复元素size</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="property">size</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>【增】：添加新的元素add()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s2.<span class="title function_">add</span>(<span class="string">&#x27;喜事&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2);<span class="comment">//&#x27;大事&#x27;,&#x27;小事&#x27;,&#x27;坏事&#x27;,&#x27;喜事&#x27;</span></span><br></pre></td></tr></table></figure><p>【删】：删除元素delete()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s2.<span class="title function_">delete</span>(<span class="string">&#x27;坏事&#x27;</span>);<span class="comment">//&#x27;大事&#x27;,&#x27;小事&#x27;,&#x27;喜事&#x27;</span></span><br></pre></td></tr></table></figure><p>【是否存在】：检测has()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="title function_">has</span>(<span class="string">&#x27;好事&#x27;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>【遍历】：使用for…of遍历集合</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> s2) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【清空】：清空clear()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s2.<span class="title function_">clear</span>());<span class="comment">//集合里内容为空</span></span><br></pre></td></tr></table></figure><p>【集合实践】：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//集合实践：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="comment">//1.数组去重</span></span><br><span class="line"><span class="comment">//let result = new Set(arr);//此时result是个集合（集合可以自动去重）</span></span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)];<span class="comment">//通过扩展运算符把result集合改成数组==&gt;此时的数组已经是去除重复元素后的数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.交集arr ∩ arr2</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> result = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)].<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;<span class="comment">//数组先去重 再使用过滤器过滤相同的元素</span></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="title class_">Set</span>(arr2);</span><br><span class="line">    <span class="keyword">if</span>(s2.<span class="title function_">has</span>(item)) &#123;<span class="comment">//s2里有arr数组去重后的元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);<span class="comment">//[4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.并集</span></span><br><span class="line"><span class="keyword">let</span> union = [...arr,...arr2];<span class="comment">//合并两个数组，此时存在重复元素</span></span><br><span class="line">union = [...union];<span class="comment">//把重复的元素去除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.差集====&gt;就是交集取反</span></span><br></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>ES6提供了Map数据结构，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。Map也实现了Iterator接口，所以可以使用扩展运算符和for…in进行遍历。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明Map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br></pre></td></tr></table></figure><p>【增】：添加元素 对象.set(键,值)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;xiaolin03&#x27;</span>);<span class="comment">//key:&quot;name&quot;  value:&quot;xiaolin03&quot;</span></span><br><span class="line">m.<span class="title function_">set</span>(<span class="string">&#x27;hobby&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我爱打代码&#x27;</span>);<span class="comment">//key:&quot;hobby&quot;   value:f()</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> key = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiaolin03&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">m.<span class="title function_">set</span>(key,[<span class="string">&#x27;宁德&#x27;</span>,<span class="string">&#x27;厦门&#x27;</span>,<span class="string">&#x27;福州&#x27;</span>]);<span class="comment">//key:&#123;name:&quot;xiaolin03&quot;&#125;   value:[&#x27;宁德&#x27;,&#x27;厦门&#x27;,&#x27;福州&#x27;]  ====&gt;键：对象 值：数组</span></span><br></pre></td></tr></table></figure><p>【元素个数】：获取元素个数  对象.size</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">size</span>);<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>【删】：删除  对象.delete(键)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">delete</span>(<span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><p>【取】：获取  对象.get(键)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">get</span>(<span class="string">&#x27;hobby&#x27;</span>);</span><br><span class="line">m.<span class="title function_">get</span>(key);</span><br></pre></td></tr></table></figure><p>【遍历】：for…of遍历</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> m) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v);<span class="comment">//v是一个数组，第一个元素是键，第二个元素是值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【清空】：对象.chear();</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.<span class="title function_">clear</span>();<span class="comment">//清空对象</span></span><br></pre></td></tr></table></figure><h1 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h1><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。作为对象的模板。通过class关键字可以定义类。基本上，ES6的class可以看做只是一个语法糖，他的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法  名字不能修改(自动执行，使用new Person()时自动调用该方法)</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法必须使用该语法 不能使用ES5的对象完整形式 call:fuction()&#123;&#125;   &lt;==   错误！！</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以打电话&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> onPlus = <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="string">&quot;1+&quot;</span>,<span class="number">1999</span>);<span class="comment">//实例化对象，自动调用constructor方法</span></span><br></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员static标注的成员，属于类，而不属于函数对象   &#x3D;&#x3D;&#x3D;&#x3D;&gt;   得用类名.成员名   来调用该属性</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//静态属性</span></span><br><span class="line">    <span class="keyword">static</span> name = <span class="string">&quot;手机&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我可以改变世界&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> huawei = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(huawei.<span class="property">name</span>);<span class="comment">//undefined;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Phone</span>.<span class="property">name</span>);<span class="comment">//手机</span></span><br></pre></td></tr></table></figure><h2 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的成员属性</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打电话&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price,color,size</span>) &#123;</span><br><span class="line">        <span class="title function_">surper</span>(brand,price);<span class="comment">//surper()就是父类的constructor()方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">photo</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;拍照&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">playGame</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;玩游戏&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaomi = <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&#x27;小米&#x27;</span>,<span class="number">799</span>,<span class="string">&#x27;黑色&#x27;</span>,<span class="string">&#x27;4.7inch&#x27;</span>);</span><br><span class="line">xiaomi.<span class="title function_">call</span>();</span><br><span class="line">xiaomi.<span class="title function_">photo</span>();</span><br><span class="line">xiaomi.<span class="title function_">playGame</span>();</span><br></pre></td></tr></table></figure><h2 id="子类对父类方法的重写"><a href="#子类对父类方法的重写" class="headerlink" title="子类对父类方法的重写"></a>子类对父类方法的重写</h2><p>重写：在子类声明一个和父类重名的方法，从而对父类的功能进行改进。当调用这个方法时，调用的是子类的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">brand</span> = brand;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类的成员属性</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打电话&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPhone</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">brand,price,color,size</span>) &#123;</span><br><span class="line">        <span class="title function_">surper</span>(brand,price);<span class="comment">//surper()就是父类的constructor()方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子类重写父类call()方法</span></span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//无法在子类里去调用父类里的call()方法！！</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打视频、聊天&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaomi = <span class="keyword">new</span> <span class="title class_">SmartPhone</span>(<span class="string">&#x27;小米&#x27;</span>,<span class="number">799</span>,<span class="string">&#x27;黑色&#x27;</span>,<span class="string">&#x27;4.7inch&#x27;</span>);</span><br><span class="line">xiaomi.<span class="title function_">call</span>();<span class="comment">//&quot;打视频、聊天&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>ES6里，无法在子类里去调用父类中和他同名的那个方法，只能在子类里写。</p></blockquote><h2 id="getter和setter设置"><a href="#getter和setter设置" class="headerlink" title="getter和setter设置"></a>getter和setter设置</h2><p>对<code>对象的属性</code>进行方法的绑定<br>get：对于对象的动态属性进行封装<br>set：添加更多的控制和判断</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">price</span>() &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;价格属性被读取了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;helloworld&#x27;</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">price</span>(<span class="params">newVAl</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;价格属性被修改了&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">price</span>());</span><br><span class="line">s.<span class="property">price</span> = <span class="string">&#x27;free&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h2><ol><li>Number.EPSILON 是 JavaScript 表示的最小精度<ul><li>EPSILON 属性的值接近于 2.22E-16</li><li>主要用于浮点数运算（浮点数运算经常会有误差）</li></ul></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span>+<span class="number">0.2</span>);<span class="comment">//0.3000000000000000000000004</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span>);<span class="comment">//false</span></span><br><span class="line"><span class="keyword">function</span> equal = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">abs</span>(a-b)&lt;<span class="title class_">Number</span>.<span class="property">EPSILON</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">equal</span>(<span class="number">0.1</span>+<span class="number">0.2</span>,<span class="number">0.3</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol start="2"><li>二进制和八进制</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">0b1010</span>;<span class="comment">//二进制 0b开头 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);<span class="comment">//10</span></span><br><span class="line"><span class="keyword">let</span> o = <span class="number">0o777</span>;<span class="comment">//八进制 0o开头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);<span class="comment">//511</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0xff</span>;<span class="comment">//十六进制 0x开头</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);<span class="comment">//255</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Number.isFinite 检测一个数值是否为有限数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">100</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>));<span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(<span class="number">100</span>/<span class="number">0</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="4"><li>Number.isNaN 检测一个数值是否为NaN</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">123</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="5"><li>Number.parseInt  Number.parseFloat  字符串转整数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">parseInt</span>(<span class="string">&quot;520Love&quot;</span>));<span class="comment">//520</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">parseFloat</span>(<span class="string">&quot;5.20Love&quot;</span>));<span class="comment">//5.20</span></span><br></pre></td></tr></table></figure><ol start="6"><li>Number.isInteger 判断一个数是否为整数</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">4</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">4.4</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="7"><li>Math.trunc 将数字的小数部分抹掉</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="number">3.5</span>));<span class="comment">//3</span></span><br></pre></td></tr></table></figure><ol start="8"><li>Math.sign 判断一个数到底为正数、负数还是零</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="number">100</span>));<span class="comment">//1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sign</span>(<span class="number">0</span>));<span class="comment">//0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">sign</span>(-<span class="number">100</span>));<span class="comment">//-1</span></span><br></pre></td></tr></table></figure><h1 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h1><ol><li>Object.is(a, b)判断两个值是否完全相等</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">120</span>,<span class="number">120</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>,<span class="title class_">NaN</span>));<span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>===<span class="title class_">NaN</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Object.assign(a, b)对象的合并</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config1 = &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">3306</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">pass</span>:<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">text</span>:<span class="string">&#x27;text&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> config2 = &#123;</span><br><span class="line">    <span class="attr">host</span>:<span class="string">&#x27;http://xiaolin03.com&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">33060</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xiaolin03.com&#x27;</span>,</span><br><span class="line">    <span class="attr">pass</span>:<span class="string">&#x27;cmb&#x27;</span>,</span><br><span class="line">    <span class="attr">text2</span>:<span class="string">&#x27;text2&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(config1,config2));</span><br><span class="line"><span class="comment">//如果对象里面参数重名host、port、name、pass，后面一个参数会把前面一个参数覆盖掉；</span></span><br><span class="line"><span class="comment">//如果前面一个对象的属性后面一个对象没有text，那么以前面一个对象为准；</span></span><br><span class="line"><span class="comment">//如果后面一个对象的属性前面一个对象没有text2，那么不会覆盖掉。</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Object.setPrototypeOf 设置原型对象   Object.getPrototypeOf</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;学校名&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cities = &#123;</span><br><span class="line">    <span class="attr">xiaoqu</span>:[<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;深圳&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(school,cities);<span class="comment">//为school对象设置原型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(school);</span><br></pre></td></tr></table></figure><blockquote><p>不建议这么做(效率低)</p></blockquote><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>将一个大的程序文件，拆分成许多小的文件（模块），然后将小文件组合起来。<br>【好处】：</p><ol><li>防止命名冲突</li><li>代码复用</li><li>高维护性<br>【语法】：模块功能主要由两个命令构成：export和import</li><li>export命令用于规定模块的对外接口</li><li>import命令用于输入其他模块提供功能</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//m1.js文件：</span></span><br><span class="line"><span class="comment">//希望这个数据能够被的模块使用，就在前面加上export，他模块就可以通过import引入这个数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> school = <span class="string">&#x27;学校名&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//index.html文件：</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//引入m1.js模块内容</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;<span class="comment">//通用方式===&gt;index.html这个文件就把m1.js文件里所有暴露数据存储到m1数据里了</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(m1);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>【暴露数据语法汇总】：</p><ol><li>分别暴露(在每个需要暴露的数据前面加上export)    m1.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> school = <span class="string">&#x27;学校名&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>统一暴露(在某个地方直接用export，用对象简化写法格yin)    m2.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> school = <span class="string">&#x27;学校名&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">teach</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;school,teach&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>默认暴露(对于这种方法，在调用的时候也需要上default 【例】m1.default.change())    m3.js</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//格式：export default + &#123;要暴露的数据&#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">school</span>:<span class="string">&quot;学校名&quot;</span>,</span><br><span class="line">    <span class="attr">change</span>:<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;heloworld&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【引入模块数据语法汇总】：</p><ol><li>通用的入方式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span>&gt;</span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>解构赋值形式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;school,teach&#125; <span class="keyword">from</span> <span class="string">&quot;./m1.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;school <span class="keyword">as</span> guigu,teach <span class="keyword">as</span> teaching&#125; <span class="keyword">from</span> <span class="string">&quot;./m2.js&quot;</span>;<span class="comment">//如果需要引入的数据重名的话，可以使用别名方式</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m3&#125; form <span class="string">&quot;./m3.js&quot;</span>;<span class="comment">//对于默认暴露的方式用解构赋值，不能直接使用default</span></span><br></pre></td></tr></table></figure><ol start="3"><li>简便形式（只能针对默认暴露）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m3 <span class="keyword">from</span> <span class="string">&quot;./m3.js&quot;</span>;<span class="comment">//直接跟变量（不写*和&#123;&#125;）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【项目】黑马头条 - 普通用户端</title>
      <link href="/post/29134165.html"/>
      <url>/post/29134165.html</url>
      
        <content type="html"><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p><img src="/assets/18f63549fbf14a9e866730e78f23454a.png" alt="18f63549fbf14a9e866730e78f23454a.png"><br><img src="/assets/c5abfc1c456449d1b8c1f2e19efca2b0.png" alt="c5abfc1c456449d1b8c1f2e19efca2b0.png"></p><h1 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a>全局异常</h1><p><img src="/assets/287788fb68b54c9ab0aaf82d728277ba.png" alt="287788fb68b54c9ab0aaf82d728277ba.png"></p><h1 id="登录手动加密（md5-随机字符串）"><a href="#登录手动加密（md5-随机字符串）" class="headerlink" title="登录手动加密（md5  + 随机字符串）"></a>登录手动加密（md5  + 随机字符串）</h1><p>【问题】md5是不可逆加密，md5相同的密码每次加密都一样，不安全。<br>【解决】在md5的基础上手动加盐（salt）处理<br><img src="/assets/51135b1974df4aaf92ca2807aa12d794.png" alt="51135b1974df4aaf92ca2807aa12d794.png"><br>校验过程：<br><img src="/assets/6db7d58b06124215aadbe261f1ad796d.png" alt="6db7d58b06124215aadbe261f1ad796d.png"></p><h1 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h1><h2 id="1-ApiFox中测试"><a href="#1-ApiFox中测试" class="headerlink" title="1. ApiFox中测试"></a>1. ApiFox中测试</h2><h2 id="2-swagger"><a href="#2-swagger" class="headerlink" title="2. swagger"></a>2. swagger</h2><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在common模块下添加swagger配置类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Docket <span class="title function_">buildDocket</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">              .apiInfo(buildApiInfo())</span><br><span class="line">              .select()</span><br><span class="line">              <span class="comment">// 要扫描的API(Controller)基础包</span></span><br><span class="line">              .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.heima&quot;</span>))</span><br><span class="line">              .paths(PathSelectors.any())</span><br><span class="line">              .build();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> ApiInfo <span class="title function_">buildApiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Contact</span> <span class="variable">contact</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;黑马程序员&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">              .title(<span class="string">&quot;黑马头条-平台管理API文档&quot;</span>)</span><br><span class="line">              .description(<span class="string">&quot;黑马头条后台api&quot;</span>)</span><br><span class="line">              .contact(contact)</span><br><span class="line">              .version(<span class="string">&quot;1.0.0&quot;</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/03715a928244480fbfe41f21dd9cc950.png" alt="03715a928244480fbfe41f21dd9cc950.png"></p><ol start="3"><li>swagger的常用注解</li></ol><ul><li>@Api：修饰整个类，描述Controller的作用  </li><li>@ApiOperation：描述接口  </li><li>@ApiModelProperty：描述属性</li></ul><blockquote><p>成功后启动项目，浏览器访问：<code>http://localhost:51801/swagger-ui.html</code></p></blockquote><h2 id="3-knife4j（常用）"><a href="#3-knife4j（常用）" class="headerlink" title="3. knife4j（常用）"></a>3. knife4j（常用）</h2><p>knife4j继承了swagger，功能比swagger更强大，也会生成接口文档</p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在common中添加配置类：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="meta">@EnableKnife4j</span></span><br><span class="line"><span class="meta">@Import(BeanValidatorPluginsConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Swagger2Configuration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(value = &quot;defaultApi2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">defaultApi2</span><span class="params">()</span> &#123;</span><br><span class="line">        Docket docket=<span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                <span class="comment">//分组名称</span></span><br><span class="line">                .groupName(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">//这里指定Controller扫描包路径</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.heima&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> docket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;黑马头条API文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;黑马头条API文档&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样也需要在resources目录中添加该配置类的全类名<br>成功后启动项目，浏览器访问：<code>http://host:port/doc.html</code></p></blockquote><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><h2 id="1-配置网关"><a href="#1-配置网关" class="headerlink" title="1. 配置网关"></a>1. 配置网关</h2><p>一个父模块(heima-leadnews-gateway)下，放多个子模块(heima-leadnews-app-gateway)。<br><img src="/assets/506178d045ab4f978a4858eb11993e82.png" alt="506178d045ab4f978a4858eb11993e82.png"></p><ol><li>在父模块中引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写子模块的引导类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.heima.app.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">//开启注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppGatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(AppGatewayApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写子模块的bootstrap.yml</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">51601</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heima-leadnews-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.102</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在注册中心中引入子模块的配置<br><img src="/assets/7c829db6c8154f0b9fa1c042543095cc.png" alt="7c829db6c8154f0b9fa1c042543095cc.png"></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">OPTION</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="comment"># 平台管理</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://leadnews-user</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">StripPrefix=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2-设置认证过滤器"><a href="#2-设置认证过滤器" class="headerlink" title="2. 设置认证过滤器"></a>2. 设置认证过滤器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizeFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取request、response对象</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">// 2. 判断是否是登录</span></span><br><span class="line">        <span class="keyword">if</span>(request.getURI().getPath().contains(<span class="string">&quot;/login&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeaders().getFirst(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">// 4. 判断token是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="comment">// 拦截</span></span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED); <span class="comment">// 返回401未授权</span></span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 判断token是否有效</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!AppJwtUtil.isValidToken(token)) &#123;</span><br><span class="line">            <span class="comment">// token过期</span></span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange); <span class="comment">// 放行</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete(); <span class="comment">// 抛异常，结束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先级设置，值越小，优先级越高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>认证过滤器用来拦截前端发过来的请求，写在网关里。</p></blockquote><h1 id="文章列表"><a href="#文章列表" class="headerlink" title="文章列表"></a>文章列表</h1><h2 id="表的拆分——垂直分表"><a href="#表的拆分——垂直分表" class="headerlink" title="表的拆分——垂直分表"></a>表的拆分——垂直分表</h2><p><img src="/assets/d70a685c8c9c4d77b89a9e5b8aec994a.png" alt="d70a685c8c9c4d77b89a9e5b8aec994a.png"><br>将一个表的字段分散到多个表，每个表存储其中一部分字段</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>减少IO争抢，减少锁表的几率（查看文章信息与文章内容互不影响）</li><li>充分发挥高频数据的操作效率，对文章信息操作的高频率不会被操作文章详情数据的低效率拖累。</li></ul><h3 id="拆分规则"><a href="#拆分规则" class="headerlink" title="拆分规则"></a>拆分规则</h3><ol><li>把不常用的字段单独放在一张表</li><li>把text、blob等大字段拆分出来单独放在一张表</li><li>经常组合查询的字段单独放在一张表</li></ol><h1 id="文章详情"><a href="#文章详情" class="headerlink" title="文章详情"></a>文章详情</h1><h2 id="方案1-直接查文章内容表"><a href="#方案1-直接查文章内容表" class="headerlink" title="方案1. 直接查文章内容表"></a>方案1. 直接查文章内容表</h2><p>用户某一条文章，根据id去查询文章内容表，返回渲染页面<br><img src="/assets/e1f300afed754115b635b8742585ed1e.png" alt="e1f300afed754115b635b8742585ed1e.png"></p><h2 id="方案2-静态模板展示（效率高）"><a href="#方案2-静态模板展示（效率高）" class="headerlink" title="方案2. 静态模板展示（效率高）"></a>方案2. 静态模板展示（效率高）</h2><p><img src="/assets/369f91bc04ab4b13a3024b7cda9063c5.png" alt="369f91bc04ab4b13a3024b7cda9063c5.png"></p><blockquote><p>把文章的内容变成静态的html文件，把生成之后的文件上传到minio中，并保存生成的html存入文章信息表中（static_url字段），前端渲染的时候，直接获取文章信息表的static_url字段，然后去minIO里获取静态访问页面即可。</p></blockquote><p>Freemaker知识点：<a href="https://blog.csdn.net/qq_57882997/article/details/145262781?sharetype=blogdetail&sharerId=145262781&sharerefer=PC&sharesource=qq_57882997&spm=1011.2480.3001.8118">Freemarker模板引擎技术</a></p><p>新增文章的测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createStaticUrlTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TemplateException &#123;</span><br><span class="line">    <span class="comment">// 1. 获取文章内容</span></span><br><span class="line">    <span class="type">ApArticleContent</span> <span class="variable">apArticleContent</span> <span class="operator">=</span> apArticleContentMapper.selectOne(Wrappers.&lt;ApArticleContent&gt;lambdaQuery().eq(ApArticleContent::getArticleId, <span class="string">&quot;1302862387124125698L&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(apArticleContent != <span class="literal">null</span> || StringUtils.isBlank(apArticleContent.getContent()))&#123;</span><br><span class="line">        <span class="comment">// 2. 文章内容通过freemarker生成html文件</span></span><br><span class="line">        <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> configuration.getTemplate(<span class="string">&quot;article.ftl&quot;</span>);</span><br><span class="line">        Map&lt;String, Object&gt; content = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        content.put(<span class="string">&quot;content&quot;</span>, JSONArray.parseArray(apArticleContent.getContent()));</span><br><span class="line">        <span class="type">StringWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringWriter</span>();</span><br><span class="line">        template.process(content, out);</span><br><span class="line">        <span class="comment">// 3. 把html上传到minio中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(out.toString().getBytes());</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> fileStorageService.uploadHtmlFile(<span class="string">&quot;&quot;</span>, apArticleContent.getArticleId() + <span class="string">&quot;.html&quot;</span>, in);</span><br><span class="line">        <span class="comment">// 4. 修改ap_article表，保存static_url字段</span></span><br><span class="line">        apArticleService.update(Wrappers.&lt;ApArticle&gt;lambdaUpdate()</span><br><span class="line">                        .eq(ApArticle::getId, apArticleContent.getArticleId())</span><br><span class="line">                        .set(ApArticle::getStaticUrl, path));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 黑马头条 </tag>
            
            <tag> 网关 </tag>
            
            <tag> 拆分表 </tag>
            
            <tag> 文章详情渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO</title>
      <link href="/post/a5fe9d0b.html"/>
      <url>/post/a5fe9d0b.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol><li>Golang语言实现</li><li>兼容亚马逊S3云存储服务接口，适合存储大量非结构化数据</li><li>官方文档：<a href="https://www.minio.org.cn/docs/minio/kubernetes/upstream/index.html">MinIO</a></li></ol><h1 id="Docker安装MinIO"><a href="#Docker安装MinIO" class="headerlink" title="Docker安装MinIO"></a>Docker安装MinIO</h1><ol><li>创建并运行容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name minio \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">--restart=always \</span><br><span class="line">-e &quot;MINIO_ACCESS_KEY=minio&quot; \</span><br><span class="line">-e &quot;MINIO_SECRET_KEY=minio123&quot; \</span><br><span class="line">-v /home/data:/data \</span><br><span class="line">-v /home/config:/root/.minio \</span><br><span class="line">minio/minio server /data</span><br></pre></td></tr></table></figure><ul><li>用户名：minio</li><li>密码：minio123</li></ul><ol start="2"><li>在浏览器输入<code>http://192.168.140.102:9000/</code>后即可看到minio控制台</li></ol><h1 id="操作MinIO"><a href="#操作MinIO" class="headerlink" title="操作MinIO"></a>操作MinIO</h1><ol><li>引入minio依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>操作minio</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d:\\list.html&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取minio的连接信息，创建minio的客户端</span></span><br><span class="line">    <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span> MinioClient.builder()</span><br><span class="line">            .credentials(<span class="string">&quot;minio&quot;</span>, <span class="string">&quot;minio123&quot;</span>) <span class="comment">// 凭证</span></span><br><span class="line">            .endpoint(<span class="string">&quot;http://192.168.140.102:9000&quot;</span>) <span class="comment">// 连接地址</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 上传</span></span><br><span class="line">    <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">            .object(<span class="string">&quot;list.html&quot;</span>) <span class="comment">// 文件名称</span></span><br><span class="line">            .contentType(<span class="string">&quot;text/html&quot;</span>) <span class="comment">// 文件类型</span></span><br><span class="line">            .bucket(<span class="string">&quot;leadnews&quot;</span>) <span class="comment">// 桶名称(与minio管理界面创建的桶一致)</span></span><br><span class="line">            .stream(fis, fis.available(), -<span class="number">1</span>) <span class="comment">// 流, 流有多大, -1表示所有相关的文件内容</span></span><br><span class="line">            .build();</span><br><span class="line">    minioClient.putObject(putObjectArgs);</span><br><span class="line">    <span class="comment">// 访问路径</span></span><br><span class="line">    System.out.println(<span class="string">&quot;http://192.168.140.102:9000/leadnews/list.html&quot;</span>); <span class="comment">// 访问路径 + 桶的名称 + 文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="封装MinIO为starter"><a href="#封装MinIO为starter" class="headerlink" title="封装MinIO为starter"></a>封装MinIO为starter</h1><p>【问题】：可能有不止一个微服务需要用到minio，如果在每个微服务都去集成minio会很麻烦。<br>【解决】：把文件微服务抽取出来，抽取minio变成一个文件微服务。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> minio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Freemarker模板引擎技术</title>
      <link href="/post/768410d8.html"/>
      <url>/post/768410d8.html</url>
      
        <content type="html"><![CDATA[<p>【<code>问题</code>】当渲染文章数据时，由于文章的数据很多，直接去查询文章内容表的话，效率比较低。<br>【<code>解决</code>】使用freemarker将文章的内容通过模板技术生成静态的html文件存储到minio中，这样用户就只需要拿着minio的url去minio里获取静态页面即可。效率大大提高<br><img src="/assets/369f91bc04ab4b13a3024b7cda9063c5.png" alt="369f91bc04ab4b13a3024b7cda9063c5.png"></p><h1 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h1><p>Freemarker是一种模板引擎：一种基于模板和要改变的数据，并用来生成输出文本（html网页、电子邮件、配置文件、源代码…）的通用工具。不是面向最终用户的，而是一个Java类库。<br><img src="/assets/bb81ce762b244cc693aeb5119f053c43.png" alt="bb81ce762b244cc693aeb5119f053c43.png"></p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- freemarker --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加application.yml配置</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8881</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">freemarker-demo</span> <span class="comment">#指定服务名</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span>  <span class="comment">#关闭模板缓存，方便测试</span></span><br><span class="line">    <span class="attr">settings:</span></span><br><span class="line">      <span class="attr">template_update_delay:</span> <span class="number">0</span> <span class="comment">#检查模板更新延迟时间，设置为0表示立即检查，如果时间大于0会有缓存不方便进行模板测试</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span> <span class="comment">#指定Freemarker模板文件的后缀名（默认是.ftlh）</span></span><br></pre></td></tr></table></figure><blockquote><p>suffix的属性也可以是.html、.xml、.jsp等，但是一般是以ftl作为扩展名</p></blockquote><ol start="3"><li>在resources下创建templates，此目录为<code>freemarker的默认模板存放目录</code>。在templates下创建<code>模板文件basic.ftl</code>，模板中的<code>插值表达式</code>最终会被freemarker替换成具体的数据。<br>basic.ftl文件</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>普通文本 String 展示：<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Hello $&#123;name&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>对象Student中的数据展示：<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">姓名：$&#123;stu.name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stu.age&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>往模板里填数据，返回模板文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 因为要返回视图，而不是json字符串，所以这里不可以用@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/basic&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(Model model)</span> &#123;</span><br><span class="line">        <span class="comment">// name</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaolin&quot;</span>);</span><br><span class="line">        <span class="comment">// stu</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;03&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;stu&quot;</span>, stu);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;basic&quot;</span>; <span class="comment">// 这里返回的数据必须和模板视图的名字一样，这样才能找到模板视图(别带后缀！！！)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Freemarker指令语法"><a href="#Freemarker指令语法" class="headerlink" title="Freemarker指令语法"></a>Freemarker指令语法</h1><h2 id="基础语法种类"><a href="#基础语法种类" class="headerlink" title="基础语法种类"></a>基础语法种类</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释&lt;#-- --&gt;"></a>1. 注释<code>&lt;#-- --&gt;</code></h3><p>介于其之间的内容会被Freemarker忽视</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--我是一个freemarker注释--&gt;</span><br></pre></td></tr></table></figure><h3 id="2-插值表达式"><a href="#2-插值表达式" class="headerlink" title="2. 插值表达式${...}"></a>2. 插值表达式<code>$&#123;...&#125;</code></h3><p>Freemarker会用真实的值替代${…}</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Hello $&#123;name&#125;</span><br></pre></td></tr></table></figure><h3 id="3-FTL指令"><a href="#3-FTL指令" class="headerlink" title="3. FTL指令&lt;#&gt; &lt;/#&gt;"></a>3. FTL指令<code>&lt;#&gt; &lt;/#&gt;</code></h3><p>名字前加<code>#</code>区分，Freemarker会解析标签中的表达式或逻辑。<br>例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#list stus as stu&gt;$&#123;stu.name&#125;&lt;/#list&gt; </span><br></pre></td></tr></table></figure><h3 id="4-文本"><a href="#4-文本" class="headerlink" title="4. 文本"></a>4. 文本</h3><p>仅文本信息，不是freemarker的注释、插值、FTL指令的内容会被Freemarker忽略解析，直接输出内容。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--freemarker中的普通文本--&gt;</span><br><span class="line">我是一个普通的文本</span><br></pre></td></tr></table></figure><h2 id="集合指令（List、Map）"><a href="#集合指令（List、Map）" class="headerlink" title="集合指令（List、Map）"></a>集合指令（List、Map）</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>钱包<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;#--遍历数据 stu指的是集合里的每一个数据--&gt;</span><br><span class="line">    &lt;#list stus as stu&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            &lt;#--获取当前集合的下标--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu_index + 1&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.age&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.money&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="获取map中某个key对应的值"><a href="#获取map中某个key对应的值" class="headerlink" title="获取map中某个key对应的值"></a>获取map中某个key对应的值</h4><ol><li>通过<code>map[&#39;keyname&#39;].property</code></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">姓名：$&#123;stuMap[&#x27;stu1&#x27;].name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stuMap[&#x27;stu1&#x27;].age&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过<code>map.keyname.property</code></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">姓名：$&#123;stuMap.stu2.name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stuMap.stu2.age&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>钱包<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;#--遍历数据 key指的是map中的每一个key--&gt;</span><br><span class="line">    &lt;#list stuMap?keys as key&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            &lt;#--获取当前集合的下标--&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;key_index + 1&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[key].name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[key].age&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[key].money&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt;/#list&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="if指令"><a href="#if指令" class="headerlink" title="if指令"></a>if指令</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if 表达式&gt;</span><br><span class="line">&lt;#else&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>【例】：姓名为小红的数据字体显示为红色</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if name = &#x27;小红&#x27;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span> = <span class="string">&quot;color: red&quot;</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&lt;#else&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>$&#123;name&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在Freemarker中，<code>=</code> 与 <code>==</code> 是一样的</p></blockquote><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="数值运算符"><a href="#数值运算符" class="headerlink" title="数值运算符"></a>数值运算符</h3><ol><li>加法：+</li><li>减法：-</li><li>乘法：*</li><li>除法：&#x2F;</li><li>求余：%</li></ol><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p><img src="/assets/846b7c2736084785a2100f9429e9c333.png" alt="846b7c2736084785a2100f9429e9c333.png"></p><blockquote><p>&#x3D; 和 !&#x3D; 可以用于字符串、数值、日期来比较是否相等<br>&#x3D; 和 !&#x3D; 两边必须是相同类型的值，否则会产生错误<br>字符串”x”和”x “和”X”比较是不相等的<br><code>gt</code>代替<code>&gt;</code>，因为Freemarker会把&gt;解析成FTL标签结束的字符串，可以用括号避免这种情况，如：<code>&lt;#if (x &gt; y)&gt;</code></p></blockquote><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>逻辑与：&amp;&amp;</li><li>逻辑或：||</li><li>逻辑非：!</li></ol><h2 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h2><ol><li>判断某个变量是否存在使用：”??”<br>用法：<code>变量??</code><ul><li>变量存在，返回true</li><li>不存在，返回false</li></ul></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#if stus??&gt;</span><br><span class="line">&lt;#list stus as stu&gt;</span><br><span class="line">...</span><br><span class="line">&lt;#list&gt;</span><br><span class="line">&lt;/#if&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>缺失的变量使用：<code>!</code><br>用法：<code>!默认值</code><ul><li>使用<code>!</code>要指定一个默认值，当变量为空时显示默认值</li><li>如果是嵌套对象，要使用<code>()</code>括起来</li></ul></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--如果name为空显示空字符串&#x27;&#x27;--&gt;</span><br><span class="line">$&#123;name!&#x27;&#x27;&#125;</span><br><span class="line">&lt;#--如果stu或name为空，默认显示空字符串&#x27;&#x27;--&gt;</span><br><span class="line">$&#123;(stu.name)!&#x27;&#x27;&#125;</span><br></pre></td></tr></table></figure><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><p>语法格式：<code>变量 + ? + 函数名称</code></p><ol><li>集合大小</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$&#123;集合名?size&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>日期格式化<br>显示日期+时间：<code>$&#123;today?datetime&#125;</code><br>自定义格式化：<code>$&#123;today?string(&quot;yyyy年MM月&quot;)&#125;</code><br>显示时分秒：<code>$&#123;today?time&#125;</code><br>显示年月日：<code>$&#123;today?date&#125;</code></li><li>内建函数c<br>【场景】：point是数值类型，使用<code>$&#123;point&#125;</code>会显示这个数字的数值，每三位使用逗号分隔。如果不想显示为每隔三位分割的数字，可以使用c函数将数字型转成字符串输出。<br><img src="/assets/62e4f1978b4447a3b40fd0c46c45e969.png" alt="62e4f1978b4447a3b40fd0c46c45e969.png"></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">model.addAttribute(<span class="string">&quot;poin&quot;</span>, <span class="number">123456780L</span>);</span><br></pre></td></tr></table></figure><p>使用内建函数c：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">$&#123;point?c&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将json字符串转为对象</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;#--assign标签的作用：定义一个变量--&gt;</span><br><span class="line">&lt;#assign text=&quot;&#123;&#x27;bank&#x27;:&#x27;工商银行&#x27;,&#x27;account&#x27;:&#x27;10101920201920212&#x27;&#125;&quot; /&gt;</span><br><span class="line">&lt;#--把json转成变量--&gt;</span><br><span class="line">&lt;#assign data=text?eval /&gt;</span><br><span class="line">开户行：$&#123;data.bank&#125;</span><br><span class="line">账号：$&#123;data.account&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：eval的使用可能不安全，如果传入的字符串内容不可控（比如来自用户输入），可能会导致安全问题（例如代码注入）</p></blockquote><h1 id="输出静态化文件"><a href="#输出静态化文件" class="headerlink" title="输出静态化文件"></a>输出静态化文件</h1><p><img src="/assets/f2aa177960304cbeab1740b830d65999.png" alt="f2aa177960304cbeab1740b830d65999.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreemarkerTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TemplateException &#123;</span><br><span class="line">        <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> configuration.getTemplate(<span class="string">&quot;test.ftl&quot;</span>); <span class="comment">// 模板对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数：模型数据 mp</span></span><br><span class="line"><span class="comment">         * 第二个参数：输出流</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Object&gt; mp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        mp.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaolin&quot;</span>);</span><br><span class="line">        template.process(mp, <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:/list.html&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Freemarker </tag>
            
            <tag> 模板引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch下</title>
      <link href="/post/ffdcb30c.html"/>
      <url>/post/ffdcb30c.html</url>
      
        <content type="html"><![CDATA[<h1 id="DSL查询"><a href="#DSL查询" class="headerlink" title="DSL查询"></a>DSL查询</h1><ol><li>叶子查询：在特定字段里查询特定值，属于简单查询，很少单独使用</li><li>复合查询：以逻辑方式组合多个叶子查询或更改叶子查询的行为方式<ul><li>在查询后还可以对查询结果做处理：<ul><li>排序：按照1个或多个字段做排序</li><li>分页：根据from或size做分页，类似MySQL</li><li>高亮：对搜索结果中的关键字添加特殊样式</li><li>聚合：对搜索结果做数据统计以形成报表</li></ul></li></ul></li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;查询类型&quot;: &#123;</span><br><span class="line">      &quot;查询条件&quot;: &quot;条件值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search </span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/2b23b9d359714c4cb0f26918da897173.png" alt="2b23b9d359714c4cb0f26918da897173.png"></p><h2 id="叶子查询"><a href="#叶子查询" class="headerlink" title="叶子查询"></a>叶子查询</h2><h3 id="1-全文检索查询"><a href="#1-全文检索查询" class="headerlink" title="1. 全文检索查询"></a>1. 全文检索查询</h3><p>利用分词器对用户输入内容分词，然后去词条列表中匹配，默认按照匹配度排序。例如：match_query、multi_match_query</p><p><code>match查询（常用）</code>：会对用户输入的内容分词，然后去倒排索引检索，语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;: &quot;搜索条件&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：搜索“脱脂牛奶”</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>multi_match查询</code>：与match查询类似，只不过允许查询多个字段，参与查询的字段越多，性能越差。语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;搜索条件&quot;,</span><br><span class="line">      &quot;fields&quot;: [&quot;字段1&quot;, &quot;字段2&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-精确查询"><a href="#2-精确查询" class="headerlink" title="2. 精确查询"></a>2. 精确查询</h3><p>不对用户输入的内容做分词，直接精确匹配，一般是查找keyword、数值、日期、布尔等类型。例如：ids、range、term</p><p><code>term查询（常用）</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;搜索条件&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：查询“牛奶”分类下的商品</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;category&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;牛奶&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range查询</code>：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: &#123;最小值&#125;,</span><br><span class="line">        &quot;lte&quot;: &#123;最大值&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：查询价格≥5k，≤1w</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: <span class="number">500000</span>,</span><br><span class="line">        &quot;lte&quot;: <span class="number">1000000</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ids查询</code>：<br>【例】：查询id为1861099和1861100的商品</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;ids&quot;: &#123;</span><br><span class="line">      &quot;values&quot;: [&quot;1861099&quot;, &quot;1861100&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-地理查询"><a href="#3-地理查询" class="headerlink" title="3. 地理查询"></a>3. 地理查询</h3><p>用于搜索地理位置。例如：geo_distance、geo_bounding_box</p><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><h3 id="1-bool查询"><a href="#1-bool查询" class="headerlink" title="1. bool查询"></a>1. bool查询</h3><p>基于逻辑运算组合叶子查询，实现组合条件，例如：bool</p><ol><li>must：必须匹配每个子查询（“与”）</li><li>should：选择性匹配子查询（“或”）</li><li>must_not：必须不匹配，<strong>不参与算分</strong>（“非”）</li><li>filter：必须匹配，<strong>不参与算分</strong>（“与”）</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_search &#123;</span><br><span class="line">&quot;query&quot;: &#123;</span><br><span class="line">bool查询条件: &#123;</span><br><span class="line">叶子查询</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用户在输入框搜索“手机”，在底下：品牌选择“华为”，价格选择“1600以上元”。<br><img src="/assets/bcceb581d0854273bcfb4d9b5a7bb18e.png" alt="bcceb581d0854273bcfb4d9b5a7bb18e.png"></p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;手机&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;brand&quot;: &quot;华为&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;price&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: <span class="number">160000</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-算分函数查询"><a href="#2-算分函数查询" class="headerlink" title="2. 算分函数查询"></a>2. 算分函数查询</h3><p>基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：function_score、dis_max</p><h2 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>es默认根据相关度算分（_score）来排序，也可以指定字段排序。可以排序的类型有：keyword、数值、地理坐标、日期。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;排序字段&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;排序方式asc和desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：搜索“脱脂牛奶”，结果按照销量排序，销量一样按照价格升序排列</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;sold&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>es默认只返回前10的数据，如果查询更多数据就需要修改分页参数。</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档<br>【例】：搜索“脱脂牛奶”，查询出销量前10的商品，销量一样时按照价格升序</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: <span class="number">0</span>, <span class="operator">/</span><span class="operator">/</span> 分页开始的位置，默认为<span class="number">0</span></span><br><span class="line">  &quot;size&quot;: <span class="number">10</span>, <span class="operator">/</span><span class="operator">/</span> 每页文档数量，默认<span class="number">10</span></span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;sold&quot;: &quot;desc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;price&quot;: &quot;asc&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h4><p>es中from + size不能超过1w条，因为太深了会有深度分页问题。<br>【产生原因】因为es存储的数据很多，所以es数据一般会采用分片存储，把一个索引中的数据分成N份，存储到不同的节点上。查询时需要汇总各个分片的数据。查询的页码越深，从每个分片差的数据量越多，内存压力越大，性能越差。<br>【解决办法】<strong>search after模式</strong>：分页时需要<code>排序</code>，原理是在上一次排序后，会记住上一次的排序值，下一次排序时，就会直接从上一次排序值开始，查询下一页数据。</p><ul><li>优点：没有查询上限，支持深度分页</li><li>缺点：只能向后逐页查询，不能随即翻页</li><li>场景：数据迁移，手机滚动查询</li></ul><h2 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h2><p>在搜索结果中，把搜索结果突出显示<br>【原理】：<br>    1. 高亮词条都加了<code>&lt;em&gt;</code>标签，标签上都添加了红色样式<br>    2. 倒排索引在分词的时候，会把词条列表进行分词，还会记录词条在文档中的位置<br><img src="/assets/3468afd108364447873d0a6fac332cba.png" alt="3468afd108364447873d0a6fac332cba.png"></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;搜索字段&quot;: &quot;搜索关键字&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;高亮字段名称&quot;: &#123;</span><br><span class="line">        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;, <span class="operator">/</span><span class="operator">/</span> 高亮的前置标签</span><br><span class="line">        &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; <span class="operator">/</span><span class="operator">/</span> 高亮的后置标签</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一般搜哪个字段，就对哪个字段做高亮，标签可以不加，默认是em</p></blockquote><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;脱脂牛奶&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/4915936d29da416b9db298d7defdde97.png" alt="4915936d29da416b9db298d7defdde97.png"></p><h1 id="JavaRestClient查询"><a href="#JavaRestClient查询" class="headerlink" title="JavaRestClient查询"></a>JavaRestClient查询</h1><h2 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h2><ol><li>构建并发起请求<br><img src="/assets/64e8e6e4bb7f4e9fbf91386bb408a2cc.png" alt="64e8e6e4bb7f4e9fbf91386bb408a2cc.png"></li><li>解析查询结果<br><img src="/assets/e0d930c0b734471ab2b87c60def123f7.png" alt="e0d930c0b734471ab2b87c60def123f7.png"></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建Request对象</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 配置Request参数</span></span><br><span class="line">    request.source()</span><br><span class="line">            .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4. 解析结果</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value; <span class="comment">// 查询的总条数</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits(); <span class="comment">// 查询的结果数组</span></span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();<span class="comment">// 得到source</span></span><br><span class="line">        System.out.println(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="叶子查询-1"><a href="#叶子查询-1" class="headerlink" title="叶子查询"></a>叶子查询</h2><h3 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h3><p><img src="/assets/8e55b250e3064f519fd196741918f652.png" alt="8e55b250e3064f519fd196741918f652.png"></p><h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p><img src="/assets/884f81bd5b1d472f81992205b66c2daf.png" alt="884f81bd5b1d472f81992205b66c2daf.png"></p><h2 id="复合查询-1"><a href="#复合查询-1" class="headerlink" title="复合查询"></a>复合查询</h2><h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p><img src="/assets/a7c8fbc7b08e4c529d33aad057a93250.png" alt="a7c8fbc7b08e4c529d33aad057a93250.png"><br>【例】：搜索关键字为“脱脂牛奶”，品牌为“德亚”，价格低于300元</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建Request对象</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 配置Request参数</span></span><br><span class="line">    request.source().query(</span><br><span class="line">            QueryBuilders.boolQuery()</span><br><span class="line">                    .must(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>))</span><br><span class="line">                    .filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;德亚&quot;</span>))</span><br><span class="line">                    .filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lt(<span class="number">30000</span>))</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4. 解析结果</span></span><br><span class="line">    parseResponseResult(response); <span class="comment">// 对上边解析response的步骤进行了封装</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序和分页-1"><a href="#排序和分页-1" class="headerlink" title="排序和分页"></a>排序和分页</h2><p><img src="/assets/18b783395c2b4960bd2b2ba510271222.png" alt="18b783395c2b4960bd2b2ba510271222.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSortAndPage</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery()) <span class="comment">// query条件</span></span><br><span class="line">            .from((pageNo - <span class="number">1</span>) * pageSize).size(pageSize) <span class="comment">// 分页条件(分页开始的位置, 每页文档数量)</span></span><br><span class="line">            .sort(<span class="string">&quot;sold&quot;</span>, SortOrder.DESC)</span><br><span class="line">            .sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC); <span class="comment">// 排序条件(排序字段, 排序方式)</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    parseResponseResult(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高亮显示-1"><a href="#高亮显示-1" class="headerlink" title="高亮显示"></a>高亮显示</h2><p><img src="/assets/e3a3c7b588604fb496f34acb625fc0d9.png" alt="e3a3c7b588604fb496f34acb625fc0d9.png"><br>高亮显示的结果解析：<br><img src="/assets/c3e042b09f4c4baaa1fc3755d933deb1.png" alt="c3e042b09f4c4baaa1fc3755d933deb1.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighLight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>)) <span class="comment">// 查询条件</span></span><br><span class="line">            .highlighter(SearchSourceBuilder.highlight().field(<span class="string">&quot;name&quot;</span>)); <span class="comment">// 高亮条件</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    parseResponseResult(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于高亮的结果不是在source里的，所以parseResponseResult()方法需要添加对高亮的处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parseResponseResult</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">   <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">   <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value; <span class="comment">// 查询的总条数</span></span><br><span class="line">   SearchHit[] hits = searchHits.getHits(); <span class="comment">// 查询的结果数组</span></span><br><span class="line">   <span class="keyword">for</span>(SearchHit hit : hits) &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();<span class="comment">// 得到source</span></span><br><span class="line">       <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(json, ItemDoc.class);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// ===处理高亮结果===</span></span><br><span class="line">       Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();</span><br><span class="line">       <span class="keyword">if</span>(hfs != <span class="literal">null</span> &amp;&amp; !hfs.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">// 根据高亮字段名获取高亮结果</span></span><br><span class="line">           <span class="type">HighlightField</span> <span class="variable">hf</span> <span class="operator">=</span> hfs.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">           <span class="comment">// 获取高亮结果后，用高亮结果覆盖非高亮结果</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">hfName</span> <span class="operator">=</span> hf.getFragments()[<span class="number">0</span>].string(); <span class="comment">// 高亮结果</span></span><br><span class="line">           itemDoc.setName(hfName); <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(itemDoc);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h1><p>聚合可以实现对文档数据的统计、分析、运算，聚合常见的有：</p><ol><li><code>桶聚合</code>：用来对文档做分组<ul><li>TermAggregation（<strong>term</strong>）：按照文档字段值分组</li><li>Date Histogram：按照日期阶梯分组，例如：一周为一组，或一月为一组</li></ul></li><li><code>度量聚合</code>：用来计算一些值，如：最大值、最小值、平均值<ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum</li></ul></li><li><code>管道聚合</code>：其他聚合结果为基础做聚合，聚合的数据是其他聚合的结果</li></ol><blockquote><p>参与聚合的字段必须是Keyword、数值、日期、布尔类型的字段</p></blockquote><h2 id="DSL聚合"><a href="#DSL聚合" class="headerlink" title="DSL聚合"></a>DSL聚合</h2><p>【例1】：统计所有商品中的商品分类</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) &quot;categroyAgg&quot; <span class="keyword">from</span> items <span class="keyword">group</span> <span class="keyword">by</span> category</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;, <span class="operator">/</span><span class="operator">/</span> 如果使用&quot;match_all&quot;，可以省略</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>, <span class="operator">/</span><span class="operator">/</span> 如果不设置size，默认为<span class="number">10</span>，不仅会返回聚合结果，还会返回搜索结果，增加网络传输的负担</span><br><span class="line">  &quot;aggs&quot;: &#123; <span class="operator">/</span><span class="operator">/</span> 定义聚合</span><br><span class="line">    &quot;categroyAgg&quot;: &#123; <span class="operator">/</span><span class="operator">/</span> 给聚合起个名字</span><br><span class="line">      &quot;terms&quot;: &#123; <span class="operator">/</span><span class="operator">/</span> 聚合的类型，按照分类聚合，所以选择term</span><br><span class="line">        &quot;field&quot;: &quot;category&quot;, <span class="operator">/</span><span class="operator">/</span> 参与聚合的字段</span><br><span class="line">        &quot;size&quot;: <span class="number">5</span> <span class="operator">/</span><span class="operator">/</span> 希望获取的聚合结果数量</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/f29c201884a04b25be600954c26364a5.png" alt="f29c201884a04b25be600954c26364a5.png"><br>【例2】：统计手机的品牌，每个品牌价格的最小值、最大值、平均值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>items<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;category&quot;: &quot;手机&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;brandAgg&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;brand&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;price_stats&quot;: &#123;</span><br><span class="line">          &quot;stats&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;price&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/4c0c108af89348e08fcc888e6cd7fd42.png" alt="4c0c108af89348e08fcc888e6cd7fd42.png"></p><h2 id="JavaRestClient聚合"><a href="#JavaRestClient聚合" class="headerlink" title="JavaRestClient聚合"></a>JavaRestClient聚合</h2><p><img src="/assets/6a085a6d89bd4516ac36f3e34ff2258a.png" alt="6a085a6d89bd4516ac36f3e34ff2258a.png"><br>解析聚合结果：<br><img src="/assets/b71d01646c2842bfaf933f0048f6fa70.png" alt="b71d01646c2842bfaf933f0048f6fa70.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAgg</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">brandAggName</span> <span class="operator">=</span> <span class="string">&quot;brandAgg&quot;</span>;</span><br><span class="line">    request.source()</span><br><span class="line">            .size(<span class="number">0</span>) <span class="comment">// 不返回文段，只返回聚合结果</span></span><br><span class="line">            .aggregation(AggregationBuilders.terms(brandAggName) <span class="comment">// 聚合类型、聚合名称</span></span><br><span class="line">                    .field(<span class="string">&quot;brand&quot;</span>) <span class="comment">// 聚合字段</span></span><br><span class="line">                    .size(<span class="number">20</span>) <span class="comment">// 聚合返回结果</span></span><br><span class="line">            );</span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 解析结果</span></span><br><span class="line">    <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    <span class="comment">// 根据聚合名称获取对应的聚合</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">terms</span> <span class="operator">=</span> aggregations.get(brandAggName); <span class="comment">// 这里用了向下转型（Aggregation：父、Terms：子）</span></span><br><span class="line">    <span class="comment">// 获取buckets</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = terms.getBuckets();</span><br><span class="line">    <span class="comment">// 遍历每一个bucket</span></span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;brand:&quot;</span> + bucket.getKeyAsString());</span><br><span class="line">        System.out.println(<span class="string">&quot;count:&quot;</span> + bucket.getDocCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch上</title>
      <link href="/post/88db839a.html"/>
      <url>/post/88db839a.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h1><ul><li>Lucene：Java语言的搜索引擎类库，易扩展；高性能（基于倒排索引）</li><li>Elasticsearch基于Lucene，支持分布式，可水平扩展；提供Restful接口，可被任何语言调用</li><li>Elasticsearch结合kibana、logstash、Beats，是一套完整的技术栈，被叫做ELK。<br><img src="/assets/930b9838c9514033be11e0400478269a.png" alt="930b9838c9514033be11e0400478269a.png"></li></ul><h2 id="安装ElasticSearch-1"><a href="#安装ElasticSearch-1" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name es \</span><br><span class="line">  -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \</span><br><span class="line">  -e &quot;discovery.type=single-node&quot; \</span><br><span class="line">  -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">  -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">  --privileged \</span><br><span class="line">  --network hm-net \</span><br><span class="line">  -p 9200:9200 \</span><br><span class="line">  -p 9300:9300 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><ul><li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code> ：配置JVM的最大最小内存</li><li><code>-e &quot;discovery.type=single-node&quot;</code>：配置运行模式（集群模式、单点模式）</li><li><code>-v es-data:/usr/share/elasticsearch/data</code>：es的数据存储目录</li><li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：es的插件目录</li><li><code>-p 9200:9200</code>：访问的http端口</li><li><code>-p 9300:9300</code>：集群间通信端口</li></ul><blockquote><p>查看es的日志：<code> docker logs -f es</code><br><img src="/assets/5bf4577a4b594756b3bf188e79fe0cfd.png" alt="5bf4577a4b594756b3bf188e79fe0cfd.png"><br><img src="/assets/28d478f9ecc14c87b0b46d9900bddf77.png" alt="28d478f9ecc14c87b0b46d9900bddf77.png"></p></blockquote><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>Kibana是个图形界面，帮助我们连接es</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=hm-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">--restart=always \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure><ul><li><code>-e ELASTICSEARCH_HOSTS=http://es:9200 \</code>：因为kibana和es在同一个网络下，所以可以通过容器名直接连接es<br><img src="/assets/d7e47a8ae9324d3baeea300602dfc6e4.png" alt="d7e47a8ae9324d3baeea300602dfc6e4.png"></li></ul><blockquote><p>安装成功后，在浏览器输入：<code>http://192.168.140.101:5601/</code>，看到响应即安装成功。<br><img src="/assets/c40ab9bb8a294d60a4402f1380cdabd6.png" alt="c40ab9bb8a294d60a4402f1380cdabd6.png"><br>可以利用kibana中<code>Dev Tools</code>控制台向es发送http请求</p></blockquote><h1 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h1><p>MySQL采用的是正向索引：<br><img src="/assets/4001096f000443a9b7421bc5e89416ac.png" alt="4001096f000443a9b7421bc5e89416ac.png"></p><blockquote><p>查询词条时需要<code>逐行遍历文档</code>，再判断文档中是否包含了词条</p></blockquote><p>Elasticsearch采用倒排索引：</p><ul><li>文档（document）：每条数据就是一个文档</li><li>词条（term）：文档按照语义分成的词语<br><img src="/assets/831fb28a305940a7a15ea2292f0d9863.png" alt="831fb28a305940a7a15ea2292f0d9863.png"></li></ul><blockquote><p>用户搜索的时候，先对用户搜索的数据进行分词，将分词后的词条放到<code>词条列表</code>中得到文档id，根据文档id去<code>文档列表</code>中查询。虽然有两次查询，但是每次查询都是有索引，搜索速度快。</p></blockquote><h1 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h1><p>中文分词往往需要根据语义，比较复杂，这就需要用到中文分词器，例如：<code>IK分词器</code>。<br>下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip">IK分词器</a></p><h2 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h2><p>只需要把IK分词器下载后放到<code>es的插件目录</code>后<code>重启es</code>即可生效。<br><img src="/assets/065c15d57a1e4149ae334cb4176c6253.png" alt="065c15d57a1e4149ae334cb4176c6253.png"></p><h2 id="测试IK分词器是否安装成功"><a href="#测试IK分词器是否安装成功" class="headerlink" title="测试IK分词器是否安装成功"></a>测试IK分词器是否安装成功</h2><h3 id="ik-smart"><a href="#ik-smart" class="headerlink" title="ik_smart"></a>ik_smart</h3><p>智能切分，粗粒度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;今天天气真好&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/bcd463bbd34c4d8aae5c8156aab1a128.png" alt="bcd463bbd34c4d8aae5c8156aab1a128.png"></p><h3 id="ik-max-word"><a href="#ik-max-word" class="headerlink" title="ik_max_word"></a>ik_max_word</h3><p>最细切分，细粒度IK分词器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;今天天气真好&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/f672e0f46f2d4537b0cbd985ebd8a65e.png" alt="f672e0f46f2d4537b0cbd985ebd8a65e.png"></p><h2 id="自定义词典"><a href="#自定义词典" class="headerlink" title="自定义词典"></a>自定义词典</h2><p>可以在ik插件的config目录下的IKAnalyzer.cfg.xml文件配置<code>扩展词典</code>、<code>停止词典</code><br><img src="/assets/3dee2da829594868a3380a1284a3f975.png" alt="3dee2da829594868a3380a1284a3f975.png"></p><h1 id="ElasticSearch中基础概念"><a href="#ElasticSearch中基础概念" class="headerlink" title="ElasticSearch中基础概念"></a>ElasticSearch中基础概念</h1><p><img src="/assets/8d52bf4e8af14734ae540e7c7384115b.png" alt="8d52bf4e8af14734ae540e7c7384115b.png"></p><h1 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h1><p>索引库相当于MySQL里的表，Mapping相当于对表字段的约束</p><h2 id="Mapping映射属性"><a href="#Mapping映射属性" class="headerlink" title="Mapping映射属性"></a>Mapping映射属性</h2><p>mapping是对索引库中文档的约束。</p><ol><li>type：字段数据类型<ul><li>字符串：text（可分词文本）、keyword（精确值，不能分词，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float</li><li>布尔：boolean</li><li>日期：date（es自己把日期对象做了序列化）</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true<ul><li>true：es就会给这个字段创建倒排索引，就可以根据这个字段进行搜索或排序</li></ul></li><li>analyzer：使用哪种分词器（ik_smart、ik_max_word），只有字段类型是text才需要指定分词器</li><li>properties：该字段的子字段</li></ol><blockquote><p>在es中，不需要管是否是数组，就算是数组，也只要指定元素的类型即可</p></blockquote><h2 id="索引库的CRUD"><a href="#索引库的CRUD" class="headerlink" title="索引库的CRUD"></a>索引库的CRUD</h2><p>es中提供的API都是Restful的接口，遵循Restful的基本规范：<br><img src="/assets/3280b872e43b4f0a81e21e2fe3e6e444.png" alt="3280b872e43b4f0a81e21e2fe3e6e444.png"></p><h3 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PUT <span class="operator">/</span>索引库名称</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;字段名&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;, <span class="operator">/</span><span class="operator">/</span> 可分词</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;字段名2&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;, <span class="operator">/</span><span class="operator">/</span> 不可分词</span><br><span class="line">        &quot;index&quot;: &quot;false&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;字段名3&quot;:&#123;</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;子字段&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="operator">/</span><span class="operator">/</span> ...略</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建索引库</span><br><span class="line">PUT <span class="operator">/</span>people </span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;info&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;byte&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;email&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;false&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">        &quot;properties&quot;: &#123;</span><br><span class="line">          &quot;firstName&quot;:&#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;lastName&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/f7dfaa5973ff49fcbc8a1a9611342af8.png" alt="f7dfaa5973ff49fcbc8a1a9611342af8.png"></p><h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PUT <span class="operator">/</span>索引库名<span class="operator">/</span>_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;新字段名&quot;:&#123;</span><br><span class="line">      &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 修改索引库，新增一个sex字段</span><br><span class="line">PUT <span class="operator">/</span>people<span class="operator">/</span>_mapping </span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;sex&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：es中是<code>不允许对已有索引库的字段进行修改</code>，但是<code>允许添加新的字段</code>。<br>【原因】：假设已经在es中创建大量的倒排索引，做了大量的分词，如果此时需要修改索引库，那么前期做的所有分词都作废还要重新建立倒排索引，对于整个数据库的影响很大。</p></blockquote><h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询索引库</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名</span><br></pre></td></tr></table></figure><h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除索引库</span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">/</span>索引库名</span><br></pre></td></tr></table></figure><h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><h2 id="文档的CRUD"><a href="#文档的CRUD" class="headerlink" title="文档的CRUD"></a>文档的CRUD</h2><h3 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>索引库名<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;字段1&quot;: &quot;值1&quot;,</span><br><span class="line">    &quot;字段2&quot;: &quot;值2&quot;,</span><br><span class="line">    &quot;字段3&quot;: &#123;</span><br><span class="line">        &quot;子属性1&quot;: &quot;值3&quot;,</span><br><span class="line">        &quot;子属性2&quot;: &quot;值4&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>people<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;info&quot;: &quot;程序员&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;xiaolin0333@qq.com&quot;,</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">        &quot;firstName&quot;: &quot;林&quot;,</span><br><span class="line">        &quot;lastName&quot;: &quot;三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>新增文档的时候最好指定文档id，es会根据文档id创建索引，如果不指定id，es会随机生成id，这样将来操作文档就会很不方便</p></blockquote><h3 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h3><h4 id="1-全量修改"><a href="#1-全量修改" class="headerlink" title="1. 全量修改"></a>1. 全量修改</h4><p>删除旧文档，添加新文档</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PUT <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;字段1&quot;: &quot;值1&quot;,</span><br><span class="line">    &quot;字段2&quot;: &quot;值2&quot;,</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> ... 文档的所有字段都要写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：如果想要修改一个文档id不存在的文档，删除文档的时候，文档不存在，会直接新增一条文档<br>因此PUT请求具备了<code>新增</code>和<code>修改</code>两种功能</p><ul><li>新增：文档id不存在</li><li>修改：文档id存在</li></ul></blockquote><h4 id="2-增量修改"><a href="#2-增量修改" class="headerlink" title="2. 增量修改"></a>2. 增量修改</h4><p>修改部分字段值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>&#123;索引库名&#125;<span class="operator">/</span>_update<span class="operator">/</span>文档id</span><br><span class="line">&#123;</span><br><span class="line">    &quot;doc&quot;: &#123;</span><br><span class="line">         &quot;字段名&quot;: &quot;新的值&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询文档</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br></pre></td></tr></table></figure><p><img src="/assets/ace01edaf4b84bc0a8ad8f48d168782c.png" alt="ace01edaf4b84bc0a8ad8f48d168782c.png"></p><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除文档</span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">/</span>索引库名<span class="operator">/</span>_doc<span class="operator">/</span>文档id</span><br></pre></td></tr></table></figure><h2 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h2><p>es中允许通过一次请求中携带多次文档操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123; &quot;index&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;1&quot; &#125; &#125; <span class="operator">/</span><span class="operator">/</span> 新增（索引库名、id）</span><br><span class="line">&#123; &quot;field1&quot; : &quot;value1&quot; &#125; <span class="operator">/</span><span class="operator">/</span> 新增的文档信息</span><br><span class="line"></span><br><span class="line">&#123; &quot;delete&quot; : &#123; &quot;_index&quot; : &quot;test&quot;, &quot;_id&quot; : &quot;2&quot; &#125; &#125; <span class="operator">/</span><span class="operator">/</span> 删除（索引库名、id）</span><br><span class="line"></span><br><span class="line">&#123; &quot;update&quot; : &#123;&quot;_id&quot; : &quot;1&quot;, &quot;_index&quot; : &quot;test&quot;&#125; &#125; <span class="operator">/</span><span class="operator">/</span> 更新（索引库名、id）</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125; <span class="operator">/</span><span class="operator">/</span> 更新的文档信息（增量修改）</span><br></pre></td></tr></table></figure><blockquote><p>写的时候不能换行，只能在一行写，否则会报错</p></blockquote><p>【例1】：批量新增</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>_bulk </span><br><span class="line">  &#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;2&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;info&quot;: &quot;这是人&quot;, &quot;email&quot;: &quot;xiaolin0333@qq.com&quot;, &quot;name&quot;: &#123;&quot;firstName&quot;: &quot;林&quot;, &quot;lastName&quot;: &quot;三&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;index&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;3&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;info&quot;: &quot;这是狗&quot;, &quot;email&quot;: &quot;cmb@qq.com&quot;, &quot;name&quot;: &#123;&quot;firstName&quot;: &quot;柴&quot;, &quot;lastName&quot;: &quot;犬&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>【例2】：批量删除</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">POST <span class="operator">/</span>_bulk </span><br><span class="line">  &#123;&quot;delete&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;2&quot;&#125;&#125;</span><br><span class="line">  &#123;&quot;delete&quot;: &#123;&quot;_index&quot;: &quot;people&quot;,&quot;_id&quot;: &quot;3&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaRestClient"><a href="#JavaRestClient" class="headerlink" title="JavaRestClient"></a>JavaRestClient</h1><h2 id="客户端初始化"><a href="#客户端初始化" class="headerlink" title="客户端初始化"></a>客户端初始化</h2><ol><li>引入es的RestHighLevelClient的依赖：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>因为SpringBoot默认ES的版本是7.17.0，所以需要覆盖默认的ES版本：</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>初始化RestHighLevelClient（这里暂时先用单元测试为例）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElasticTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client = &quot;</span> + client);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@BeforeEach</span> <span class="comment">// 初始化方法：在单元测试执行前</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.140.101:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterEach</span> <span class="comment">// 销毁方法：在单元测试执行后</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(client != <span class="literal">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="商品表Mapping映射"><a href="#商品表Mapping映射" class="headerlink" title="商品表Mapping映射"></a>商品表Mapping映射</h2><p>【业务分析】：<br><img src="/assets/e9b41e2aadc4472abdeecb3f50a41b3a.png" alt="e9b41e2aadc4472abdeecb3f50a41b3a.png"><br><img src="/assets/ece92419c1134c71a9eaefe155ad8864.png" alt="ece92419c1134c71a9eaefe155ad8864.png"><br>【在控制台创建Mapping映射】：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 商品索引库</span><br><span class="line">PUT <span class="operator">/</span>hmall</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;name&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;price&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;image&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;,</span><br><span class="line">        &quot;index&quot;: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;category&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;brand&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;sold&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;commentCount&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer&quot;,</span><br><span class="line">        &quot;index&quot;: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;isAD&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;boolean&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;updateTime&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引库操作-1"><a href="#索引库操作-1" class="headerlink" title="索引库操作"></a>索引库操作</h2><ol><li>创建XxxIndexRequest。Xxx指：Create、Get、Delete</li><li>准备请求参数（Create需要）</li><li>发送请求。调用client.indices.xxx()方法，xxx指：create、get、exists、delete</li></ol><h3 id="创建索引库-1"><a href="#创建索引库-1" class="headerlink" title="创建索引库"></a>创建索引库</h3><p>创建索引库的JavaAPI和Restful接口API对比：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 准备请求参数</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON); <span class="comment">// MAPPING_TEMPLATE就是前面在控制台写的那段</span></span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/65d6537c9bab4055847d8fae1a6b8d72.png" alt="65d6537c9bab4055847d8fae1a6b8d72.png"></p><h3 id="查询索引库-1"><a href="#查询索引库-1" class="headerlink" title="查询索引库"></a>查询索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 发送请求</span></span><br><span class="line">    <span class="type">GetIndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.indices().get(request, RequestOptions.DEFAULT);<span class="comment">// 查询索引库（索引库不存在报错）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);<span class="comment">// 判断索引库是否存在（索引库不存在返回false）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     <span class="comment">// 1. 准备Request对象</span></span><br><span class="line">     <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">     <span class="comment">// 2. 发送请求</span></span><br><span class="line">     client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="文档操作-1"><a href="#文档操作-1" class="headerlink" title="文档操作"></a>文档操作</h2><ol><li>初始化RestHighLevelClient</li><li>创建XxxRequest。Xxx指：Index、Get、Update、Delete</li><li>准备参数（Index和Update需要）</li><li>请求参数。调用xxx()方法，xxx是index、get、update、delete</li><li>解析结果（Get需要）</li></ol><h3 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h3><p>新增文档的JavaAPI和Restful接口API对比：<br><img src="/assets/22d934d176f3427d9b51644eb52e8dbb.png" alt="22d934d176f3427d9b51644eb52e8dbb.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testIndexDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 准备文档数据</span></span><br><span class="line">    <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getById(<span class="number">2018833</span>);</span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class); <span class="comment">// 文档数据对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(itemDoc); <span class="comment">// JSON</span></span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(itemDoc.getId());<span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 准备JSON文档</span></span><br><span class="line">    request.source(jsonStr, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h3><h4 id="全量修改"><a href="#全量修改" class="headerlink" title="全量修改"></a>全量修改</h4><p>全量修改相当于新增，就是新增的时候文档id已经存在</p><h4 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h4><p><img src="/assets/f369c5e2c72644c18b1cdec0eac46372.png" alt="f369c5e2c72644c18b1cdec0eac46372.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;2018833&quot;</span>); <span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>, <span class="number">25600</span>,</span><br><span class="line">            <span class="string">&quot;stock&quot;</span>, <span class="number">9999</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3. 发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h3><p>查询文档主要是拿到_source部分<br><img src="/assets/98d5e2804ab847c2b7656976a4c8f037.png" alt="98d5e2804ab847c2b7656976a4c8f037.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;2018833&quot;</span>); <span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 发送请求</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">doc</span> <span class="operator">=</span> JSONUtil.toBean(json, ItemDoc.class);</span><br><span class="line">    System.out.println(doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 准备Request</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;2018833&quot;</span>); <span class="comment">// 索引库名、文档id</span></span><br><span class="line">    <span class="comment">// 2. 发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>构建请求时会用到BulkRequest来封装普通的CRUD请求：<br><img src="/assets/018d138da6544a71aed9f9d5387c3fb6.png" alt="018d138da6544a71aed9f9d5387c3fb6.png"><br>【案例】：往索引库里添加所有上架的商品</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 0. 准备文档数据</span></span><br><span class="line">        Page&lt;Item&gt; page = itemService.lambdaQuery()</span><br><span class="line">                .eq(Item::getStatus, <span class="number">1</span>) <span class="comment">// 上架商品</span></span><br><span class="line">                .page(Page.of(pageNo, pageSize));</span><br><span class="line">        List&lt;Item&gt; records = page.getRecords();</span><br><span class="line">        <span class="keyword">if</span>(records == <span class="literal">null</span> || records.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 准备Request</span></span><br><span class="line">        <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">        <span class="comment">// 2. 准备数据-批量新增</span></span><br><span class="line">        <span class="keyword">for</span>(Item item : records) &#123;</span><br><span class="line">            <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);</span><br><span class="line">            request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(item.getId().toString()).source(JSONUtil.toJsonStr(itemDoc), XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 发送请求</span></span><br><span class="line">        client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">        pageNo++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ确保消息可靠性</title>
      <link href="/post/619a560a.html"/>
      <url>/post/619a560a.html</url>
      
        <content type="html"><![CDATA[<h1 id="消息丢失的可能性"><a href="#消息丢失的可能性" class="headerlink" title="消息丢失的可能性"></a>消息丢失的可能性</h1><p><img src="/assets/d2795a487f804ce59f0ec8a984b9cf18.png" alt="d2795a487f804ce59f0ec8a984b9cf18.png"><br>支付服务先扣减余额和更新支付状态（这俩是同步调用），然后通过RabbitMq异步调用支付服务更新订单状态。但是有些情况下，可能订单已经支付 ，但是更新订单状态却失败了，这就出现了消息丢失。</p><ol><li><code>发送者</code>在发送的过程中出现了网络故障</li><li><code>RabbitMQ</code>在发送消息的过程中出现了问题</li><li><code>消费者</code>在更新订单状态的时候出现了问题</li></ol><h1 id="发送者的可靠性"><a href="#发送者的可靠性" class="headerlink" title="发送者的可靠性"></a>发送者的可靠性</h1><p>发送者确认机制需要与MQ进行通信和确认，会影响消息发送的效率且一般出现的概率极低，所以一般不用这个。</p><hr><h2 id="方法1-发送者重连"><a href="#方法1-发送者重连" class="headerlink" title="方法1. 发送者重连"></a>方法1. 发送者重连</h2><p>确保发送者与MQ之间连接的可靠性。有的时候由于网络波动，可能出现发送者连接MQ失败的情况，这个配置是关闭的，可以开启连接失败后的重连机制：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制(默认是false)</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><blockquote><p>【注】：当网络不稳定时，利用重试机制可以提高消息发送的成功率，但是SpringAMQP提供的重试机制是<code>阻塞式</code>的重试，如果需要多次重试等待，当前线程被阻塞，会影响性能。<br>如果对业务性能有要求，建议<code>禁用</code>重试机制，如果一定要使用，要合理的配置等待时常和重试次数，或使用<code>异步线程</code>来执行发送消息的代码。</p></blockquote><h2 id="方法2-发送者确认"><a href="#方法2-发送者确认" class="headerlink" title="方法2. 发送者确认"></a>方法2. 发送者确认</h2><p>确保消息发送的可靠性。SpringAMQP提供了Publisher Confirm和Publisher Return两种机制，开启确认机制后，当发送者发送消息给MQ后，MQ会返回确认结果给发送者，返回的结果有以下几种情况：</p><ul><li>消息投递到MQ，但是路由失败，此时通过PublisherReturn返回路由异常信息，然后返回<code>ACK</code>，告知投递成功。例如：<ul><li><pre><code>消息发送给图中的exchange1，但是RoutingKey写错了，没有匹配到正确的队列，也会导致路由失败。</code></pre></li><li><pre><code>消息发送给图中的exchange2，但是它底下没有绑定新的队列，就会导致路由失败。</code></pre></li></ul></li><li>临时消息【不需要往磁盘做持久化的消息】投递到MQ，并入队成功，返回<code>ACK</code>，告知投递成功。</li><li>持久消息投递到MQ，并入队完成持久化，返回<code>ACK</code>，告知投递成功。</li><li>其他情况都会返回<code>NACK</code>，告知投递失败。<br><img src="/assets/1d5dac29f79645f7b70988aec1b9332c.png" alt="1d5dac29f79645f7b70988aec1b9332c.png"><br>步骤：</li></ul><ol><li>在发送方publisher所在的微服务的application.yml中配置：</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><blockquote><p>publisher-confirm-type有三种模式：</p><ul><li>none：关闭confirm机制</li><li>simple：同步阻塞等待MQ回执消息</li><li>correlated：MQ异步回调方式返回回执消息（常用）</li></ul></blockquote><ol start="2"><li>开启回调机制：每个RabbitTemplate只能配置一个ReturnCallback，在发送者publisher所在的项目启动时配置即可。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// 在Bean初始化完成后调用这个方法（只会调用一次）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 返回ACK，但是此时路由失败，就会走这个方法</span></span><br><span class="line">        rabbitTemplate.setReturnsCallback(returnedMessage -&gt; &#123;</span><br><span class="line">            log.error(<span class="string">&quot;监听到了消息return callback&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returnedMessage.getExchange());</span><br><span class="line">            log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returnedMessage.getRoutingKey());</span><br><span class="line">            log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returnedMessage.getMessage());</span><br><span class="line">            log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returnedMessage.getReplyCode());</span><br><span class="line">            log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returnedMessage.getReplyText());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>开启消息确认机制：发送消息、指定消息ID、每次发送消息都需要配置一个ConfirmCallback</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConfirmCallback</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">  cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">      <span class="comment">// 【几乎不可能发生】Future发生异常时的处理逻辑</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">          log.error(<span class="string">&quot;spring ampq处理确认结果异常&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 成功，拿到MQ结果，判断是ACK还是NACK</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(result.isAck()) &#123;</span><br><span class="line">              <span class="comment">// ACK</span></span><br><span class="line">              log.debug(<span class="string">&quot;收到ACK，消息发送成功&quot;</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// NACK</span></span><br><span class="line">              log.debug(<span class="string">&quot;收到NACK，消息发送失败，失败原因：&#123;&#125;&quot;</span>,result.getReason());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;hello world&quot;</span>, cd); <span class="comment">// 发送消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h1><p>RabbitMQ一般会将收到的信息保存到<strong>内存</strong>（速度快）中，降低消息收发的延迟，这样会导致：</p><ol><li>MQ宕机，内存中的消息会丢失。</li><li>内存空间有限，消费者故障或处理过慢，会导致消息积压，引发MQ阻塞。<br><img src="/assets/b6edb928b1264d50a5b503b2c56e5df9.png" alt="b6edb928b1264d50a5b503b2c56e5df9.png"></li></ol><blockquote><p>【案例】发送者往MQ发消息，MQ会把数据保存到内存中，如果内存<strong>满了</strong>，MQ就会把一部分数据迁移到磁盘中暂时进行持久化存储，移动到磁盘的这段时间发送者发送的消息就会产生丢失。</p></blockquote><h2 id="方法1-数据持久化"><a href="#方法1-数据持久化" class="headerlink" title="方法1. 数据持久化"></a>方法1. 数据持久化</h2><p>数据持久化就是把数据持久化到磁盘，但是不是向上边那个案例，等满了再去持久化（被动），而是提前进行持久化。</p><ol><li>交换机的持久化（默认开启的）<br><img src="/assets/8a372d3f987e4948a4e72a6ba5a9b0d3.png" alt="8a372d3f987e4948a4e72a6ba5a9b0d3.png"></li><li>队列的持久化（默认开启的）<br><img src="/assets/87f68a2ef34a485db948adb22b1a51cf.png" alt="87f68a2ef34a485db948adb22b1a51cf.png"></li><li>消息持久化（默认是非持久的）<br>在发送消息的时候设定的<br><img src="/assets/af7cbfc0248d4d598289121a8f7bf452.png" alt="af7cbfc0248d4d598289121a8f7bf452.png"><br>【<code>案例</code>】：比较一下持久化和非持久化的性能。<br>发100w条消息给MQ：<br>这是非持久化的方式：使用纯内存的方式存储，每次内存满之后，MQ就会把消息写到磁盘中，此时就会出现阻塞状态，处理速度降低到0<br><img src="/assets/c299dfe47826452d93a6d5ff9731fb21.png" alt="c299dfe47826452d93a6d5ff9731fb21.png"><br>【<code>问题</code>】可能出现消息丢失和MQ阻塞<br>【<code>解决办法</code>】使用持久化的方式：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendPersistentMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 自定义构建消息</span></span><br><span class="line">    <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> MessageBuilder.withBody(<span class="string">&quot;hello world&quot;</span>.getBytes(StandardCharsets.UTF_8)) <span class="comment">// 消息体</span></span><br><span class="line">            .setDeliveryMode(MessageDeliveryMode.PERSISTENT) <span class="comment">// 投递模式（持久化）</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;simple.queue&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mq并没有阻塞，每发一条消息就赶紧把它存到磁盘中，和纯内存方式相比，不会有个中断的过程。<br><img src="/assets/a7722b341dda45fa8520dce35998273c.png" alt="a7722b341dda45fa8520dce35998273c.png"></p><h2 id="方法2-Lazy-Queue（推荐）"><a href="#方法2-Lazy-Queue（推荐）" class="headerlink" title="方法2. Lazy Queue（推荐）"></a>方法2. Lazy Queue（推荐）</h2><p>【<code>问题</code>】：由于使用了消息持久化的方式，发到MQ的消息不仅要到内存，还要在磁盘中写一份，这会导致整体的并发能力下降<br>【<code>特征</code>】：</p><ul><li>接收到消息后直接入磁盘，不再存储到内存</li><li>在写磁盘的时候也对写入磁盘的操作进行一些优化，比传统的写操作高很多</li><li>消费者要消费消息时，才会从磁盘中读取并加载到内存<ul><li>【<code>问题</code>】：可能会影响消费者处理消息的速度</li><li>【<code>解决</code>】：可以提前缓存部分消息到内存，最多2048条</li></ul></li></ul><h3 id="控制台声明Lazy-Queue队列"><a href="#控制台声明Lazy-Queue队列" class="headerlink" title="控制台声明Lazy Queue队列"></a>控制台声明Lazy Queue队列</h3><p><img src="/assets/423f7c05c9014ea4b6a827925a1c0a41.png" alt="423f7c05c9014ea4b6a827925a1c0a41.png"></p><h3 id="Java代码添加"><a href="#Java代码添加" class="headerlink" title="Java代码添加"></a>Java代码添加</h3><h4 id="声明Bean"><a href="#声明Bean" class="headerlink" title="声明Bean"></a>声明Bean</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RabbitListener注解"><a href="#RabbitListener注解" class="headerlink" title="@RabbitListener注解"></a>@RabbitListener注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;) // 开启Lazy模式</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h1><h2 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h2><p>为了确认消费者是否成功处理消息，当消费者处理消息结束后，应该向MQ发送一个回执，告知MQ自己的消息处理状态。有如下几种消息处理状态：</p><ul><li>ack：处理消息成功，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息【在处理的过程中，发现消息的内容有问题，没有重试的必要，直接拒绝就行】</li></ul><blockquote><p>【注意】：不管是哪种情况，都应该等消息处理完后得到结果再返回，不要一拿到消息就返回<br>返回消息处理状态的过程，类似于处理事务，事务处理成功，返回ACK；处理失败，返回NACK</p></blockquote><p>SpringAMQP允许通过在消费者的配置文件选择ACK的处理方式，有三种：</p><ul><li>none：不处理，消息投递给消费者后立刻ack，消息会立刻从MQ中删除，别用</li><li>manual：手动模式，需要在业务代码中调用api，发送ack或reject，存在业务入侵，但是更灵活。</li><li>auto：自动模式，利用AOP对消息处理逻辑进行了环绕增强<ul><li>业务处理正常：自动返回<code>ack</code></li><li>业务处理异常：自动返回<code>nack</code></li><li>消息处理或校验异常【MessageConversionException】：自动返回<code>reject</code></li></ul></li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto#</span> <span class="string">不做处理</span></span><br></pre></td></tr></table></figure><h2 id="失败重试策略"><a href="#失败重试策略" class="headerlink" title="失败重试策略"></a>失败重试策略</h2><p>在消费者出现异常时，利用本地重试，而不是无限的重新入队到mq，可以在消费者的yaml文件中添加配置来开启重试机制。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数（达到最大重试次数后，MQ会把消息丢弃）</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p>【<code>问题</code>】：在开启重试模式后，重试次数耗尽，如果消息仍然失败，默认会把消息进行丢弃。<br>【<code>解决</code>】：因此需要有MessageRecoverer接口来处理，包含三种不同的实现：</p><ul><li>RejectAndDontRequeueRecoverer（默认）：重试耗尽后，直接reject，丢弃消息。</li><li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队。</li><li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机 。<br><img src="/assets/37694c723e9b44a39bee6b67070c4b07.png" alt="37694c723e9b44a39bee6b67070c4b07.png"></li></ul><h3 id="修改失败重试策略为RepublishMessageRecoverer"><a href="#修改失败重试策略为RepublishMessageRecoverer" class="headerlink" title="修改失败重试策略为RepublishMessageRecoverer"></a>修改失败重试策略为RepublishMessageRecoverer</h3><ol><li>定义接收失败的交换机、队列、 </li><li>定义RepublishMessageRecoverer</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 定义接收失败的交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义接收失败的队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义绑定关系</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorQueueBinding</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue())</span><br><span class="line">                .to(errorExchange())</span><br><span class="line">                .with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义失败处理策略</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">messageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h2><p>f(x) &#x3D; f(f(x))，指同一个业务，执行一次或多次对业务状态的影响是一致的。</p><ul><li>幂等业务：查询业务、删除业务</li><li>非幂等业务：用户下单需要扣减库存、用户退款业务需要恢复余额</li></ul><h3 id="方案1-唯一消息id"><a href="#方案1-唯一消息id" class="headerlink" title="方案1. 唯一消息id"></a>方案1. 唯一消息id</h3><p>给每个消息设置一个唯一id，利用id区分是否是重复消息：</p><ul><li>每条消息都生成一个唯一id，与消息一起投递给消费者</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息id保存到数据库中</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则视为重复消息放弃处理</li></ul><ol><li>在发送方配置Bean用来自动创建消息id</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">        converter.setCreateMessageIds(<span class="literal">true</span>); <span class="comment">// 配置自动创建消息id</span></span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在接收方接收消息id</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(Message msg)</span> &#123; <span class="comment">// 使用字符串发送，就用字符串接收</span></span><br><span class="line">        log.info(<span class="string">&quot;监听到simple.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        log.info(<span class="string">&quot;消息id：&#123;&#125;&quot;</span>, msg.getMessageProperties().getMessageId());</span><br><span class="line">        <span class="comment">// throw new RuntimeException(&quot;故意的&quot;);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/ede2c8352f014e61a549afe6fa45d49f.png" alt="ede2c8352f014e61a549afe6fa45d49f.png"></p><h3 id="方案2-业务判断（常用）"><a href="#方案2-业务判断（常用）" class="headerlink" title="方案2. 业务判断（常用）"></a>方案2. 业务判断（常用）</h3><p>结合业务逻辑，基于业务本身做判断。<br>【<code>案例</code>】：当用户下单成功后，通过MQ通知交易服务来修改订单状态为已支付（这里记作<code>消息1</code>），修改成功后交易服务返回ACK给MQ，此时出现了网络的故障，MQ没有收到交易服务发送的ACK，MQ认为交易服务宕机，消息又重新入队。<br>就在此刻，用户点击了申请退款，直接向交易服务修改订单状态为退款中（这个操作没有走MQ，此时订单状态是退款中，但是消息1还在消息队列中）。<br>此时网络恢复了，MQ又将消息1发送给交易服务，此时交易服务又把订单状态标记为已支付（订单申请退款中的状态又被覆盖了）。<br><img src="/assets/6114b30ce9784387a6925375b1004202.png" alt="6114b30ce9784387a6925375b1004202.png"><br>【<code>解决</code>】：通知来的时候，先判断订单的状态，再进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayStatusListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IOrderService orderService;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;trade.pay.success.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;pay.direct&quot;),</span></span><br><span class="line"><span class="meta">            key = &quot;pay.success&quot;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenPaySuccess</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderService.getById(orderId);</span><br><span class="line">        <span class="comment">// 2.判断订单状态是否为未支付</span></span><br><span class="line">        <span class="keyword">if</span>(order == <span class="literal">null</span> || order.getStatus() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 不做处理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.标记订单状态为已支付</span></span><br><span class="line">        orderService.markOrderPaySuccess(orderId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/25e9d5b300b04d0cb730cf1ae91a7af4.png" alt="25e9d5b300b04d0cb730cf1ae91a7af4.png"></p><h1 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h1><p>延迟消息：发送者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息。<br>延迟任务：设置在一定时间后才执行的任务。<br><img src="/assets/f6713f02b3c349d096e499b1f02d077b.png" alt="f6713f02b3c349d096e499b1f02d077b.png"></p><h2 id="方案1-死信交换机"><a href="#方案1-死信交换机" class="headerlink" title="方案1. 死信交换机"></a>方案1. 死信交换机</h2><p>当一个队列中的消息满足下列情况之一的，就会成为<code>死信</code>：</p><ul><li>消费者使用basic.reject或basic.nack声明消费失败，并且消息的requeue参数设置为false。</li><li>消息是一个过期消息（达到队列设置的过期时间 或 消息本身设置的过期时间），超时无人消费。</li><li>要投递的队列消息堆积满了，最早的消息可能成为死信。</li></ul><p>队列通过<strong>dead-letter-exchange</strong>属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中，这个交换机就叫做<code>死信交换机</code>（DLX）。<br><img src="/assets/280e34d1fd4943eab40b6d6b71398e4c.png" alt="280e34d1fd4943eab40b6d6b71398e4c.png"></p><ol><li>声明死信队列、死信交换机、它们之间的绑定关系：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;dlx.queue&quot;, durable = &quot;true&quot;), // 死信队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;dlx.direct&quot;, type = ExchangeTypes.DIRECT), // 死信交换机</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;hi&quot;&#125; </span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDlxQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;消费者监听到dlx.queue的消息: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明普通队列、普通交换机、它们之间的绑定关系，并把队列绑定到死信交换机上（此时就不需要把它绑定消费者了）：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">normalExchange</span><span class="params">()</span> &#123; <span class="comment">// 普通交换机</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;normal.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">normalQueue</span><span class="params">()</span> &#123; <span class="comment">// 普通队列</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;normal.direct&quot;</span>) <span class="comment">// 队列名字</span></span><br><span class="line">                .deadLetterExchange(<span class="string">&quot;dlx.direct&quot;</span>) <span class="comment">// 死信交换机名字</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">normalQueueBinding</span><span class="params">(Queue normalQueue, DirectExchange normalExchange)</span> &#123; <span class="comment">// 绑定关系</span></span><br><span class="line">        <span class="comment">// 把队列绑定到交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(normalQueue) <span class="comment">// 队列</span></span><br><span class="line">                .to(normalExchange) <span class="comment">// 交换机</span></span><br><span class="line">                .with(<span class="string">&quot;hi&quot;</span>);<span class="comment">// 这里绑定关系要和普通队列的绑定关系保持一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>发送延迟消息：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDelayMsg</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;normal.direct&quot;</span>, <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;hello world&quot;</span>, message -&gt; &#123;</span><br><span class="line">        <span class="comment">// 当消息被转成Message对象后，还可以进一步做加工</span></span><br><span class="line">        message.getMessageProperties().setExpiration(<span class="string">&quot;10000&quot;</span>); <span class="comment">// 设置消息过期时间(10s)</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：<strong>normal.direct和normal.queue</strong>之间绑定的BindingKey 与 <strong>dlx.direct和dlx.queue</strong>之间绑定的BindingKey要一致</p></blockquote><h2 id="方案2-延迟消息插件DelayExchange（推荐）"><a href="#方案2-延迟消息插件DelayExchange（推荐）" class="headerlink" title="方案2. 延迟消息插件DelayExchange（推荐）"></a>方案2. 延迟消息插件DelayExchange（推荐）</h2><p>这个插件可以将普通交换机改造为支持延迟消息功能的交换机，当消息投递到交换机后，可以暂存一段时间，到后期再投递到队列。</p><h3 id="一、安装插件"><a href="#一、安装插件" class="headerlink" title="一、安装插件"></a>一、安装插件</h3><ol><li>插件下载地址：<a href="https://b11et3un53m.feishu.cn/wiki/A9SawKUxsikJ6dk3icacVWb4n3g#share-BinndxWXIorpaFxltoRclv6fnMG">DelayExchange</a></li><li>需要把插件放在RabbitMQ插件目录对应的数据卷下</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p><img src="/assets/571644c4a5004005bd5fceef602a40e9.png" alt="571644c4a5004005bd5fceef602a40e9.png"><br><img src="/assets/7d8aa7eb82744446b18d4a15f7a333b6.png" alt="7d8aa7eb82744446b18d4a15f7a333b6.png"></p><ol start="3"><li>执行命令，安装插件</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it rabbitmq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h3 id="二、使用插件"><a href="#二、使用插件" class="headerlink" title="二、使用插件"></a>二、使用插件</h3><ol><li>声明延迟交换机：只要设置delay的属性为true即可</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;, type = ExchangeTypes.DIRECT), // 只要设置一个delayed属性为true即可</span></span><br><span class="line"><span class="meta">        key = &#123;&quot;hi&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;消费者监听到delay.queue的消息: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>发送延迟消息：通过消息头x-delay来设置过期时间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDelayMsgByPlugin</span><span class="params">()</span> &#123;</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, <span class="string">&quot;hello world&quot;</span>, message -&gt; &#123;</span><br><span class="line">        message.getMessageProperties().setDelay(<span class="number">10000</span>);<span class="comment">// 添加延迟消息属性</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>延迟消息的实现需要记录消息的过期时间，计时的时钟需要依赖cpu，是个cpu密集型任务。因此使用延迟消息时，需要避免同一时刻在mq里存在大量的延迟消息（尽可能地让延迟消息的延迟时间不要太长）。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息丢失 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/post/b543ced0.html"/>
      <url>/post/b543ced0.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>虽然多线程也能做异步处理，但是多线程仅限于在同一个进程做异步处理，会占用服务器的资源。<br>MQ是可以分布式的，可以分担服务器的压力。</p></blockquote><h1 id="同步调用和异步调用"><a href="#同步调用和异步调用" class="headerlink" title="同步调用和异步调用"></a>同步调用和异步调用</h1><h2 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h2><p>优势：时效性强，等待到结果后才返回<br>问题：拓展性差、性能差、级联失败问题</p><h2 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h2><ul><li>消息发送者：投递消息的人（调用者）</li><li>消息接收者：接收和处理消息的人（服务提供者）</li><li>消息代理：管理、暂存、转发消息（微信服务器）<br><img src="/assets/7ac1576587c5453f95aaeaad8a28e8e2.png" alt="7ac1576587c5453f95aaeaad8a28e8e2.png"></li></ul><blockquote><p>扣减数据余额和更新支付状态必须采用同步调用。<br>更新订单状态、短信通知用户、增加用户积分，这三个业务其实和支付服务的关系不大，有点业务耦合，可以用异步调用，支付服务先发一条消息给消息代理，交易服务、通知服务、积分服务去监听消息代理。如果服务故障了，没有收到消息，只要这个服务重新启动，消息代理还会投递消息给这个服务。</p></blockquote><p>优势：解除耦合，拓展性好；无需等待；故障隔离；缓存消息，流量削峰填谷。<br>问题：不能立刻得到调用结果，时效性差；不能确定下游业务执行是否成功；业务安全依赖Broker的可靠性。</p><h2 id="MQ技术选型"><a href="#MQ技术选型" class="headerlink" title="MQ技术选型"></a>MQ技术选型</h2><p>MQ：消息队列，存放消息的队列。也就是异步调用的Broker<br><img src="/assets/7a3c7ee01adf459590df9d0ba9fca1a5.png" alt="7a3c7ee01adf459590df9d0ba9fca1a5.png"></p><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>创建并运行容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run  -d \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=admin \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=admin \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name rabbitmq \</span><br><span class="line"> --hostname rabbitmq \</span><br><span class="line">--restart=always \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> --network hm-net \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><ol start="2"><li>创建容器成功后，即可查看rabbitmq控制台：<code>http://192.168.140.101:15672</code>，用户名、密码为admin</li></ol><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>virtual-host：虚拟主机，起到数据隔离的作用</li><li>publisher：消息发送者</li><li>consumer：消息的消费者</li><li>queue：队列，存储消息</li><li>exchange：交换机，负责路由消息<br><img src="/assets/4787873ed4ff4f8e8a866b25113b115e.png" alt="4787873ed4ff4f8e8a866b25113b115e.png"></li></ul><blockquote><p>交换机只能路由消息，无法存储消息<br>交换机只会路由消息给与其绑定的队列，因此队列必须与交换机绑定</p></blockquote><h1 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h1><h2 id="收发消息"><a href="#收发消息" class="headerlink" title="收发消息"></a>收发消息</h2><ol><li>引入spring-amqp依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置RabbitMQ服务端信息，让微服务连接到rabbitmq</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span> <span class="comment"># 虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><ol start="3"><li>【发送消息】：SpringAMQP提供了RabbitTemplate工具类，方便我们发送消息</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>; <span class="comment">// 消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, msg); <span class="comment">// 发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>【接收消息】：只需要通过注解（<code>@RabbitListener</code>）在方法上声明要监听的队列名称，将来SpringAMQP就会把消息传递给当前方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue</span><span class="params">(String msg)</span> &#123; <span class="comment">// 使用字符串发送，就用字符串接收</span></span><br><span class="line">        log.info(<span class="string">&quot;监听到simple.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p> work Queues：任务模型，让<code>多个消费者绑定到一个队列</code>，共同消费队列中的消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line"><span class="comment">// 多个消费者绑定到同一个队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;consumer 1: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;work.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;consumer 2: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>实际开发只会写一个方法，但是在部署的时候会在不同服务器上部署多个实例，形成一个集群。<br>【<code>问题</code>】：默认是轮询投递给绑定在队列上的每一个消费者，但是这并没有考虑到消费者处理完消息，可能出现消息堆积的问题。<br>【<code>解决</code>】：修改application.yml，设置preFetch的值为1，确保同一时刻最多投递给消费者一条消息（性能好的服务器，处理的消息越多，能者多劳）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line"><span class="attr">listener:</span></span><br><span class="line"><span class="attr">simple:</span></span><br><span class="line"> <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="交换机的类型"><a href="#交换机的类型" class="headerlink" title="交换机的类型"></a>交换机的类型</h2><p>接收发送者发送的消息，并将消息路由到与其绑定的队列。<br><img src="/assets/19d6a91aad5646afa6e9fa613898128b.png" alt="19d6a91aad5646afa6e9fa613898128b.png"></p><h3 id="Fanout交换机（广播）"><a href="#Fanout交换机（广播）" class="headerlink" title="Fanout交换机（广播）"></a>Fanout交换机（广播）</h3><p>会将接收到的消息路由到每一个与其绑定的Queue。<br><img src="/assets/9f362598ed8b4902b945901ead3258e0.png" alt="9f362598ed8b4902b945901ead3258e0.png"></p><blockquote><p>【案例】：用户消费完毕，更新支付状态后，需要通知交易服务、短信服务、积分服务。如果没有交换机，通过队列发送，但是在队列里，一个消息只能被一个消费者处理。所以需要fanout交换机，把这个消息发送给所有的队列。</p></blockquote><p>发送消息到Fanout交换机的API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.fanout&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;<span class="comment">// 消息</span></span><br><span class="line">        <span class="comment">// 发送消息，参数分别为：交换机名，RoutingKey(暂时为空)，消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="literal">null</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：convertAndSend方法中两个参数默认是发给<code>队列</code>，三个参数是发给<code>交换机</code></p></blockquote><h3 id="Direct交换机（定向）"><a href="#Direct交换机（定向）" class="headerlink" title="Direct交换机（定向）"></a>Direct交换机（定向）</h3><p>会将接收到的消息根据<code>规则</code>（RoutingKey）路由到指定的Queue，规则如下：</p><ul><li>每一个Queue都与Exchange绑定时都需要设置一个BindingKey</li><li>发布者发布消息时，指定消息的RoutingKey</li><li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列<br><img src="/assets/adcd87bd2a454998874466cddbd409e1.png" alt="adcd87bd2a454998874466cddbd409e1.png"></li></ul><blockquote><p>【注】：当两个队列的BindingKey相同时，Direct交换机就变成了Fanout交换机。<br>【场景】：用户消费完毕后，如果点了取消，交易服务需要把订单状态变成已取消，但是不需要通知短信服务、积分服务了。此时只需要发给交易服务即可。</p></blockquote><p>在rabbitMq控制台设置交换机和队列的绑定关系，并设置RoutingKey：<br><img src="/assets/229f3d34f2f445afb2be234ee6615af6.png" alt="229f3d34f2f445afb2be234ee6615af6.png"><br>发送消息到Direct交换机的API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;蓝色&quot;</span>;<span class="comment">// 消息</span></span><br><span class="line">        <span class="comment">// 发送消息，参数分别为：交换机名，RoutingKey(绑定关系)，消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;blue&quot;</span>, msg); <span class="comment">// 此时只有direct.queue1收到消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic交换机（话题）"><a href="#Topic交换机（话题）" class="headerlink" title="Topic交换机（话题）"></a>Topic交换机（话题）</h3><p>也是基于RoutingKey做消息路由，但时RoutingKey通常是多个单词的组合，并且以<code>.</code>分割。<br>Queue与Exchange指定的BindingKey可以使用通配符：</p><ul><li>#：代表0个或多个单词</li><li>*：代表一个单词<br><img src="/assets/18608ac9f3074897853eab96668b1491.png" alt="18608ac9f3074897853eab96668b1491.png"></li></ul><p>在rabbitMq控制台设置交换机和队列的绑定关系，并设置RoutingKey：<br><img src="/assets/65f0d098fb8d4ff2be093a4c6759f03a.png" alt="65f0d098fb8d4ff2be093a4c6759f03a.png"><br>发送消息到Topic交换机的API：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTopicxchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.topic&quot;</span>; <span class="comment">// 队列名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;有关中国的新闻&quot;</span>;<span class="comment">// 消息</span></span><br><span class="line">        <span class="comment">// 发送消息，参数分别为：交换机名，RoutingKey(绑定关系)，消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, msg); <span class="comment">// 此时topic.queue1和topic.queue4都能收到消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明队列和交换机"><a href="#声明队列和交换机" class="headerlink" title="声明队列和交换机"></a>声明队列和交换机</h2><ul><li>Queue：声明队列，可以用工厂类QueueBuilder创建</li><li>Exchange：声明交换机，可以用工厂类ExchangeBuilder创建</li><li>Binding：声明队列和交换机的绑定关系，可以用工厂类BindingBuilder创建</li></ul><h3 id="基于JavaBean的方式声明"><a href="#基于JavaBean的方式声明" class="headerlink" title="基于JavaBean的方式声明"></a>基于JavaBean的方式声明</h3><p>【案例】：声明一个Direct类型的交换机，并创建两个队列与其绑定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">directExchange</span><span class="params">()</span> &#123; <span class="comment">// 交换机</span></span><br><span class="line">        <span class="comment">// return new directExchange(&quot;hmall.direct&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(<span class="string">&quot;hmall.direct&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue1</span><span class="params">()</span> &#123; <span class="comment">// 队列1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;direct.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">directQueue2</span><span class="params">()</span> &#123; <span class="comment">// 队列2</span></span><br><span class="line">        <span class="keyword">return</span> QueueBuilder</span><br><span class="line">                .durable(<span class="string">&quot;direct.queue2&quot;</span>) <span class="comment">// 队列持久化到磁盘</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">directQueue1Binding</span><span class="params">(Queue directQueue1, DirectExchange directExchange)</span> &#123; <span class="comment">// 绑定关系1</span></span><br><span class="line">        <span class="comment">// 把队列绑定到交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(directQueue1) <span class="comment">// 队列</span></span><br><span class="line">                .to(directExchange) <span class="comment">// 交换机</span></span><br><span class="line">                .with(<span class="string">&quot;blue&quot;</span>); <span class="comment">// 绑定关系（但是只能传一个key，如果需要绑定多个routingKey需要再写一个绑定关系）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">directQueue2Binding</span><span class="params">(Queue directQueue2, DirectExchange directExchange)</span> &#123; <span class="comment">// 绑定关系2</span></span><br><span class="line">        <span class="comment">// 把队列绑定到交换机</span></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder</span><br><span class="line">                .bind(directQueue2) <span class="comment">// 队列</span></span><br><span class="line">                .to(directExchange) <span class="comment">// 交换机</span></span><br><span class="line">                .with(<span class="string">&quot;yellow&quot;</span>); <span class="comment">// 绑定关系（但是只能传一个key）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于注解的方式声明"><a href="#基于注解的方式声明" class="headerlink" title="基于注解的方式声明"></a>基于注解的方式声明</h3><p>使用<code>@RabbitListener</code>注解来声明队列和交换机</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;direct.queue1&quot;, durable = &quot;true&quot;), // 队列</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT), // 交换机</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;red&quot;, &quot;blue&quot;&#125; // 绑定关系</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;consumer 1: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(name = &quot;direct.queue2&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">            key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;consumer 2: &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h2><p>【场景】：向object.queue队列发送一个对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendObject</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; msg = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        msg.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;xiaolin&quot;</span>);</span><br><span class="line">        msg.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;object.queue&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制台上看到的是：<br><img src="/assets/5aad7ced954b4a119d1de1a78585dfab.png" alt="5aad7ced954b4a119d1de1a78585dfab.png"><br>【原因】：Spring对消息对象的处理是由MessageConverter来处理的，而默认实现是SimpleMessageConverter，基于JDK的ObjectOutputStream完成序列化。<br>【这种方式存在的问题】：JDK的序列化有安全风险，JDK序列化的消息太大，JDK序列化的消息可读性太差<br>【解决】：建议采用JSON序列化代替默认的JDK序列化。</p><ol><li>在publisher和consumer中，引入jackson依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jackson消息转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在publisher和consumer中，配置MessageConverter</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(RabbitTemplate.class)</span> <span class="comment">// 有RabbitTemplate才生效</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/359d3cb0ff0f413f8fdf65a278ba6712.png" alt="359d3cb0ff0f413f8fdf65a278ba6712.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> 同步异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网关 + Nacos配置管理</title>
      <link href="/post/e0cedcb.html"/>
      <url>/post/e0cedcb.html</url>
      
        <content type="html"><![CDATA[<h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>网关：就是网络的关口，负责请求的路由、转发、身份校验。<br><img src="/assets/09f95626ddea400b8bacdab65fafb1d6.png" alt="09f95626ddea400b8bacdab65fafb1d6.png"></p><h2 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h2><ol><li>新建网关模块gateway</li><li>引入相关依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>写启动类</li><li>配置路由规则</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 前端请求的端口（网关的端口）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="comment"># 路由配置</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item-service</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span> <span class="comment"># 路由目标微服务，lb代表负载均衡协议</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断请求是否符合要求，符合则路由到目标</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,</span> <span class="string">/search/**</span> <span class="comment"># 以请求路径做判断，以/items或/search开头则符合</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/addresses/**,</span> <span class="string">/users/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br></pre></td></tr></table></figure><h2 id="路由属性"><a href="#路由属性" class="headerlink" title="路由属性"></a>路由属性</h2><p>网关路由对应的Java类型是RouteDefinition，常见的属性有：</p><ul><li>id：路由唯一标识</li><li>uri：路由目标地址</li><li>predicates：路由断言，判断请求是否符合当前路由</li><li>filters：路由过滤器，对请求或响应做特殊处理</li></ul><h3 id="predicates路由断言"><a href="#predicates路由断言" class="headerlink" title="predicates路由断言"></a>predicates路由断言</h3><p>文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.8/reference/html/#gateway-request-predicates-factories">predicates路由断言</a><br><img src="/assets/a06fc78dc06f4ad893c48b690b57ee9b.png" alt="a06fc78dc06f4ad893c48b690b57ee9b.png"></p><h3 id="filters路由过滤器"><a href="#filters路由过滤器" class="headerlink" title="filters路由过滤器"></a>filters路由过滤器</h3><p>文档：<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.8/reference/html/#gatewayfilter-factories">filters路由过滤器</a><br><img src="/assets/818227d547a6437d99c043f307fe15b8.png" alt="818227d547a6437d99c043f307fe15b8.png"></p><h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><p>网关过滤器有两种：</p><ol><li>GatewayFilter：路由过滤器，作用于任意指定的路由，默认不生效，要陪知道路由后生效。</li><li>GlobalFilter（常用）：全局过滤器，作用范围是所有路由；声明后自动生效。<br><img src="/assets/de4bb87f30e944a78554a8dba6730a8b.png" alt="de4bb87f30e944a78554a8dba6730a8b.png"></li></ol><h3 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取请求</span></span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> exchange.getRequest().getHeaders();</span><br><span class="line">        <span class="comment">// 过滤器业务处理（登录校验逻辑...）</span></span><br><span class="line">        <span class="keyword">if</span>(...) &#123;</span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">            <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange); <span class="comment">// 放行</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 控制过滤器执行顺序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 值越小，优先级越高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自定义的过滤器需要在NettyRoutingFilter【将请求转发到微服务】这个过滤器之前执行，所以需要再继承一个Ordered接口，来保证我们自定义的过滤器的优先级比NettyRoutingFilter高</p></blockquote><h2 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h2><p><img src="/assets/1a7472fcc3034feeb999d6699a88b4af.png" alt="1a7472fcc3034feeb999d6699a88b4af.png"></p><h3 id="网关传递用户"><a href="#网关传递用户" class="headerlink" title="网关传递用户"></a>网关传递用户</h3><p><img src="/assets/0fcac58bbf304ed0afa42dfc94e8320d.png" alt="0fcac58bbf304ed0afa42dfc94e8320d.png"></p><ol><li>在网关的登录校验过滤器中，从前端发送的请求头里拿到用户信息，并把用户信息放到请求头里，再发给微服务。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">swe</span> <span class="operator">=</span> exchange.mutate()</span><br><span class="line">                .request(builder -&gt; builder.header(<span class="string">&quot;user-info&quot;</span>, userInfo))</span><br><span class="line">                .build(); <span class="comment">// 传递的时候，需要传递这个返回的新的exchange</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在微服务中定义拦截器，保存网关发过来的用户信息到ThreadLocal里。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义拦截器</span></span><br><span class="line"><span class="comment">// 因为校验请求头这些操作已经在网关做过了，所以拦截器里边只需要把用户信息保存到ThreadLocal里即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否获取了用户信息</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            <span class="comment">// 存入上下文</span></span><br><span class="line">            UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 清理用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册拦截器</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DispatcherServlet.class：springmvc的核心api</span></span><br><span class="line"><span class="comment"> * 防止网关【没有SpringMvc】也引用这个类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span> <span class="comment">// 条件注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于很多微服务，都需要获取用户信息，不可能在这么多微服务里都一个拦截器，太麻烦啦。所以就把拦截器的代码写在common公共模块。<br>【<code>问题</code>】：配置类想要生效，需要被Spring扫描包扫描到，但是现在mvc配置类是在common公共模块下，但是是其他微服务使用这个拦截器，无法扫描到这个配置类。<br>【<code>解决</code>】：利用SpringBoot自动装配的原理，将定义的配置类放在了META-INF下的spring.factories文件下，这样就能实现自动装</p></blockquote><h3 id="OpenFeign传递用户信息"><a href="#OpenFeign传递用户信息" class="headerlink" title="OpenFeign传递用户信息"></a>OpenFeign传递用户信息</h3><p><img src="/assets/6116a9309a3e42ea8b5ede7ca200c0b9.png" alt="6116a9309a3e42ea8b5ede7ca200c0b9.png"><br>【<code>分析</code>】：购物车服务中的请求，不是直接从网关发过来的，而是网关先发给交易服务，再由交易服务通过OpenFeign向购物车服务中发送请求【微服务之间的调用】。<br>【<code>解决</code>】：OpenFeign提供了一个拦截器接口，所有由OpenFeign发起的请求都会先调用拦截器处理请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line"><span class="comment">// 交易服务可以拿到用户信息，它向购物车发请求时，UserContext里会保存用户信息</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line"><span class="keyword">if</span> (userId != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 把用户信息放到请求头中</span></span><br><span class="line">template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString()); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：DefaultFeignConfig配置类想要生效，必须在<code>发起请求所在的服务</code>（交易服务）的启动类上添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</span></span><br></pre></td></tr></table></figure><hr><hr><h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><p>【<code>存在问题</code>】：</p><ol><li>微服务重复配置过多，维护成本高。</li><li>业务配置经常变动，每次修改都要重启服务</li><li>网关路由配置写死，如果变更都要重启网关<br><img src="/assets/3fe9b4ff6f6b407084bb0d74d8ee4ee5.png" alt="3fe9b4ff6f6b407084bb0d74d8ee4ee5.png"></li></ol><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><h3 id="1-添加共享配置"><a href="#1-添加共享配置" class="headerlink" title="1. 添加共享配置"></a>1. 添加共享配置</h3><p><img src="/assets/94b4df1cef85413fbe42a5be8e80a932.png" alt="94b4df1cef85413fbe42a5be8e80a932.png"></p><h3 id="2-拉取共享配置"><a href="#2-拉取共享配置" class="headerlink" title="2. 拉取共享配置"></a>2. 拉取共享配置</h3><p>基于NacosConfig拉取共享配置代替微服务的本地配置<br><img src="/assets/946301ba738e46fc9ad04a7fee35a511.png" alt="946301ba738e46fc9ad04a7fee35a511.png"></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.新建bootstrap.yaml文件</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 微服务的名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-jdbc.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-log.yaml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">data-id:</span> <span class="string">shared-swagger.yaml</span></span><br></pre></td></tr></table></figure><p><img src="/assets/4a766faffbb94956a64d70f84bc562db.png" alt="4a766faffbb94956a64d70f84bc562db.png"></p><blockquote><p>先加载bootstrap配置文件，拉取nacos配置，再进行合并。</p></blockquote><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>当修改配置文件中的配置时，微服务<strong>无需重启</strong>即可使配置生效。<br>【<code>条件</code>】：</p><ol><li>nacos中要有一个与微服务名有关的配置文件。<br><img src="/assets/617202b295ac4f2ab1684dcb20ee19c1.png" alt="617202b295ac4f2ab1684dcb20ee19c1.png"></li><li>微服务中要以特定方式读取需要热更新的配置属性。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxItems;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对应nacos中的配置：<br><img src="/assets/3bdd6371c4894edc9886796dd8e3016f.png" alt="3bdd6371c4894edc9886796dd8e3016f.png"></p></blockquote><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>要实现动态路由首先要将路由配置保存到nacos中，当nacos中路由配置变更时，推送最新配置到网关，更新网关中的路由信息。</p><ol><li>拉取配置并添加监听器</li><li>在<code>路由表里的内容变更</code>和<code>项目启动</code>时，更新路由表</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 保存旧的路由表</span></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// 在项目一启动的时候执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1. 项目启动，先拉取配置，并添加配置监听器</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123; <span class="comment">// 定义线程池</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123; <span class="comment">// 配置变更时做的事</span></span><br><span class="line">                        <span class="comment">// 2. 监听到配置变更时，需要去更新路由表</span></span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 3. 第一次读取到配置，也需要更新路由表</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新路由表【利用RouteDefinitionWriter来更新路由表】</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123; <span class="comment">// configInfo就是配置文件的内容</span></span><br><span class="line">        <span class="comment">// 1. 解析配置文件，转为RouteDefinition</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routes = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2. 更新路由表</span></span><br><span class="line">        <span class="comment">// 【删】删除旧的路由表</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空旧的路由表</span></span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="keyword">for</span> (RouteDefinition route : routes) &#123;</span><br><span class="line">            <span class="comment">// 【增】新增新的路由表</span></span><br><span class="line">            writer.save(Mono.just(route)).subscribe();</span><br><span class="line">            <span class="comment">// 记录路由id，便于下次更新时删除</span></span><br><span class="line">            routeIds.add(route.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在nacos中添加动态路由<br><img src="/assets/f8daa3c9a9f644c9a93bcca2e3a3a4c1.png" alt="f8daa3c9a9f644c9a93bcca2e3a3a4c1.png"></li></ol><blockquote><p>【注】：为了方便解析从nacos读取到的路由配置，推荐使用json格式的路由配置。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> nacos </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel服务保护 + Seata分布式事务</title>
      <link href="/post/83df4a98.html"/>
      <url>/post/83df4a98.html</url>
      
        <content type="html"><![CDATA[<h1 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h1><p><img src="/assets/2cc9cca2bb6c4b8fba768d0a1e1a3374.png" alt="2cc9cca2bb6c4b8fba768d0a1e1a3374.png"><br>【<code>原因</code>】：</p><ol><li>微服务相互调用，服务提供者出现故障。</li><li>服务调用这没有做好异常处理，导致自身故障。</li><li>调用链中所有服务级联失败，导致整个集群故障。</li></ol><p>【<code>解决方案</code>】：<br>请求限流、线程隔离、服务熔断<br>【<code>服务保护技术</code>】：<br><img src="/assets/54aa0a3b19124b8d8e17aa6a80f7381d.png" alt="54aa0a3b19124b8d8e17aa6a80f7381d.png"></p><h1 id="Sentinel服务保护"><a href="#Sentinel服务保护" class="headerlink" title="Sentinel服务保护"></a>Sentinel服务保护</h1><p>官方文档：<a href="https://sentinelguard.io/zh-cn/docs/quick-start.html">Sentinel</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-使用docker部署sentinel"><a href="#1-使用docker部署sentinel" class="headerlink" title="1. 使用docker部署sentinel"></a>1. 使用docker部署sentinel</h3><p>创建并运行sentinel容器：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--net=host \</span><br><span class="line">--name sentinel \</span><br><span class="line">--restart=always \</span><br><span class="line">-e AUTH_USERNAME=admin \</span><br><span class="line">-e AUTH_PASSWORD=admin \</span><br><span class="line">bladex/sentinel-dashboard:1.8.6</span><br></pre></td></tr></table></figure><p>完成后在浏览器输入：<code>192.168.140.101:8858</code>，用户名admin，密码admin</p><h3 id="2-在微服务中连接sentinel控制台"><a href="#2-在微服务中连接sentinel控制台" class="headerlink" title="2.在微服务中连接sentinel控制台"></a>2.在微服务中连接sentinel控制台</h3><p>引入sentinel依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置控制台：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8858</span> <span class="comment"># sentinel的控制台地址</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><blockquote><p>Restful风格的API请求路径一般相同，会导致簇点资源名称重复。所以我们要修改配置，把<code>请求方式 + 请求路径</code>作为簇点资源名称</p></blockquote><h2 id="簇点链路"><a href="#簇点链路" class="headerlink" title="簇点链路"></a>簇点链路</h2><p>簇点链路就是单机调用链路，是一次请求进入服务后经过的每一个被Sentinel监控的资源链。默认Sentinel会监控SpringMVC的每一个Endpoint（Http接口）。限流、熔断等都是争对簇点链路中的资源设置的，资源名默认就是接口的请求路径。<br><img src="/assets/73c5da38241d45dc9ecb894066f1aafd.png" alt="73c5da38241d45dc9ecb894066f1aafd.png"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-请求限流"><a href="#1-请求限流" class="headerlink" title="1. 请求限流"></a>1. 请求限流</h3><p>限制访问微服务的请求的并发量，避免服务因流量激增而出现故障。<br><img src="/assets/7257b09894a64584991f2caa12ce5723.png" alt="7257b09894a64584991f2caa12ce5723.png"><br><img src="/assets/8e0ebcb4bc544398a62f2bc43cb3671e.png" alt="8e0ebcb4bc544398a62f2bc43cb3671e.png"><br>这个接口每秒钟只能处理6个请求，使用ApiFox进行测试，会有部分请求失败【失败返回状态码429】。<br><img src="/assets/8d05ad4b973d4911a59e0db815072b13.png" alt="8d05ad4b973d4911a59e0db815072b13.png"></p><h3 id="2-线程隔离"><a href="#2-线程隔离" class="headerlink" title="2. 线程隔离"></a>2. 线程隔离</h3><p>通过限定每个业务能使用的线程数量而将故障业务隔离，避免故障扩散。<br><img src="/assets/66f03b62c56a46b28426749b0bbfa7e5.png" alt="66f03b62c56a46b28426749b0bbfa7e5.png"><br>【<code>场景</code>】：假设有大量的查询购物车的请求，通过对查询购物车这个线程做线程隔离，可以保证购物车这个微服务的资源不会被耗尽，不会对修改购物车等其他业务造成影响。<br><img src="/assets/65421a69176f41f280895281be0cbaa0.png" alt="65421a69176f41f280895281be0cbaa0.png"><br><img src="/assets/dc7dfeb1f5f2434fbacab1b1188ac1e2.png" alt="dc7dfeb1f5f2434fbacab1b1188ac1e2.png"></p><blockquote><p>线程隔离和请求限流的区别：<br><strong>请求限流</strong>：控制接受请求的<code>速度</code>(每秒访问几次)<br><strong>线程隔离</strong>：控制最多能接收请求的<code>次数</code>(一次访问的线程数)<br>就算请求限流设置的再慢，如果线程卡住的话，不设置线程隔离，也会导致资源占用。</p></blockquote><h3 id="3-fallback"><a href="#3-fallback" class="headerlink" title="3. fallback"></a>3. fallback</h3><p><img src="/assets/919d0bc52c674d66b761d79030ed1ba0.png" alt="919d0bc52c674d66b761d79030ed1ba0.png"><br>一、 将FeignClient作为Sentinel的簇点资源：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启流量控制</span></span><br></pre></td></tr></table></figure><p>二、 为FeignClient添加Fallback：</p><ul><li>方法1：FallbackClass，无法对远程调用的异常做处理</li><li>方法2：<code>FallbackFactory</code>，可以对远程调用的异常做处理</li></ul><ol><li>自定义类，实现FallbackFactory，编写对某个FeignClient的fallback逻辑：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">    <span class="comment">// 编写失败的处理逻辑（失败后就会走里边的方法）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;查询商品失败，&quot;</span>+ cause);</span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;扣减商品库存失败，&quot;</span>+ cause);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将定义的FallbackFactory注册为一个Bean：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ItemClientFallbackFactory <span class="title function_">itemClientFallbackFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClientFallbackFactory</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在ItemClient接口中使用FallbackFactory：<code>@FeignClient(value = &quot;item-service&quot;, fallbackFactory = ItemClientFallbackFactory.class)</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, fallbackFactory = ItemClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; items)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/assets/dd48672f97c8470ba4eaccb7e55fa40f.png" alt="dd48672f97c8470ba4eaccb7e55fa40f.png"></p><h3 id="4-服务熔断"><a href="#4-服务熔断" class="headerlink" title="4. 服务熔断"></a>4. 服务熔断</h3><p>由<strong>断路器</strong>统计请求的异常比例或慢调用比例，如果超出阈值则会熔断该业务，则拦截改接口的请求。熔断期间，所有请求<code>快速失败</code>，全部走fallback逻辑。当服务恢复时，断路器会放行访问该服务的请求。<br><img src="/assets/6fb72065d9ab449da726f4d8475717a0.png" alt="6fb72065d9ab449da726f4d8475717a0.png"></p><h4 id="断路器工作原理："><a href="#断路器工作原理：" class="headerlink" title="断路器工作原理："></a>断路器工作原理：</h4><p><img src="/assets/f7b1a34e18ef4ed58cf252b6cc209674.png" alt="f7b1a34e18ef4ed58cf252b6cc209674.png"><br>默认情况：<code>Closed状态</code><br>如果失败的比例过高：就会进入<code>Open状态</code>【拦截一切请求，快速失败】<br>在<code>Open状态</code>下会尝试放行一次请求，进入<code>Half-Open状态</code>，如果仍然失败，再次返回Open状态；如果成功，回到<code>Closed状态</code>。</p><h4 id="配置熔断策略"><a href="#配置熔断策略" class="headerlink" title="配置熔断策略"></a>配置熔断策略</h4><p><img src="/assets/c8573593d04c4081a9fd34a3ed557f64.png" alt="c8573593d04c4081a9fd34a3ed557f64.png"><br><img src="/assets/41c3633ff01d4c7686feca76ccec84cb.png" alt="41c3633ff01d4c7686feca76ccec84cb.png"></p><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>如果一个业务需要多个服务合作完成，而且每个服务都有事务，多个事务必须同时成功或同时失败，这样的事务就是<code>分布式事务</code>。其中每一个服务的事务就是一个<code>分支事务</code>。整个业务称为<code>全局事务</code>。<br>【<code>场景</code>】：用户下单后，订单服务首先创建订单，随后调用购物车服务清理购物车，最后调用库存服务扣减商品的库存。如果在调用库存服务的时候商品库存为0，此时扣减库存失败，订单服务和购物车服务应该同时失败。<br><img src="/assets/099e39d670064e3b8e9ba752153342da.png" alt="099e39d670064e3b8e9ba752153342da.png"><br>【<code>出现问题的原因</code>】：各个分支服务不知道对方的情况<br>【<code>解决思路</code>】：让各个分支事务感受到对方的存在，让所有的微服务向事务协调者报告当前的状态。<br><img src="/assets/b8c06f583e3f4ee9909a011fab1f7986.png" alt="b8c06f583e3f4ee9909a011fab1f7986.png"></p><h1 id="Seata架构"><a href="#Seata架构" class="headerlink" title="Seata架构"></a>Seata架构</h1><ul><li>事务协调者（TC）：维护<code>全局和分支事务</code>的状态，协调全局事务提交或回滚。</li><li>事务管理器（TM）：定义<code>全局事务</code>的范围、开始全局事务、提交或回滚全局事务。</li><li>资源管理器（RM）：管理<code>分支事务</code>，与TC交谈以注册分支事务和报告分支事务的状态。<br><img src="/assets/b497bbfe12194c6d8a2cb7cf88b41a47.png" alt="b497bbfe12194c6d8a2cb7cf88b41a47.png"></li></ul><h2 id="1-部署TC服务"><a href="#1-部署TC服务" class="headerlink" title="1. 部署TC服务"></a>1. 部署TC服务</h2><ol><li>创建数据库，导入sql文件<br><img src="/assets/150a14f4bbfb468bbd8d53777f85df86.png" alt="150a14f4bbfb468bbd8d53777f85df86.png"></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `seata`;</span><br><span class="line">USE `seata`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `global_table`</span><br><span class="line">(</span><br><span class="line">    `xid`                       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `transaction_id`            <span class="type">BIGINT</span>,</span><br><span class="line">    `status`                    TINYINT      <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `application_id`            <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_service_group` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_name`          <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `timeout`                   <span class="type">INT</span>,</span><br><span class="line">    `begin_time`                <span class="type">BIGINT</span>,</span><br><span class="line">    `application_data`          <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`                DATETIME,</span><br><span class="line">    `gmt_modified`              DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`xid`),</span><br><span class="line">    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),</span><br><span class="line">    KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `branch_table`</span><br><span class="line">(</span><br><span class="line">    `branch_id`         <span class="type">BIGINT</span>       <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `xid`               <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `transaction_id`    <span class="type">BIGINT</span>,</span><br><span class="line">    `resource_group_id` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `resource_id`       <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `branch_type`       <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    `status`            TINYINT,</span><br><span class="line">    `client_id`         <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    `application_data`  <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`        DATETIME(<span class="number">6</span>),</span><br><span class="line">    `gmt_modified`      DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`branch_id`),</span><br><span class="line">    KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `lock_table`</span><br><span class="line">(</span><br><span class="line">    `row_key`        <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `xid`            <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">    `branch_id`      <span class="type">BIGINT</span>       <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `resource_id`    <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `table_name`     <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `pk`             <span class="type">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    `status`         TINYINT      <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0:locked ,1:rollbacking&#x27;</span>,</span><br><span class="line">    `gmt_create`     DATETIME,</span><br><span class="line">    `gmt_modified`   DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY KEY</span> (`row_key`),</span><br><span class="line">    KEY `idx_status` (`status`),</span><br><span class="line">    KEY `idx_branch_id` (`branch_id`),</span><br><span class="line">    KEY `idx_xid_and_branch_id` (`xid` , `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `distributed_lock`</span><br><span class="line">(</span><br><span class="line">    `lock_key`       <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `lock_value`     <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">    `expire`         <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="keyword">primary key</span> (`lock_key`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;AsyncCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryRollbacking&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;TxTimeoutCheck&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>准备配置文件<br><a href="https://download.csdn.net/download/qq_57882997/90244761?spm=1001.2014.3001.5503">seata运行时所需的配置文件</a><br>上传前先看看application.yml，里边可能有些配置需要改一下<br>把上边的配置文件丢到root根目录下<br><img src="/assets/35c04cad63ca46c48c78793dc560ba46.png" alt="35c04cad63ca46c48c78793dc560ba46.png"></li><li>docker部署<br>在&#x2F;root目录下执行以下命令，创建并允许seata容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name seata \</span><br><span class="line">-p 8099:8099 \</span><br><span class="line">-p 7099:7099 \</span><br><span class="line">-e SEATA_IP=192.168.140.101 \</span><br><span class="line">-v ./seata:/seata-server/resources \</span><br><span class="line">--privileged=true \</span><br><span class="line">--network hm-net \</span><br><span class="line">--restart=always \</span><br><span class="line">-d \</span><br><span class="line">seataio/seata-server:1.5.2</span><br></pre></td></tr></table></figure><ol start="4"><li>以上操作都完成后，在浏览器输入：<code>http://192.168.140.101:7099/</code>后即可登录seata控制台。（初始账号：admin、密码：admin）</li></ol><h2 id="2-微服务集成Seata"><a href="#2-微服务集成Seata" class="headerlink" title="2. 微服务集成Seata"></a>2. 微服务集成Seata</h2><ol><li>引入Seata依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置TC服务地址，让微服务找到TC服务地址<br><img src="/assets/71f62f42519b4caba2fca5bcaa9c7a40.png" alt="71f62f42519b4caba2fca5bcaa9c7a40.png"></li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为很多服务都需要实现分布式事务，所以可以把对于seata的配置抽取成一个共享配置写在nacos里。所以添加依赖的时候，检查一下是否有<code>bootstrap</code>和<code>nacos配置管理</code>的依赖。</p></blockquote><p>查看seata的日志文件，可以看到购物车服务、交易服务、商品服务已经全部和seata的TC服务建立连接。<br><img src="/assets/ade0cde731924dbeb93ce0272718895b.png" alt="ade0cde731924dbeb93ce0272718895b.png"></p><h2 id="3-Seata解决分布式事务问题"><a href="#3-Seata解决分布式事务问题" class="headerlink" title="3. Seata解决分布式事务问题"></a>3. Seata解决分布式事务问题</h2><h3 id="XA模式—强一致"><a href="#XA模式—强一致" class="headerlink" title="XA模式—强一致"></a>XA模式—强一致</h3><p><img src="/assets/89a4a66e8aac422c9f909bf4d6437f0f.png" alt="89a4a66e8aac422c9f909bf4d6437f0f.png"></p><ol><li>一阶段工作：</li></ol><ul><li>RM注册分支事务</li><li>RM执行分支事务sql<code>但不提交</code></li><li>RM报告执行状态到TC</li></ul><ol start="2"><li>二阶段工作：</li></ol><ul><li>TC检测各分支事务执行状态：<ul><li>如果都成功，通知所有RM<code>提交事务</code></li><li>如果有失败，通知所有RM<code>回滚事务</code></li></ul></li><li>RM接收到TC指令，提交或回滚事务</li></ul><blockquote><p>通过“等待”的方式，确保了全局事务的ACID特性。但是一阶段需要锁定数据库的资源，到二阶段才释放，性能差。</p></blockquote><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>修改（每个参与事务的微服务）application.yml文件，开启XA模式</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><ol start="2"><li>给发起全局事务的入口添加<code>@GlobalTransactional</code>注解<br><img src="/assets/40c708a8b87143399bacde7aa1b077dd.png" alt="40c708a8b87143399bacde7aa1b077dd.png"></li></ol><h3 id="AT模式（主推）—最终一致"><a href="#AT模式（主推）—最终一致" class="headerlink" title="AT模式（主推）—最终一致"></a>AT模式（主推）—最终一致</h3><p>AT模式弥补了XA模式中资源锁定周期过长的缺陷。<br><img src="/assets/984ee6e1df964b379ff0c9524daa0d63.png" alt="984ee6e1df964b379ff0c9524daa0d63.png"></p><ol><li>一阶段RM的工作：</li></ol><ul><li>注册分支事务</li><li>记录<code>undo-log</code>（数据快照）</li><li>执行业务sql<code>并提交</code></li><li>报告事务状态</li></ul><ol start="2"><li>二阶段提交时RM的工作：</li></ol><ul><li>删除undo-log即可</li></ul><ol start="3"><li>二阶段回滚时RM的工作：</li></ol><ul><li>根据undo-log恢复数据到更新前</li></ul><blockquote><p>AT模式相比于XA模式的优点在于：在一阶段不需要等待彼此执行，而是各自提交，这样资源就没有锁定，性能也会好。<br>但是如果二阶段需要进行回滚，在回滚之前，会出现数据短暂的不一致。<br>【<code>AT模式与XA模式的区别</code>】：</p><ol><li>XA模式一阶段不提交事务，锁定资源<br>  AT模式一阶段直接提交，不锁定资源</li><li>XA模式依赖数据库机制实现回滚<br>  AT模式利用数据快照实现回滚</li><li>XA模式强一致<br>  AT模型最终一致</li></ol></blockquote><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li>创建数据表，导入用来记录数据快照的undo_log表<br>【<code>注</code>】：每个分支事务都需要有自己的undo_log表</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `undo_log`</span><br><span class="line">(</span><br><span class="line">    `branch_id`     <span class="type">BIGINT</span>       <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    `xid`           <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    `context`       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    `rollback_info` LONGBLOB     <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    `log_status`    <span class="type">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    `log_created`   DATETIME(<span class="number">6</span>)  <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    `log_modified`  DATETIME(<span class="number">6</span>)  <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span><span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改application.yml文件，将事务模式修改为AT模式</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span></span><br></pre></td></tr></table></figure><p><img src="/assets/b5011655c47246f49d5f0770c77002ba.png" alt="b5011655c47246f49d5f0770c77002ba.png"><br>数据快照（undo_log表）：<br><img src="/assets/09abfcb768a64fefa0d1397b8ce4e5f9.png" alt="09abfcb768a64fefa0d1397b8ce4e5f9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> sentinel </tag>
            
            <tag> 服务保护 </tag>
            
            <tag> seata </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos注册中心 + OpenFeign远程调用</title>
      <link href="/post/61626915.html"/>
      <url>/post/61626915.html</url>
      
        <content type="html"><![CDATA[<h1 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h1><h2 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h2><p>服务提供者：暴露服务接口，供其他服务调用<br>服务调用者：调用别的服务提供的接口<br>注册中心：记录并监控微服务各实例状态，推送服务变更信息<br><img src="/assets/16c60d1c84d945988f8bcc8394929317.png" alt="16c60d1c84d945988f8bcc8394929317.png"></p><blockquote><ol><li><strong>服务提供者</strong>会在启动时注册自己的信息到<strong>注册中心</strong>，<strong>消费者</strong>可以从<strong>注册中心</strong>订阅和拉取服务信息</li><li><strong>服务提供者</strong>通过<strong>心跳机制</strong>向<strong>注册中心</strong>报告自己的健康状态，当心跳异常时，注册中心会将异常服务剔除，并通知订阅了该服务的<strong>消费者</strong>。</li><li><strong>消费者</strong>可以通过<strong>负载均衡算法</strong>，从多个实例中选择一个。</li></ol></blockquote><h2 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h2><ol><li>先导入nacos表<br><img src="/assets/76b42e46dee24390b2ae2119c4591545.png" alt="76b42e46dee24390b2ae2119c4591545.png"></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导出 nacos 的数据库结构</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `nacos`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `nacos` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line">USE `nacos`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_aggr 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_aggr`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_aggr 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_aggr`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_beta 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_beta`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_beta 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_beta`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_tag 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_tag`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_tag 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_tag`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_tags_relation 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_tags_relation`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_tags_relation 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_tags_relation`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.group_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `group_capacity`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.group_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `group_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.his_config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `his_config_info`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.his_config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `his_config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.permissions 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `permissions`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `permissions` (</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.permissions 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `permissions`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.roles 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `roles`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `roles` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_user_role` (`username`,`role`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.roles 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `roles`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `roles` (`username`, `role`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_capacity`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_info`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span> <span class="keyword">NOT NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.users 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `users`;</span><br><span class="line"><span class="keyword">CREATE TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT NULL</span>,</span><br><span class="line">  `enabled` tinyint(<span class="number">1</span>) <span class="keyword">NOT NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span> (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.users 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `users`;</span><br><span class="line"><span class="keyword">INSERT INTO</span> `users` (`username`, `password`, `enabled`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>把custom.env文件丢到服务器上。<br><img src="/assets/f3a559af7165417b9dd8707f1ad9b7d4.png" alt="f3a559af7165417b9dd8707f1ad9b7d4.png"></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PREFER_HOST_MODE=hostname</span><br><span class="line">MODE=standalone</span><br><span class="line">SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">MYSQL_SERVICE_HOST=192.168.140.101</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">MYSQL_SERVICE_PORT=3307</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=123</span><br><span class="line">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><ol start="3"><li>创建并启动nacos容器</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nacos \</span><br><span class="line">--env-file ./nacos/custom.env \</span><br><span class="line">--network hm-net \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">-p 9848:9848 \</span><br><span class="line">-p 9849:9849 \</span><br><span class="line">--restart=always \</span><br><span class="line">nacos/nacos-server:v2.1.0-slim</span><br></pre></td></tr></table></figure><blockquote><p>配置成功后，在浏览器里输入：<code>http://192.168.140.101:8848/nacos</code>，即可看到nacos操作界面。<br>用户名：nacos、密码：nacos</p><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h2></blockquote><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p><strong>服务注册</strong>：<strong>服务提供者</strong>在启动时提交自己的信息到注册中心。</p><ol><li>引用nacos依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置nacos地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><p>如果服务提供者配置在两台服务器上（这里用不同端口来演示），直接启动后，注册中心就能看到这两个服务。<br><img src="/assets/3b0e281c97ee47d2bae1df707e0217cc.png" alt="3b0e281c97ee47d2bae1df707e0217cc.png"></p><blockquote><p>假如有一台服务器宕机了，注册中心会感知到这台服务器宕机，并将它从注册中心删除。</p></blockquote><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><strong>服务发现</strong>：<strong>服务调用者</strong>调用别的服务，需要去注册中心里拉取别的服务。</p><ol><li>引用nacos依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置nacos地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.140</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><ol start="3"><li>服务发现</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 根据服务名称，获取服务的实例列表</span></span><br><span class="line"> List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>); <span class="comment">// 实例列表</span></span><br><span class="line"> <span class="keyword">if</span>(CollUtils.isEmpty(instances))&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 2. 手写负载均衡，从实例列表中随机挑选一个实例</span></span><br><span class="line"> <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> instances.get(RandomUtil.randomInt(<span class="number">0</span>, instances.size()));</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 3.使用RestTemplate发起远程调用（暂时先这样，实际上用的是OpenFeign）</span></span><br><span class="line"> ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">         instance.getUri()+ <span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">         HttpMethod.GET,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">         &#125;, <span class="comment">// 泛型的引用</span></span><br><span class="line">         Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line"> );</span><br><span class="line"> <span class="comment">// 解析响应</span></span><br><span class="line"> <span class="keyword">if</span>(!response.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;ItemDTO&gt; items = response.getBody();</span><br></pre></td></tr></table></figure><h1 id="OpenFeign远程调用"><a href="#OpenFeign远程调用" class="headerlink" title="OpenFeign远程调用"></a>OpenFeign远程调用</h1><p>声明式的http客户端，帮助我们优雅的实现http请求的发送。<br><strong>旧</strong>：使用RestTemplate发送http请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">        instance.getUri()+ <span class="string">&quot;/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">        HttpMethod.GET,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">        &#125;, <span class="comment">// 泛型的引用</span></span><br><span class="line">        Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line">);</span><br><span class="line">List&lt;ItemDTO&gt; items = response.getBody();</span><br></pre></td></tr></table></figure><p><strong>新</strong>：OpenFeign</p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>启用OpenFeign功能：在启动类上加入@EnableFeignClients注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写FeignClient</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;)</span> <span class="comment">// 告诉OpenFeign，这个是一个客户端[OpenFeign就可以根据服务的名称去注册中心里拉取实例列表]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/items&quot;)</span> <span class="comment">// 请求方式、路径</span></span><br><span class="line">List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>; <span class="comment">// 请求参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用OpenFeign，实现远程调用</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(ids);</span><br></pre></td></tr></table></figure><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>OpenFeign底层发起http请求，依赖其他框架，这些框架可以自己配置，包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><blockquote><p>OpenFeign底层最终发送请求<strong>默认</strong>使用的是Client代理，每次都要重新创建连接，效率很低，所以需要<strong>连接池</strong>。</p></blockquote><h3 id="OpenFeign整合OKHttp"><a href="#OpenFeign整合OKHttp" class="headerlink" title="OpenFeign整合OKHttp"></a>OpenFeign整合OKHttp</h3><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>开启连接池功能</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><h2 id="最佳方案"><a href="#最佳方案" class="headerlink" title="最佳方案"></a>最佳方案</h2><p><strong>方法1.</strong><br><img src="/assets/b1cfbddd8b0a47278eeccaaff9e3ab99.png" alt="b1cfbddd8b0a47278eeccaaff9e3ab99.png"><br><strong>方法2.</strong><br><img src="/assets/b8232fab7d034370a8bdac8ba76df2cb.png" alt="b8232fab7d034370a8bdac8ba76df2cb.png"></p><blockquote><p>当定义的FeignClient不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。<strong>报错</strong>：<br><img src="/assets/763530fca0f74f368c78c96b489b18fe.png" alt="763530fca0f74f368c78c96b489b18fe.png"><br><strong>解决办法</strong>：</p><ol><li>指定FeignClient所在包：<br><code>@EnableFeignClients(basePackages = &quot;com.hmall.api.clients&quot;)</code></li><li>指定FeignClient字节码：<br><code>@EnableFeignClients(clients = &#123;UserClient.class&#125;)</code></li></ol></blockquote><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>OpenFeign只会在FeignClient所在包的日志级别为DEBUG时，才会输出日志。<br><img src="/assets/0e3e0b6fa77b48e68a17a90b68726b9f.png" alt="0e3e0b6fa77b48e68a17a90b68726b9f.png"></p><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><ul><li>NONE（默认值）：不记录任何日志信息</li><li>BASIC：请求的方法 + URL + 响应状态码 + 执行时间</li><li>HEADERS：BASIC + 请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细（头信息、请求体、元数据）</li></ul><h3 id="定义日志级别"><a href="#定义日志级别" class="headerlink" title="定义日志级别"></a>定义日志级别</h3><ol><li>声明一个类型为Logger.Level的Bean，在其中定义日志级别：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultFeignConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Logger.Level <span class="title function_">feignLogLevel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>此时这个Bean并未生效</li></ol><ul><li>如果想配置某个FeignClient的日志级别，可以在@FeignClient注解中声明<br><code>@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</code></li><li>如果想要全局配置，让所有的FeignClient都按照这个日志级别配置，需要在@EnableFeignClients注解中声明<br><code>@EnableFeignClients(basePackages = &quot;com.hmall.api.client&quot;, defaultConfiguration = DefaultFeignConfig.class)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> nacos </tag>
            
            <tag> openFeign </tag>
            
            <tag> 注册中心 </tag>
            
            <tag> 远程调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构</title>
      <link href="/post/e8b36ae1.html"/>
      <url>/post/e8b36ae1.html</url>
      
        <content type="html"><![CDATA[<h1 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h1><p>将<strong>业务的所有功能</strong>集中在一个项目中开发，打包成一个包部署。<br><img src="/assets/6f344e10fbcb4c8e9385198a5c2ed481.png" alt="6f344e10fbcb4c8e9385198a5c2ed481.png"><br><strong>优点</strong>：架构简单、部署成本低。<br><strong>缺点</strong>：团队协作成本高、系统发布效率低、系统可用性差。</p><blockquote><p>由于tomcat资源有限，同一个时间可能的并发量不大，如果有一个线程有大量的请求访问，其他的线程也会收到影响。</p></blockquote><h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p>微服务架构是服务化思想指导下的一套最佳实践架构方案。<strong>服务化思想</strong>：把单体架构中的功能模块拆分为多个独立的项目。<br><img src="/assets/a45478ce92d8493f804f65d3cb61de66.png" alt="a45478ce92d8493f804f65d3cb61de66.png"></p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><p>是最广泛的微服务框架。<br><img src="/assets/2c49976ed225467f96da6b5dbe4fe874.png" alt="2c49976ed225467f96da6b5dbe4fe874.png"></p><h1 id="微服务拆分"><a href="#微服务拆分" class="headerlink" title="微服务拆分"></a>微服务拆分</h1><h2 id="拆分原则"><a href="#拆分原则" class="headerlink" title="拆分原则"></a>拆分原则</h2><ol><li>创业型项目：先采用单体项目快速开发，随着规模扩大，逐渐拆分。</li><li>确定的大型项目：资金充足，目标明确，可以直接选择微服务项目，避免后续拆分麻烦。</li></ol><blockquote><p>要做到：高内聚、低耦合。<br><strong>高内聚</strong>：每个微服务的职责单一，包含的业务关联度高、完整度高。<br><strong>低耦合</strong>：每个微服务的功能相对独立，尽量减少对其他服务的依赖。</p></blockquote><p>拆分方式：</p><ul><li><strong>横向拆分</strong>：抽取公共服务，提高复用性。</li><li><strong>纵向拆分</strong>：按照业务模块来拆分。</li></ul><h2 id="拆分服务"><a href="#拆分服务" class="headerlink" title="拆分服务"></a>拆分服务</h2><p>工程结构有两种：</p><ol><li>独立Project：一个Project下多个Project</li><li>Maven聚合：一个Project下多个module</li></ol><h1 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h1><p>购物车服务里需要用到商品服务里的接口，但是此时是这两个服务已经拆分了，所以需要购物车服务向商品服务发送请求【类似于前端页面向后端发请求】<br><img src="/assets/f8d891fc93dc49b1b0a24c2fd22aad96.png" alt="f8d891fc93dc49b1b0a24c2fd22aad96.png"></p><h2 id="方法1-RestTemplate"><a href="#方法1-RestTemplate" class="headerlink" title="方法1.RestTemplate"></a>方法1.RestTemplate</h2><p><img src="/assets/70b364c3b28c4956b5a785039d30df34.png" alt="70b364c3b28c4956b5a785039d30df34.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单体服务：</span></span><br><span class="line"><span class="comment">// List&lt;ItemDTO&gt; items = itemService.queryItemByIds(itemIds);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 微服务远程调用：</span></span><br><span class="line"><span class="comment">// 1. 利用restTemplate发起http请求，得到http响应</span></span><br><span class="line">ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">         <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,</span><br><span class="line">         HttpMethod.GET,</span><br><span class="line">         <span class="literal">null</span>,</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;</span><br><span class="line">         &#125;, <span class="comment">// 泛型的引用</span></span><br><span class="line">         Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))</span><br><span class="line"> );</span><br><span class="line"> <span class="comment">// 2.解析响应</span></span><br><span class="line"> <span class="keyword">if</span>(!response.getStatusCode().is2xxSuccessful())&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;ItemDTO&gt; items = response.getBody();</span><br></pre></td></tr></table></figure><blockquote><p><strong>存在的问题</strong>：服务的调用者，在写代码的时候，还不知道服务提供者的地址。例如：商品微服务那边部署在了多台服务器，写url时，就不知道怎么写了。<br><img src="/assets/2f37302c55054edb95b1d5380ac397e3.png" alt="2f37302c55054edb95b1d5380ac397e3.png"></p></blockquote><h2 id="方法2-注册中心"><a href="#方法2-注册中心" class="headerlink" title="方法2.注册中心"></a>方法2.注册中心</h2><p>通过注册中心进行服务治理，通过订阅服务和注册服务，实现服务之间的远程调用；再通过OpenFeign来发送http请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法2.使用nacos + openFeign</span></span><br><span class="line"><span class="comment">// 根据服务名称，获取服务的实例列表</span></span><br><span class="line"> List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">&quot;item-service&quot;</span>); <span class="comment">// 实例列表</span></span><br><span class="line"> <span class="keyword">if</span>(CollUtils.isEmpty(instances))&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br></pre></td></tr></table></figure><p>（详细操作看：<a href="https://blog.csdn.net/qq_57882997/article/details/144990202?spm=1001.2014.3001.5502">nacos注册中心 + OpenFeign远程调用</a>）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> springcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/post/f5f9fa9b.html"/>
      <url>/post/f5f9fa9b.html</url>
      
        <content type="html"><![CDATA[<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><h2 id="1-卸载已有的Docker"><a href="#1-卸载已有的Docker" class="headerlink" title="1. 卸载已有的Docker"></a>1. 卸载已有的Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-selinux </span><br></pre></td></tr></table></figure><h2 id="2-配置yum源"><a href="#2-配置yum源" class="headerlink" title="2. 配置yum源"></a>2. 配置yum源</h2><ol><li>安装yum工具</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><ol start="2"><li>配置yum源</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h2 id="几个常见的错误"><a href="#几个常见的错误" class="headerlink" title="几个常见的错误"></a>几个常见的错误</h2><ol><li>报错<br><img src="/assets/34a3e7528a934f21825bf1f8a34323d8.png" alt="34a3e7528a934f21825bf1f8a34323d8.png"><br>去<code>/etc/yum.repos.d/</code>路径下的配置文件里，看看是否有中文注释，删了中文注释就行了</li><li>报错<br><img src="/assets/e1a02af7f0aa4453a937726202221c4c.png" alt="e1a02af7f0aa4453a937726202221c4c.png"><br>把<a href="https://gitcode.com/open-source-toolkit/10c42/?utm_source=tools_gitcode&index=bottom&type=card&">资源文件</a>放到指定的路径（<code>/opt/centos/repodata/</code>）下就行了</li><li>安装docker时报错：<br><img src="/assets/6611d9b24eb243cbb3d07b54e6264c6b.png" alt="6611d9b24eb243cbb3d07b54e6264c6b.png"><br><strong>解决办法</strong>：安装docker-ce-selinux</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure><h2 id="4-启动和校验"><a href="#4-启动和校验" class="headerlink" title="4. 启动和校验"></a>4. 启动和校验</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动Docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"># 停止Docker</span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"># 设置开机自启</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 执行docker ps命令，如果不报错，说明安装启动成功</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h2 id="5-配置镜像加速"><a href="#5-配置镜像加速" class="headerlink" title="5. 配置镜像加速"></a>5. 配置镜像加速</h2><ol><li>打开<a href="https://www.aliyun.com/product/acr?spm=5176.28536895.nav-v2-dropdown-menu-0.d_main_2_0_2.6651586crapZkh">阿里云的容器镜像服务</a></li><li>点击管理控制台：<br><img src="/assets/e8410e441042494ab55665d37348a253.png" alt="e8410e441042494ab55665d37348a253.png"></li><li>按照步骤配置镜像加速器即可。<br><img src="/assets/2ae0900d88e241afa8e20eb46d605fe0.jpeg" alt="2ae0900d88e241afa8e20eb46d605fe0.jpeg"><br><img src="/assets/e2dda10e3182492b9bba6c80db438609.png" alt="e2dda10e3182492b9bba6c80db438609.png"><br><strong>原因</strong>：现在阿里云的镜像已经停用失效，导致网络无法访问。<br><strong>解决</strong>：可以修改配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://docker.1ms.run&quot;,</span><br><span class="line">        &quot;https://docker.1panel.live/&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新加载配置文件并重启docker：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h1 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h1><p>利用Docker安装应用时，Docker会自动搜索并下载<strong>镜像</strong>（<strong>image</strong>）。镜像包含了：应用本身、应用运行所需的环境、配置、系统函数库。Docker会在运行镜像时创建一个隔离环境，成为<strong>容器</strong>（<strong>container</strong>）<br><strong>镜像仓库</strong>：存储和管理镜像的平台。<br><strong>镜像帮助文档</strong>：<a href="https://hub.docker.com/">dockerHub</a></p><h1 id="部署Mysql"><a href="#部署Mysql" class="headerlink" title="部署Mysql"></a>部署Mysql</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  mysql:5.7.32</span><br></pre></td></tr></table></figure><ul><li>docker run：创建并运行一个容器</li><li>-d：让容器在后台运行</li><li>–name：给容器起名，必须唯一</li><li>-p：设置端口映射【宿主机 : 容器内】</li><li>-e：设置环境变量</li><li>–restart&#x3D;always：设置开机自启</li><li>mysql:5.7.32：指定运行的镜像名[镜像名]:[版本]（版本省略就默认是最新版）</li></ul><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><p><img src="/assets/b9244ef79a834c888e55732c87abae93.png" alt="b9244ef79a834c888e55732c87abae93.png"></p><blockquote><p><strong>docker run</strong>：创建并运行容器<br><strong>docker start</strong>：启动容器，但是不会创建容器<br><strong>docker exec -it 容器名 bash</strong>：进入容器内部</p></blockquote><h2 id="给docker-ps和docker-images命令取个别名"><a href="#给docker-ps和docker-images命令取个别名" class="headerlink" title="给docker ps和docker images命令取个别名"></a>给docker ps和docker images命令取个别名</h2><ol><li>进入.bashrc文件：<code>vim ~/.bashrc</code></li><li>起别名：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias dps=&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span><br><span class="line">alias dis=&#x27;docker images&#x27;</span><br></pre></td></tr></table></figure><ol start="3"><li>让修改的文件生效：<code>source ~/.bashrc</code></li></ol><h1 id="数据卷挂载"><a href="#数据卷挂载" class="headerlink" title="数据卷挂载"></a>数据卷挂载</h1><p><strong>数据卷（volume）</strong>是一个虚拟目录，是<strong>容器内目录</strong>和<strong>宿主机目录</strong>之间映射的桥梁。(是个<strong>双向映射</strong>)<br><img src="/assets/80dca7e55e50465584a5bed7fd485c55.png" alt="80dca7e55e50465584a5bed7fd485c55.png"><br><img src="/assets/2b47c6a8ab464ab9bf2787b665d2a36d.png" alt="2b47c6a8ab464ab9bf2787b665d2a36d.png"></p><blockquote><ol><li>在执行docker run命令，使用<code>-v 数据卷:容器内目录</code>，可以完成数据卷的挂载。</li><li>当创建容器时，如果挂载了数据卷，且数据卷不存在，会自动创建数据卷。</li></ol></blockquote><h1 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h1><blockquote><ol><li>在执行docker run命令，使用<code>-v 本地目录:容器内目录</code>，可以完成本地目录的挂载。</li><li>本地目录必须以 &#x2F; 或 .&#x2F; 开头，如果直接以名称开头，会被识别成数据卷而非本地目录。</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3307:3306 \</span><br><span class="line">  -v /root/mysql/data:/var/lib/mysql \</span><br><span class="line">  -v /root/mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  -v /root/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  --restart=always \</span><br><span class="line">  mysql:5.7.32</span><br></pre></td></tr></table></figure><h1 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h1><p>镜像包含了应用程序、程序运行的系统函数库、运行配置等文件的文件包。构建镜像的过程实际上就是把上述文件打包的过程。</p><h2 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h2><p><img src="/assets/46fd11e845e64b2cae8325cb6b53118e.png" alt="46fd11e845e64b2cae8325cb6b53118e.png"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile就是一个文本文件，其中包含一个个的指令，用指令来说明要执行什么操作来构建镜像。<br><img src="/assets/6e0455e392ae441384b8361d201a7680.png" alt="6e0455e392ae441384b8361d201a7680.png"></p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t myImage:1.0 .</span><br></pre></td></tr></table></figure><ul><li>-t：给镜像起名，格式：[镜像名]:[版本]（不指定版本默认为latest）</li><li>. ：指定Dockerfile所在目录，如果在当前目录就指定为“.”</li></ul><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>默认情况下，所有容器都是以bridge方式连接到Docker的一个虚拟网桥上。<br><img src="/assets/7602a42ae6804609bdfa2436d6f2d9ce.png" alt="7602a42ae6804609bdfa2436d6f2d9ce.png"></p><h2 id="Docker的网络操作命令"><a href="#Docker的网络操作命令" class="headerlink" title="Docker的网络操作命令"></a>Docker的网络操作命令</h2><p>加入自定义网络的容器才可以通过容器名互相访问。<br><img src="/assets/d01da4c991094d4b8f93ccfab81d5b03.png" alt="d01da4c991094d4b8f93ccfab81d5b03.png"></p><blockquote><p>把容器加入网络的两种方式：<br>先创建容器，再把容器加入网桥：<code>docker network connect 网络名 容器名</code><br>创建容器的同时把容器加入网桥：<code>docker run -d .... --network 网络名 ...</code></p></blockquote><h1 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h1><h2 id="后端部署"><a href="#后端部署" class="headerlink" title="后端部署"></a>后端部署</h2><ol><li>打包项目<br><img src="/assets/815202303137461c8e76def8f5579d1c.png" alt="815202303137461c8e76def8f5579d1c.png"></li><li>把打包好的<code>jar包</code>和<code>Dockerfile文件</code>一起丢到服务器上<br><img src="/assets/af5776419de44941aab52b5256069fa8.png" alt="af5776419de44941aab52b5256069fa8.png"></li><li>切换到&#x2F;root&#x2F;hm目录下，构建自定义镜像hm-java：<code>docker build -t hm-java:1.0 .</code><br><img src="/assets/87c818023be948d3b074c189292c8d8c.png" alt="87c818023be948d3b074c189292c8d8c.png"></li><li>创建并运行容器，同时把容器加入网桥：<code>docker run -d --name hm-java -p 8080:8080 --network lsh hm-java:1.0</code><br><img src="/assets/ec70f4a7666e4af3a3fec5e6cf8c877a.png" alt="ec70f4a7666e4af3a3fec5e6cf8c877a.png"></li></ol><h2 id="部署前端"><a href="#部署前端" class="headerlink" title="部署前端"></a>部署前端</h2><ol><li>准备好<code>静态资源</code>和<code>配置文件</code><br><img src="/assets/d7380915e3224e3090d4e97bced881bd.png" alt="d7380915e3224e3090d4e97bced881bd.png"></li><li>创建容器并挂载</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name nginx \</span><br><span class="line">-p 18080:18080 \</span><br><span class="line">-p 18081:18081 \</span><br><span class="line">-v /root/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">--network lsh \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>通过一个独立的<strong>docker-compose.yml</strong>模板文件（yaml格式）来定义一组相关联的应用容器，帮助我们实现多个关联的Docker容器的快速部署。<br><img src="/assets/d8c05b0d94c9419f8f1f6eeb80ee7726.png" alt="d8c05b0d94c9419f8f1f6eeb80ee7726.png"><br><img src="/assets/e158bb3d266d49e6ac949769a14fd4d5.png" alt="e158bb3d266d49e6ac949769a14fd4d5.png"><br><code>docker-compose.yml</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &quot;3.8&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql</span><br><span class="line">    container_name: mysql</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3306:3306&quot;</span><br><span class="line">    environment:</span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;./mysql/conf:/etc/mysql/conf.d&quot;</span><br><span class="line">      - &quot;./mysql/data:/var/lib/mysql&quot;</span><br><span class="line">      - &quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">  hmall:</span><br><span class="line">    build: </span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    container_name: hmall</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">    depends_on:</span><br><span class="line">      - mysql</span><br><span class="line">  nginx:</span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: nginx</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;18080:18080&quot;</span><br><span class="line">      - &quot;18081:18081&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span><br><span class="line">      - &quot;./nginx/html:/usr/share/nginx/html&quot;</span><br><span class="line">    depends_on:</span><br><span class="line">      - hmall</span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">networks:</span><br><span class="line">  hm-net:</span><br><span class="line">    name: hmall</span><br></pre></td></tr></table></figure><p>docker compose的命令格式：<br><img src="/assets/802e0738aabe48518c52f5ed8d674d65.png" alt="802e0738aabe48518c52f5ed8d674d65.png"></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 容器 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-Stream流</title>
      <link href="/post/50c7718b.html"/>
      <url>/post/50c7718b.html</url>
      
        <content type="html"><![CDATA[<p>stream流相当于一个流水线，一共可以分成三大类的方法。</p><ol><li>获取stream流</li><li>中间方法</li><li>终结方法（可以得到一个返回结果的）</li></ol><hr><h1 id="获取stream流"><a href="#获取stream流" class="headerlink" title="获取stream流"></a>获取stream流</h1><h2 id="单列集合获取Stream流"><a href="#单列集合获取Stream流" class="headerlink" title="单列集合获取Stream流"></a>单列集合获取Stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="comment">// 单列集合获取stream流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>);</span><br><span class="line">        <span class="comment">/*Stream&lt;String&gt; stream = list.stream(); // 获取到一条流水线，并把集合中的数据放到流水线上</span></span><br><span class="line"><span class="comment">        stream.forEach((x)-&gt; System.out.println(x));*/</span></span><br><span class="line">        list.stream().forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双列集合获取stream流"><a href="#双列集合获取stream流" class="headerlink" title="双列集合获取stream流"></a>双列集合获取stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        map.put(<span class="string">&quot;d&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 双列集合获取stream流</span></span><br><span class="line">        map.keySet().stream().forEach(x -&gt; System.out.println(x));</span><br><span class="line">        map.entrySet().stream().forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组获取stream流"><a href="#数组获取stream流" class="headerlink" title="数组获取stream流"></a>数组获取stream流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Arrays.stream(arr).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一堆零散的数据"><a href="#一堆零散的数据" class="headerlink" title="一堆零散的数据"></a>一堆零散的数据</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>流只能用一次，就算保存了流对象，后边也无法使用了。</p></blockquote><h1 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h1><h2 id="filter过滤"><a href="#filter过滤" class="headerlink" title="filter过滤"></a>filter过滤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(x -&gt; x.startsWith(<span class="string">&quot;张&quot;</span>)) <span class="comment">// 过滤姓名张开头的</span></span><br><span class="line">                .filter(x -&gt; x.length() == <span class="number">3</span>) <span class="comment">// 过滤长度为3的</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="skip跳过前n个"><a href="#skip跳过前n个" class="headerlink" title="skip跳过前n个"></a>skip跳过前n个</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .limit(<span class="number">2</span>) <span class="comment">// 获取前两[个]</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .skip(<span class="number">2</span>) <span class="comment">// 跳过前两个</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.stream()</span><br><span class="line">                .skip(<span class="number">3</span>)</span><br><span class="line">                .limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="distinct去除集合中重复的元素"><a href="#distinct去除集合中重复的元素" class="headerlink" title="distinct去除集合中重复的元素"></a>distinct去除集合中重复的元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;周芷若&quot;</span>,<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .distinct() <span class="comment">// 去重</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concat连接两个集合"><a href="#concat连接两个集合" class="headerlink" title="concat连接两个集合"></a>concat连接两个集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list1, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>);</span><br><span class="line">        ArrayList&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list2, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span> , <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        Stream.concat(list1.stream(), list2.stream()) <span class="comment">// 连接两个集合</span></span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map类型转换"><a href="#map类型转换" class="headerlink" title="map类型转换"></a>map类型转换</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌-1&quot;</span>, <span class="string">&quot;周芷若-2&quot;</span>, <span class="string">&quot;赵敏-3&quot;</span>, <span class="string">&quot;张三丰-4&quot;</span>, <span class="string">&quot;张翠山-5&quot;</span>, <span class="string">&quot;张良-6&quot;</span>, <span class="string">&quot;王二麻子-7&quot;</span>, <span class="string">&quot;谢广坤-8&quot;</span>);</span><br><span class="line">        list.stream()</span><br><span class="line">                .map(x -&gt; &#123; <span class="comment">// map方法执行完后，流上的数据就变成了整数</span></span><br><span class="line">                        String[] arr = x.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">                    &#125;)</span><br><span class="line">                .forEach(x -&gt; System.out.println(x)); <span class="comment">// 打印的是整数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flatMap将流中每个元素转成另一个流"><a href="#flatMap将流中每个元素转成另一个流" class="headerlink" title="flatMap将流中每个元素转成另一个流"></a>flatMap将流中每个元素转成另一个流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; familyNameList = Arrays.asList(<span class="string">&quot;赵&quot;</span>, <span class="string">&quot;钱&quot;</span>, <span class="string">&quot;孙&quot;</span>, <span class="string">&quot;李&quot;</span>);</span><br><span class="line">        List&lt;String&gt; boyNameList = Arrays.asList(<span class="string">&quot;男&quot;</span>, <span class="string">&quot;子&quot;</span>, <span class="string">&quot;孩&quot;</span>);</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; cartesianProductList = familyNameList.stream()</span><br><span class="line">                .flatMap(familyName -&gt; boyNameList.stream() <span class="comment">// 将流中每个元素转换成另一个流</span></span><br><span class="line">                                        .map(boyName -&gt; familyName + boyName))</span><br><span class="line">                .forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h1><h2 id="forEach遍历集合"><a href="#forEach遍历集合" class="headerlink" title="forEach遍历集合"></a>forEach遍历集合</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        list.stream().forEach(x-&gt;System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="count计算集合中的元素"><a href="#count计算集合中的元素" class="headerlink" title="count计算集合中的元素"></a>count计算集合中的元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="toArray收集流中的数据放到数组中"><a href="#toArray收集流中的数据放到数组中" class="headerlink" title="toArray收集流中的数据放到数组中"></a>toArray收集流中的数据放到数组中</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="comment">// 收集流中的数据，放到数组中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        Object[] arr1 = list.stream().toArray();</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        String[] arr2 = list.stream().toArray(n -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[n]);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="collect收集流中的数据，放到集合中（List、Set、Map）"><a href="#collect收集流中的数据，放到集合中（List、Set、Map）" class="headerlink" title="collect收集流中的数据，放到集合中（List、Set、Map）"></a>collect收集流中的数据，放到集合中（List、Set、Map）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="comment">// 收集流中的数据，放到集合中（List、Set、Map）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌-男-15&quot;</span>, <span class="string">&quot;周芷若-女-14&quot;</span>, <span class="string">&quot;赵敏-女-14&quot;</span>, <span class="string">&quot;张三丰-男-100&quot;</span>, <span class="string">&quot;张翠山-男-40&quot;</span>, <span class="string">&quot;张良-男-35&quot;</span>, <span class="string">&quot;王二麻子-男-37&quot;</span>, <span class="string">&quot;谢广坤-男-41&quot;</span>);</span><br><span class="line">        <span class="comment">// 收集所有的男性到List集合中</span></span><br><span class="line">        List&lt;String&gt; list1 = list.stream()</span><br><span class="line">                .filter(x -&gt; <span class="string">&quot;男&quot;</span>.equals(x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>])) <span class="comment">// 过滤所有男性</span></span><br><span class="line">                .collect(Collectors.toList());<span class="comment">// 创建一个ArrayList集合</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 收集所有的男性到Set集合中</span></span><br><span class="line">        Set&lt;String&gt; set1 = list.stream()</span><br><span class="line">                .filter(x -&gt; <span class="string">&quot;男&quot;</span>.equals(x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>])) <span class="comment">// 过滤所有男性</span></span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集Map集合(键不能重复，否则代码报错)</span></span><br><span class="line">        <span class="comment">// Key：姓名、Value：年龄</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * toMap(键的规则，值的规则)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        HashMap&lt;String, String&gt; mp1 = list.stream()</span><br><span class="line">                .filter(x -&gt; <span class="string">&quot;男&quot;</span>.equals(x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>])) <span class="comment">// 过滤所有男性</span></span><br><span class="line">                .collect(Collectors.toMap(x -&gt; x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">0</span>], <span class="comment">// 键的规则</span></span><br><span class="line">                        x -&gt; x.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]));<span class="comment">// 值的规则</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> stream </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-Thread</title>
      <link href="/post/d89ccce6.html"/>
      <url>/post/d89ccce6.html</url>
      
        <content type="html"><![CDATA[<h1 id="定义多线程的三种方式"><a href="#定义多线程的三种方式" class="headerlink" title="定义多线程的三种方式"></a>定义多线程的三种方式</h1><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个类继承自Thread</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 2.重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName()+<span class="string">&quot;run()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3.创建对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 4.启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口的方式"><a href="#实现Runnable接口的方式" class="headerlink" title="实现Runnable接口的方式"></a>实现Runnable接口的方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个类实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2.重写run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前线程对象</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;run()...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3.创建对象(表示多线程要执行的任务)</span></span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">mr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">mr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">        <span class="comment">// 4.创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr2);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用Callable接口和Future接口-可以获取多线程的结果"><a href="#利用Callable接口和Future接口-可以获取多线程的结果" class="headerlink" title="利用Callable接口和Future接口[可以获取多线程的结果]"></a>利用Callable接口和Future接口[可以获取多线程的结果]</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个MyCallable类实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123; <span class="comment">// Callable的泛型表示这个线程返回的结果</span></span><br><span class="line">    <span class="comment">//2.重写call方法，返回值表示多线程运行结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 3.创建MyCallable对象【表示多线程要执行的任务】</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">// 4.创建FutureTask对象【管理多线程运行的结果】</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">        <span class="comment">// 5.创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        <span class="comment">// 6.启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 获取线程的返回结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见的成员方法"><a href="#常见的成员方法" class="headerlink" title="常见的成员方法"></a>常见的成员方法</h1><p><img src="/assets/dd9adb91be924e9883e65f30ed8b321a.png" alt="dd9adb91be924e9883e65f30ed8b321a.png"></p><p>setPriority(int newPriority)【设置线程的优先级】 和 final int getPriority()【获取线程的优先级】</p><ul><li>优先级不是绝对的，只是表示线程有很大的概率能抢到CPU</li></ul><p>final void setDaemon(boolean on)：设置为守护线程</p><ul><li>当其他非守护线程结束了，守护线程也会陆续结束</li><li>应用场景：线程1（聊天）、线程2（传输文件-守护线程）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">            System.out.println(getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">        t2.setDaemon(<span class="literal">true</span>); <span class="comment">// 设置为守护线程</span></span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;非守护线程&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;守护线程&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程的生命周期【5种】"><a href="#线程的生命周期【5种】" class="headerlink" title="线程的生命周期【5种】"></a>线程的生命周期【5种】</h1><p><img src="/assets/82b504e93c09411da619543c59ef03e9.png" alt="82b504e93c09411da619543c59ef03e9.png"></p><h1 id="线程安全的问题"><a href="#线程安全的问题" class="headerlink" title="线程安全的问题"></a>线程安全的问题</h1><p>线程在执行的时候会有随机性，CPU的执行权随时有可能被其他线程抢走</p><p>买票问题：三个窗口同时卖100张票</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                ++ticket;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步代码块：把操作共享数据的代码锁起来"><a href="#同步代码块：把操作共享数据的代码锁起来" class="headerlink" title="同步代码块：把操作共享数据的代码锁起来"></a>同步代码块：把操作共享数据的代码锁起来</h2><ul><li>锁默认打开，有一个线程进去，锁自动关闭</li><li>里面的代码全部执行完毕，线程出来，锁自动打开</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (锁) &#123;</span><br><span class="line">    操作共享数据的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>更新上边买票代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 锁对象一定要是唯一的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 锁对象一般可以写成【当前类的字节码文件对象MyThraed.class】</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++ticket;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p> 把synchronized关键字加到方法上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 方法名(方法参数)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><ul><li>同步方法是锁住方法里面的所有代码</li><li>锁对象不能自己指定 <ul><li>非静态：this</li><li>静态：当前类的字节码文件对象</li></ul></li></ul><p>更新上边买票代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 如果是继承Runnable接口的方式定义的线程，不需要加static，因为只会定义一个MyRunnable对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket == <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            ++ticket;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>void lock()：获得锁</p><p>void unlock()：释放锁</p><blockquote><p>Lock是接口，不能直接实例化，需要采用他的实现类ReentrantLock来实例化</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 因为使用继承Thread的方式，所以ticket和lock都会创建多次，要保证只会创建一次，就要加上static关键字</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    ++ticket;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁【如果不写在finally里，达到100张票后，其中一个线程会经过break跳出循环，就无法释放锁，程序无法停止】</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁是一个错误，在写锁的时候，不要让两个锁嵌套写</p><p><img src="/assets/37439290d8b94a73be88e05f4b13c3d3.png" alt="37439290d8b94a73be88e05f4b13c3d3.png"></p><h1 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h1><h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p><img src="/assets/4c3d2285c11c45aaaea14e7902cdc8c7.png" alt="4c3d2285c11c45aaaea14e7902cdc8c7.png"></p><p>场景：有一个桌子（Desk）、厨师（Cook）、吃货（Foodie）；要求厨师做一碗，吃货吃一碗。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【厨师】：生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Desk.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断桌子上是否有食物</span></span><br><span class="line">                    <span class="keyword">if</span>(Desk.foodFlag == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有-等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 有-制作食物，修改食物状态、叫醒消费者</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;厨师正在做&quot;</span>);</span><br><span class="line">                        Desk.foodFlag = <span class="number">1</span>;</span><br><span class="line">                        Desk.lock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【吃货】：消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Desk.lock) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Desk.count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断桌子上是否有面条</span></span><br><span class="line">                    <span class="keyword">if</span>(Desk.foodFlag == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 没有 - 等待</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Desk.lock.wait();<span class="comment">// 要用锁对象调用wait方法，让当前线程和锁进行绑定</span></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 有 - 开吃、唤醒厨师、总数-1、更改桌子的状态</span></span><br><span class="line">                        Desk.count--;</span><br><span class="line">                        System.out.println(<span class="string">&quot;吃货正在吃，还能吃：&quot;</span>+ Desk.count);</span><br><span class="line">                        Desk.lock.notifyAll();<span class="comment">// 唤醒绑定在这把锁上的所有线程</span></span><br><span class="line">                        Desk.foodFlag = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 【桌子】：控制生产者和消费者的执行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Desk</span> &#123;</span><br><span class="line">    <span class="comment">// 桌子上是否有食物 0-没有食物、1-有食物</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">foodFlag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 锁对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cook</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>();</span><br><span class="line">        <span class="type">Foodie</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>();</span><br><span class="line">        cook.setName(<span class="string">&quot;厨师&quot;</span>);</span><br><span class="line">        foodie.setName(<span class="string">&quot;吃货&quot;</span>);</span><br><span class="line">        cook.start();</span><br><span class="line">        foodie.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="利用阻塞队列方式实现"><a href="#利用阻塞队列方式实现" class="headerlink" title="利用阻塞队列方式实现"></a>利用阻塞队列方式实现</h2><p>阻塞队列：连接生产者和消费者之间的管道。</p><ul><li>put数据：放不进去，会等着，叫做阻塞</li><li>take数据：取出第一个数据，取不到会等着，也叫阻塞</li></ul><blockquote><p>写的时候可以不用加锁，put()和take()底层就已经有锁了</p></blockquote><h3 id="阻塞队列的继承结构"><a href="#阻塞队列的继承结构" class="headerlink" title="阻塞队列的继承结构"></a>阻塞队列的继承结构</h3><p><img src="/assets/92fe5595b5f24ca3b41d6462ac3b58a4.png" alt="92fe5595b5f24ca3b41d6462ac3b58a4.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 【厨师】：生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cook</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cook</span><span class="params">(ArrayBlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 不断地把面条放入阻塞队列中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">&quot;面条&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;厨师放了一碗面条&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 【吃货】：消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foodie</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    ArrayBlockingQueue&lt;String&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Foodie</span><span class="params">(ArrayBlockingQueue queue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 不断地从阻塞队列中获取面条</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">food</span> <span class="operator">=</span> queue.take();</span><br><span class="line">                System.out.println(food);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建阻塞队列</span></span><br><span class="line">        ArrayBlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 创建线程的对象，并把阻塞队列传过去</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cook</span>(queue);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">foodie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Foodie</span>(queue);</span><br><span class="line">        cook.setName(<span class="string">&quot;厨师&quot;</span>);</span><br><span class="line">        foodie.setName(<span class="string">&quot;吃货&quot;</span>);</span><br><span class="line">        cook.start();</span><br><span class="line">        foodie.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="线程的状态【7种】"><a href="#线程的状态【7种】" class="headerlink" title="线程的状态【7种】"></a>线程的状态【7种】</h1><p><img src="/assets/2ac906960b66471d8a04b7b4c0e2bcef.png" alt="2ac906960b66471d8a04b7b4c0e2bcef.png"></p><blockquote><p>注：在Java虚拟机种只有六种状态，没有运行状态，因为线程抢到CPU的执行权进入运行状态，虚拟机就会把当前线程交给操作系统管理</p></blockquote><p><img src="/assets/438d5dbcea4c4f58926a6a50ae6f0f02.png" alt="438d5dbcea4c4f58926a6a50ae6f0f02.png"></p><h1 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h1><p><img src="/assets/6b7fe42977f5476ea43d715e2b857282.png" alt="6b7fe42977f5476ea43d715e2b857282.png"></p><blockquote><p>线程1和线程2的run()方法里的存储空间是相互独立的。</p></blockquote><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ol><li><strong>创建一个池子</strong>，池子是空的</li><li><strong>提交任务</strong>，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接服用已有的线程即可。</li><li>如果提交任务时，池子里没有空闲的线程，也无法创建新的线程，任务就会排队等待。</li></ol><p>Executors：线程池的工具类，通过调用方法返回不同类型的线程池对象</p><p><img src="/assets/4de2b6aa401f4fff96e320e3d4885980.png" alt="4de2b6aa401f4fff96e320e3d4885980.png"></p><h2 id="创建没有上限的线程池"><a href="#创建没有上限的线程池" class="headerlink" title="创建没有上限的线程池"></a>创建没有上限的线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        <span class="comment">// 销毁线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>线程是可以复用的，代码中让提交任务后，让main线程睡1秒中，此时上一个线程执行完毕，就会把线程重新放入线程池中</p></blockquote><h2 id="创建有上限的线程池"><a href="#创建有上限的线程池" class="headerlink" title="创建有上限的线程池"></a>创建有上限的线程池</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        <span class="comment">// 销毁线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><blockquote><p>上边的代码相当于是3个线程在执行5个任务。因为创建了多个线程，所以当代码一步一步往下走的时候，上一步可能是还没执行完的。所以运行到第四个提交任务的时候，就会有一个任务在排队了，到第五个提交任务，就有两个任务在排队。</p></blockquote><p>线程池多大合适？</p><p><img src="/assets/62bf226445104081a2cff5e196bce135.png" alt="62bf226445104081a2cff5e196bce135.png"></p><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p><img src="/assets/110193df8ff741deaf86cff67b7a3b43.png" alt="110193df8ff741deaf86cff67b7a3b43.png"></p><p><img src="/assets/71e1aa7b657c428d946b3cf61cf8a39c.png" alt="71e1aa7b657c428d946b3cf61cf8a39c.png"></p><p><img src="/assets/a7a1272ec0724c1db98149da1afc6ce3.png" alt="a7a1272ec0724c1db98149da1afc6ce3.png"></p><blockquote><p><strong>核心线程</strong>都在处理任务，队伍中也已经排满了，此时才会创建<strong>临时线程</strong>去处理任务。</p><p>任务的执行不会按照提交的顺序去执行。</p></blockquote><p><img src="/assets/9b88ce4525dc49578d6921b95e2d81e1.png" alt="9b88ce4525dc49578d6921b95e2d81e1.png"></p><blockquote><p>核心线程和临时线程都在工作，队伍中也排满了，此时线程池就会触发<strong>任务拒绝策略</strong>。</p></blockquote><h3 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h3><p><img src="/assets/166fdb7e0c654fcb956a927b8be1a833.png" alt="166fdb7e0c654fcb956a927b8be1a833.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><img src="/assets/1df5bad3e7984d07a11a58beb0b75dd3.png" alt="1df5bad3e7984d07a11a58beb0b75dd3.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">3</span>, <span class="comment">// 核心线程数量</span></span><br><span class="line">                <span class="number">6</span>,<span class="comment">// 最大线程数量</span></span><br><span class="line">                <span class="number">60</span>,<span class="comment">// 空闲线程最大存活时间</span></span><br><span class="line">                TimeUnit.SECONDS, <span class="comment">// 时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>), <span class="comment">// 任务队列</span></span><br><span class="line">                Executors.defaultThreadFactory(), <span class="comment">// 创建线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="comment">// 任务的拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 同步异步 </tag>
            
            <tag> javase </tag>
            
            <tag> 多线程 </tag>
            
            <tag> Thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-不可变集合</title>
      <link href="/post/9e7d9a7f.html"/>
      <url>/post/9e7d9a7f.html</url>
      
        <content type="html"><![CDATA[<p>JDK9以后才有不可变集合</p><hr><h1 id="创建不可变集合的应用场景"><a href="#创建不可变集合的应用场景" class="headerlink" title="创建不可变集合的应用场景"></a>创建不可变集合的应用场景</h1><ol><li>如果某个数据不能被修改，可以把他拷贝到不可变集合。</li><li>当集合对象被不可信的库调用，不可变形式是安全的。</li></ol><h1 id="创建不可变集合的书写方式"><a href="#创建不可变集合的书写方式" class="headerlink" title="创建不可变集合的书写方式"></a>创建不可变集合的书写方式</h1><p>在List、Set、Map接口中，都存在静态的of方法，可以获取一个不可变的集合<br><img src="/assets/d6832a15c2d74a54a1dd59ce05bb85f1.png" alt="d6832a15c2d74a54a1dd59ce05bb85f1.png"></p><blockquote><p>这个集合不能添加，不能删除，不能修改。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 一旦创建完毕，是无法修改的，只能进行查询操作</span></span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">// 在Set集合中，里边的参数要保证唯一，否则就会报错</span></span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="comment">// 在Map集合中，键也不能重复 且 参数有上限（最多只能传递10个键值对）</span></span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于Map.of()方法最多只能传递10个键值对，如果想存储超过10个的键值对，可以使用Map.ofEntries()方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 获取所有的entry对象</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">    <span class="comment">// 把entries变成数组</span></span><br><span class="line">    <span class="comment">// toArray底层会把集合的长度和数组的长度做一个比较</span></span><br><span class="line">    <span class="comment">// 如果集合的长度 &gt; 数组的长度，会根据实际数据的个数，重新创建新的数组</span></span><br><span class="line">    <span class="comment">// 如果集合的长度 ≤ 数组的长度，表示数据在数组中放得下，不会创建新的数组，直接使用数组的长度</span></span><br><span class="line">    Map.Entry[] arr = entries.toArray(<span class="keyword">new</span> <span class="title class_">Map</span>.Entry[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 不可变的map集合</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">res</span> <span class="operator">=</span> Map.ofEntries(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK10如果想存储超过10个的键值对，可以用Map.copyOf()方法</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">res</span> <span class="operator">=</span> Map.copyOf(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-反射</title>
      <link href="/post/94e71cae.html"/>
      <url>/post/94e71cae.html</url>
      
        <content type="html"><![CDATA[<p>反射允许对成员变量，成员方法、构造方法的信息进行编程访问。<br>反射 &#x3D; 获取 + 解剖</p><ul><li>获取：获取class对象</li><li>解剖：解剖class对象的一些方法信息</li></ul><h1 id="获取class对象的三种方式"><a href="#获取class对象的三种方式" class="headerlink" title="获取class对象的三种方式"></a>获取class对象的三种方式</h1><ul><li>Class.forName(“全类名”)：最常用。</li><li>类名.class：当作参数进行传递</li><li>对象.getClass()：当已经有了这个类的对象时可以使用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Class.forName(&quot;全类名&quot;)</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Student&quot;</span>);<span class="comment">// 全类名 = 包名 + 类名</span></span><br><span class="line">        <span class="comment">// 类名.class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">        <span class="comment">// 对象.getClass()</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用反射获取构造方法Constructor"><a href="#利用反射获取构造方法Constructor" class="headerlink" title="利用反射获取构造方法Constructor"></a>利用反射获取构造方法Constructor</h1><p><img src="/assets/ddcb8d18273a47d9a97f16a5da85b511.png" alt="ddcb8d18273a47d9a97f16a5da85b511.png"></p><h2 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Stu</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Stu</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有公共的构造方法</span></span><br><span class="line">        Constructor[] cons1 = clazz.getConstructors();</span><br><span class="line">        <span class="comment">// 获取所有的构造方法</span></span><br><span class="line">        Constructor[] cons2 = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 获取单个构造方法对象【只能获取公共的】</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con1</span> <span class="operator">=</span> clazz.getConstructor();</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con2</span> <span class="operator">=</span> clazz.getConstructor(String.class);</span><br><span class="line">        <span class="comment">// 获取单个构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con3</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con4</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(con4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取权限修饰符"><a href="#获取权限修饰符" class="headerlink" title="获取权限修饰符"></a>获取权限修饰符</h2><blockquote><p>getDeclaredConstructor()如果获取的是私有的构造方法，正常情况不能用获取的构造方法创建对象，但是使用<strong>暴力反射</strong>就可以使用私有的构造方法创建对象了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructor con = clazz.getDeclaredConstructor(String.class, int.class);</span><br><span class="line">con.setAccessible(true);</span><br><span class="line">Stu stu = (Stu) con.newInstance(&quot;zhangsan&quot;, 23);</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取构造方法对象【私有的】</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="comment">// 暴力反射：临时取消权限校验【如果使用私有的构造方法，需要加上这行】</span></span><br><span class="line">        con.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> (Stu) con.newInstance(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取构造方法的权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> con.getModifiers();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取构造方法的参数</span></span><br><span class="line">        Parameter[] ps = con.getParameters();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用反射获取成员变量Field"><a href="#利用反射获取成员变量Field" class="headerlink" title="利用反射获取成员变量Field"></a>利用反射获取成员变量Field</h1><p><img src="/assets/200774045d0b4aaa8d4fd770a9ad92ec.png" alt="200774045d0b4aaa8d4fd770a9ad92ec.png"></p><h2 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">// 获取class字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu2&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有公共的成员变量</span></span><br><span class="line">        Field[] fields1 = clazz.getFields();</span><br><span class="line">        <span class="comment">// 获取所有的成员变量</span></span><br><span class="line">        Field[] fields2 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 获取公共的单个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">gender</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取单个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取权限修饰符-1"><a href="#获取权限修饰符-1" class="headerlink" title="获取权限修饰符"></a>获取权限修饰符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 获取字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取单个成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取成员变量记录的值</span></span><br><span class="line">        <span class="comment">// 暴力反射：临时取消权限校验【如果要获取私有的成员变量，需要加上这行】</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) name.get(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改成员变量的值</span></span><br><span class="line">        name.set(stu, <span class="string">&quot;linsan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> name.getModifiers();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员变量名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> name.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据类型</span></span><br><span class="line">        Class&lt;?&gt; type = name.getType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="利用反射获取成员方法Method"><a href="#利用反射获取成员方法Method" class="headerlink" title="利用反射获取成员方法Method"></a>利用反射获取成员方法Method</h1><p><img src="/assets/034ce5f995e2439daf61435975e0e494.png" alt="034ce5f995e2439daf61435975e0e494.png"></p><h2 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">eat</span><span class="params">(String something)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在吃&quot;</span> + something);</span><br><span class="line">        <span class="keyword">return</span> something;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something, <span class="type">int</span> a)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在吃&quot;</span> + something);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu3&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有公共的方法【包含父类中所有的公共方法】</span></span><br><span class="line">        Method[] methods1 = clazz.getMethods();</span><br><span class="line">        <span class="comment">// 获取所有本类中的方法【包括私有方法】</span></span><br><span class="line">        Method[] methods2 = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// 获取公共的方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">sleep</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取指定的单一方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取权限修饰符-2"><a href="#获取权限修饰符-2" class="headerlink" title="获取权限修饰符"></a>获取权限修饰符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.reflect.reflect_01_get.Stu3&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">eat</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// 获取方法的修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> eat.getModifiers();</span><br><span class="line">        <span class="comment">// 获取方法的名字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> eat.getName();</span><br><span class="line">        <span class="comment">// 获取方法的形参</span></span><br><span class="line">        Parameter[] parameters = eat.getParameters();</span><br><span class="line">        <span class="comment">// 获取方法抛出的异常</span></span><br><span class="line">        Class&lt;?&gt;[] exceptionTypes = eat.getExceptionTypes();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 运行方法：</span></span><br><span class="line"><span class="comment">         * Object invoke(Object obj, Object... args)：运行方法</span></span><br><span class="line"><span class="comment">         * 参数1：用obj对象调用该方法</span></span><br><span class="line"><span class="comment">         * 参数2：调用方法的传递的参数（如果没有就不写）</span></span><br><span class="line"><span class="comment">         * 返回值：方法的返回值（如果没有就不写）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Stu3</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu3</span>();</span><br><span class="line">        eat.setAccessible(<span class="literal">true</span>); <span class="comment">// 取消访问权限</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> (String) eat.invoke(stu, <span class="string">&quot;火锅&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h1><ol><li>获取一个类里面所有的信息，获取到之后，再执行其他的业务逻辑</li><li>结合配置文件，动态的创建对象并调用方法</li></ol><blockquote><p>总结：</p><ul><li><strong>get</strong>：获取</li><li><strong>set</strong>：设置</li><li><strong>Constructor</strong>：构造方法</li><li><strong>Field</strong>：成员变量</li><li><strong>Method</strong>：方法</li><li><strong>Parameter</strong>：参数</li><li><strong>Modifiers</strong>：修饰符</li><li><strong>Declared</strong>：私有的</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-方法引用</title>
      <link href="/post/4b4db8e0.html"/>
      <url>/post/4b4db8e0.html</url>
      
        <content type="html"><![CDATA[<p><strong>方法引用</strong>：就是把已经有的方法拿过来用，当作函数式接口抽象方法的方法体。<br><strong>条件</strong>：</p><ol><li>引用处必须是函数式接口</li><li>被引用的方法必须已经存在</li><li>被引用方法的形参和返回值需要和抽象方法保持一致</li><li>被引用的方法要满足当前需求</li></ol><p><strong>格式</strong>：类名::方法名</p><hr><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="comment">// 被引用的方法：可以是java已经写好的，也可以是第三方工具类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">// lambda表达式</span></span><br><span class="line">        Arrays.sort(arr, (o1, o2) -&gt; o1 - o2);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="comment">// 改进：方法引用</span></span><br><span class="line">        Arrays.sort(arr, Demo01::sub); <span class="comment">// 类名::方法名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用静态方法"><a href="#引用静态方法" class="headerlink" title="引用静态方法"></a>引用静态方法</h1><p>格式：类名::静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; list1 = list.stream().map(Integer::parseInt)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用成员方法"><a href="#引用成员方法" class="headerlink" title="引用成员方法"></a>引用成员方法</h1><p>格式：对象::成员方法</p><ol><li>其他类：其它类对象::方法名</li><li>本类：this::方法名</li><li>父类：super::方法名</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">StringJudge</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; s.length() == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;赵敏&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;张翠山&quot;</span>, <span class="string">&quot;张良&quot;</span>, <span class="string">&quot;王二麻子&quot;</span>, <span class="string">&quot;谢广坤&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = list.stream().filter(<span class="keyword">new</span> <span class="title class_">Demo03</span>()::StringJudge)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：引用本类成员方法、父类成员方法处不能是静态方法</p></blockquote><h1 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h1><p>格式：类名::new</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer no;</span><br><span class="line">    <span class="comment">// 流里边的数据是string，所以这里形参需要写string</span></span><br><span class="line">    Student(String str) &#123;</span><br><span class="line">        String[] split = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = split[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.no = Integer.valueOf(split[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张无忌-1&quot;</span>, <span class="string">&quot;周芷若-2&quot;</span>, <span class="string">&quot;赵敏-3&quot;</span>, <span class="string">&quot;张三丰-4&quot;</span>, <span class="string">&quot;张翠山-5&quot;</span>, <span class="string">&quot;张良-6&quot;</span>, <span class="string">&quot;王二麻子-7&quot;</span>, <span class="string">&quot;谢广坤-8&quot;</span>);</span><br><span class="line">        List&lt;Student&gt; list1 = list.stream().map(Student::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他调用方式"><a href="#其他调用方式" class="headerlink" title="其他调用方式"></a>其他调用方式</h1><h2 id="使用类名引用成员方法"><a href="#使用类名引用成员方法" class="headerlink" title="使用类名引用成员方法"></a>使用类名引用成员方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        List&lt;String&gt; list1 = list.stream()</span><br><span class="line">        <span class="comment">// 拿着流里的数据，去调用String类中的toUpperCase方法，返回值就是转换后的结果</span></span><br><span class="line">                .map(String::toUpperCase)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注】：被引用方法的形参需要跟抽象方法的<strong>第二个形参到最后一个形参</strong>保持一致<br><img src="/assets/13727fe029cd4c4b97be59bd9718328f.png" alt="13727fe029cd4c4b97be59bd9718328f.png"></p><ol><li>第一个参数：表示被引用方法的调用者，决定了可以引用哪些类中的方法<br>在stream流中，第一个参数一般都表示流里边每个数据，假设流里边的数据是字符串，那么只能引用String这个类中的方法</li><li>第二个参数到最后一个参数：和被引用方法的形参保持一致，如果没有第二个参数，说明被引用的方法需要是无参的成员方法</li></ol></blockquote><h2 id="引用数组的构造方法"><a href="#引用数组的构造方法" class="headerlink" title="引用数组的构造方法"></a>引用数组的构造方法</h2><p>格式：数据类型[]::new</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        String[] array = list.stream()</span><br><span class="line">                .toArray(String[]::<span class="keyword">new</span>); <span class="comment">// 数组中的类型需要和流中数据的类型保持一致</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 方法引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-可变集合</title>
      <link href="/post/53e9807a.html"/>
      <url>/post/53e9807a.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合的体系结构"><a href="#集合的体系结构" class="headerlink" title="集合的体系结构"></a>集合的体系结构</h1><p><img src="/assets/225e05bdb27e4545a5bc6c774b3d21f2.png" alt="225e05bdb27e4545a5bc6c774b3d21f2.png"><br>List：添加的元素是有序、可重复、有索引的。<br>Set：添加的元素是无序、不重复、无索引的。</p><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>是单列集合的祖宗<strong>接口</strong>，它的功能是所有单列集合都可以继承使用。</p><h2 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h2><p><img src="/assets/1d4ba5478768419eafc91c126267031c.png" alt="1d4ba5478768419eafc91c126267031c.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 增：</span></span><br><span class="line"><span class="comment">         * 往List集合里添加数据，方法永远返回true</span></span><br><span class="line"><span class="comment">         * 往Set集合里添加数据</span></span><br><span class="line"><span class="comment">         *      元素已经存在：返回false</span></span><br><span class="line"><span class="comment">         *      元素不存在：返回true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.remove(<span class="string">&quot;aaa&quot;</span>); <span class="comment">// 删</span></span><br><span class="line">        coll.clear();<span class="comment">// 删：清空集合</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断要删除的元素是否存在</span></span><br><span class="line"><span class="comment">         * contains底层是依赖equals()方法进行判断的</span></span><br><span class="line"><span class="comment">         * 如果集合中存储的是自定义的对象，一定要重写equals方法</span></span><br><span class="line"><span class="comment">         * 如果没有重写equals方法，默认使用Object中的equals方法【通过地址值判断】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isExists</span> <span class="operator">=</span> coll.contains(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> coll.isEmpty();<span class="comment">// 判断集合是否为空</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> coll.size(); <span class="comment">// 获取集合长度 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="迭代器遍历"><a href="#迭代器遍历" class="headerlink" title="迭代器遍历"></a>迭代器遍历</h3><p>迭代器Iterator是集合专用的遍历方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator(); <span class="comment">// 获取迭代器对象</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123; <span class="comment">// 是否还有元素</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next(); <span class="comment">// 获取元素，移动指针</span></span><br><span class="line">            System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>迭代器遍历<strong>不依赖索引</strong></li><li>如果迭代器遍历到最后一个位置了，还强行使用it.next()，会报错：<strong>NoSuchElementException</strong></li><li>迭代器遍历完毕，<strong>指针不会复位</strong></li><li>循环中只能用一次next方法【如果想要使用第二次，最好在循环里多判断一次hasNext()】</li><li>迭代器遍历时，<strong>不能使用集合的方法进行添加或删除</strong>，会报错：ConcurrentModificationException<ul><li>但是可以用迭代器提供的remove()方法进行删除</li><li>添加暂时无解</li></ul></li></ul></blockquote><h3 id="增强for遍历"><a href="#增强for遍历" class="headerlink" title="增强for遍历"></a>增强for遍历</h3><p>增强for是为了简化迭代器的书写，内部原理就是迭代器，<strong>单列集合、数组</strong>才能用增强for遍历。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 变量名 : 数组或集合)&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改增强for中的变量（第三方变量），不会改变集合原本的数据</p></blockquote><h3 id="lambda表达式遍历"><a href="#lambda表达式遍历" class="headerlink" title="lambda表达式遍历"></a>lambda表达式遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>forEach的底层就是增强for</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>迭代器：删除元素<br>读：增强for 或 lambda</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p>有序、有索引、可重复<br>List集合的方法 &#x3D; Collection的方法  + 索引操作的方法</p><h2 id="List中特有的方法"><a href="#List中特有的方法" class="headerlink" title="List中特有的方法"></a>List中特有的方法</h2><p>Collection的方法List都继承了</p><blockquote><ul><li>删除元素：</li></ul><ul><li>如果在调用remove()方法时，remove(int idx) 和 remove(Object obj)都可以匹配上，那么优先调用实际参数和形参保持一致的方法。</li></ul></blockquote><h3 id="索引操作的方法"><a href="#索引操作的方法" class="headerlink" title="索引操作的方法"></a>索引操作的方法</h3><p><img src="/assets/4173a3a2d709400d9bfcad56fb999510.png" alt="4173a3a2d709400d9bfcad56fb999510.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 在指定索引添加元素【原来索引上的元素会依次往后移】</span></span><br><span class="line">        list.add(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素，通过索引删除【返回被删除索引的元素】</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">remove</span> <span class="operator">=</span> list.remove(<span class="number">1</span>); <span class="comment">// 优先调用实参和形参保持一致的方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除元素，通过元素删除【返回bool值判断是否删除成功】</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>); <span class="comment">// 手动装箱，把基本类型变成Integer类型</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isRemove</span> <span class="operator">=</span> list.remove(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改指定索引的元素【返回修改前的元素】</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">res</span> <span class="operator">=</span> list.set(<span class="number">0</span>, <span class="number">33</span>);</span><br><span class="line">        <span class="comment">// 返回指定索引的元素</span></span><br><span class="line">        res = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List中独有的遍历方式"><a href="#List中独有的遍历方式" class="headerlink" title="List中独有的遍历方式"></a>List中独有的遍历方式</h2><p> Collection的遍历方式List都可以用<br> List集合的遍历方式 &#x3D; Collection中的遍历方式 + 列表迭代器遍历 + 普通for遍历</p><h3 id="Collection中的遍历方式-普通for遍历"><a href="#Collection中的遍历方式-普通for遍历" class="headerlink" title="Collection中的遍历方式 + 普通for遍历"></a>Collection中的遍历方式 + 普通for遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. Lambda表达式遍历</span></span><br><span class="line">        list.forEach(s -&gt; System.out.println(s));</span><br><span class="line">        <span class="comment">// 4.普通for遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表迭代器"><a href="#列表迭代器" class="headerlink" title="列表迭代器"></a>列表迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        <span class="comment">// 5.列表迭代器遍历</span></span><br><span class="line">        ListIterator&lt;String&gt; it = list.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;bbb&quot;</span>.equals(str)) &#123;</span><br><span class="line">                it.add(<span class="string">&quot;zzz&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>列表迭代器 相比 迭代器多出了<strong>添加元素</strong>的方法</p></blockquote><h3 id="五种方式的对比"><a href="#五种方式的对比" class="headerlink" title="五种方式的对比"></a>五种方式的对比</h3><p>迭代器：需要删除元素<br>列表迭代器：需要添加元素<br>增强for、lambda：仅遍历元素<br> 普通for：想操作索引</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p>ArrayList的底层是<strong>数组</strong>的，ArrayList中的方法 &#x3D; List中的方法</p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><ol><li>利用空参创建的集合，在底层创建一个默认长度为0的数组。</li><li>添加第一个元素，底层会创建一个长度为10的数组。</li><li>存满时，会扩容1.5倍。</li><li>如果一次添加多个元素，1.5倍放不下，则新数组的长度以实际长度为准。</li></ol><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p> LinkedList的底层是<strong>双链表</strong>，查询慢、增删快。<br> LinkedList中的方法 &#x3D; List中的方法 + LinkedList中独有的方法（少用）</p><h3 id="LinkedList中独有的方法"><a href="#LinkedList中独有的方法" class="headerlink" title="LinkedList中独有的方法"></a>LinkedList中独有的方法</h3><p><img src="/assets/93a6bab83fb94913856e6be23387bc9c.png" alt="93a6bab83fb94913856e6be23387bc9c.png"></p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>泛型：在编译阶段约束操作的数据类型</li><li>泛型只支持<strong>引用数据类型</strong>（基本数据类型要转成包装类才行）</li><li>不写泛型，默认是Object类型</li><li>如果没有给集合指定泛型，默认所有的数据类型都是Object类型，此时可以往集合中添加任意类型的数据，在获取数据的时候，无法使用元素的特有行为。</li></ul><blockquote><p>Java中的泛型是伪泛型<br><img src="/assets/130435e5f1bb415b8ed9e9c6fca8fd0d.png" alt="130435e5f1bb415b8ed9e9c6fca8fd0d.png"></p></blockquote><h2 id="泛型可以定义的地方"><a href="#泛型可以定义的地方" class="headerlink" title="泛型可以定义的地方"></a>泛型可以定义的地方</h2><h3 id="泛型类（类后边）"><a href="#泛型类（类后边）" class="headerlink" title="泛型类（类后边）"></a>泛型类（类后边）</h3><p>使用场景：当定义一个类时，某个变量的数据类型不确定，就可以定义带有泛型的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名&lt;类型&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&lt;E&gt; &#123; <span class="comment">// E可以理解成变量</span></span><br><span class="line">E sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList</span>&lt;E&gt; &#123;</span><br><span class="line">    Object[] obj = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// E：是不确定的数据类型，该类型在类名后已经定义过了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        obj[size] = e;</span><br><span class="line">        ++size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (E)obj[idx];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.toString(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyArrayList&lt;String&gt; list =  <span class="keyword">new</span> <span class="title class_">MyArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法（方法上边）"><a href="#泛型方法（方法上边）" class="headerlink" title="泛型方法（方法上边）"></a>泛型方法（方法上边）</h3><p>方法中形参类型不确定</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名) &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(ArrayList&lt;T&gt; list, T...elements)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(T e : elements) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ListUtil.addAll(list, <span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口（接口后边）"><a href="#泛型接口（接口后边）" class="headerlink" title="泛型接口（接口后边）"></a>泛型接口（接口后边）</h3><ul><li>方式1：实现类给出具体类型</li><li>方式2：实现类延续泛型，创建对象时再确定</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名&lt;类型&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyList</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K element)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList1</span> <span class="keyword">implements</span> <span class="title class_">MyList</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String element)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArrayList2</span>&lt;K&gt; <span class="keyword">implements</span> <span class="title class_">MyList</span>&lt;K&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(K element)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式1：实现类给出具体类型</span></span><br><span class="line">        <span class="type">MyArrayList1</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyArrayList1</span>(); <span class="comment">// 不需要指定泛型了</span></span><br><span class="line">        <span class="comment">// 方式2：实现类延续泛型，创建对象时再确定</span></span><br><span class="line">        MyArrayList2&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">MyArrayList2</span>(); <span class="comment">// 需要指定泛型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><ul><li>泛型不具备继承性，但是数据具备继承性</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ye</span>&#123;&#125; <span class="comment">// 爷爷</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fu</span> <span class="keyword">extends</span> <span class="title class_">Ye</span>&#123;&#125; <span class="comment">// 父亲</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zi</span> <span class="keyword">extends</span> <span class="title class_">Fu</span>&#123;&#125; <span class="comment">// 儿子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.泛型不具备继承性</span></span><br><span class="line"><span class="comment">     * 此时泛型里面写的是什么类型，只能传递什么类型的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;Ye&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        method(list1);</span><br><span class="line">        <span class="comment">// method(list2); // 代码报错</span></span><br><span class="line">        <span class="comment">// method(list3); // 代码报错</span></span><br><span class="line">        <span class="comment">// 2.数据具备继承性</span></span><br><span class="line">        list1.add(<span class="keyword">new</span> <span class="title class_">Ye</span>());</span><br><span class="line">        list1.add(<span class="keyword">new</span> <span class="title class_">Fu</span>());</span><br><span class="line">        list1.add(<span class="keyword">new</span> <span class="title class_">Zi</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果方法形参是一个集合，集合中的数据类型不确定，可以用<strong>泛型方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;T&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        method(list1);</span><br><span class="line">        method(list2);</span><br><span class="line">        method(list3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><blockquote><p>上边代码存在一个问题：这种情况下它可以接受任意的数据类型<br>如果希望以后这个参数的数据类型只能是：Ye、Fu、Zi类，可以用<strong>泛型的通配符</strong></p><ul><li>? extends E：表示可以传递E或E所有的子类类型</li><li>? super E：表示可以传递E或E所有的父类类型</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;E&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(ArrayList&lt;E&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(ArrayList&lt;? extends Ye&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;? <span class="built_in">super</span> Zi&gt; list)</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Ye&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Fu&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Zi&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        method1(list1);</span><br><span class="line">        method1(list2);</span><br><span class="line">        method1(list3);</span><br><span class="line">        method2(list1);</span><br><span class="line">        method2(list2);</span><br><span class="line">        method2(list3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><blockquote><p>如果定义类、方法、接口时，类型不确定，可以定义<strong>泛型类、泛型方法、泛型接口</strong>。<br>如果类型不确定，但是能知道以后只能传递某个继承体系中的，可以使用<strong>泛型通配符</strong>。</p></blockquote><h1 id="单列集合Set"><a href="#单列集合Set" class="headerlink" title="单列集合Set"></a>单列集合Set</h1><p>无序、不重复、无索引<br>Set集合的方法 &#x3D; Collection的方法</p><blockquote><p>【注】：所有Set集合的底层原理都是new Map()</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; st = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 第一次添加，添加成功</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r1</span> <span class="operator">=</span> st.add(<span class="string">&quot;A&quot;</span>); <span class="comment">// true</span></span><br><span class="line">        <span class="comment">// 第二次添加，添加失败</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r2</span> <span class="operator">=</span> st.add(<span class="string">&quot;A&quot;</span>); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 1.迭代器遍历</span></span><br><span class="line">        Iterator&lt;String&gt; it = st.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.增强for遍历</span></span><br><span class="line">        <span class="keyword">for</span> (String s : st) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.Lambda表达式遍历</span></span><br><span class="line">        st.forEach(x -&gt; System.out.println(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Set集合的实现类：</p><ul><li>HashSet：无序、不重复、无索引</li><li>LinkedHashSet：有序、不重复、无索引</li><li>TreeSet：可排序、不重复、无索引</li></ul></blockquote><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p>HashSet底层采用<strong>哈希表</strong>存储数据</p><ul><li>哈希表的组成：<ul><li>JDK8之前：数组 + 链表</li><li>JDK8开始：数组 + 链表 + 红黑树</li></ul></li></ul><h3 id="哈希值"><a href="#哈希值" class="headerlink" title="哈希值"></a>哈希值</h3><ul><li><p>对象的整数表现形式，根据hashCode()算出来的int类型的整数</p></li><li><p>hashCode()定义在<strong>Object类中</strong>，所有的对象都可以调用，<strong>默认使用地址值</strong>进行计算</p></li><li><p>一般情况需要<strong>重写hashCode()方法</strong>，利用对象内部的属性值计算哈希值</p><ul><li>如果没有重写hashCode()方法，不同对象计算出的hashCode是不不同的</li><li>如果重写hashCode()方法，不同对象只要属性值相同，计算出的哈希值是一样的</li><li>小概率：不同属性值或不同地址值计算出来的哈希值也可能一样（哈希碰撞）</li></ul></li></ul><h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><ol><li>创建一个默认长度为16，默认加载因子为0.75的数组</li></ol><blockquote><p>hashSet的扩容时机：</p><ul><li>16 * 0.75 &#x3D; 12，当数组中元素达到12个元素，就会扩容成原先的2倍</li><li><strong>（JDK8开始）</strong>链表的长度 &gt; 8 且 数组长度 ≥ 64，当前链表会自动转成红黑树</li></ul></blockquote><ol start="2"><li>根据数组的哈希值与数组的长度计算元素应存入的位置</li></ol><blockquote><p>int idx &#x3D; (数组长度 - 1) &amp; 哈希值;</p></blockquote><ol start="3"><li>判断当前位置是否为null<ul><li>如果是null，直接存入</li><li>如果不是null，调用equals()方法比较属性值<ul><li>一样：不存</li><li>不一样：存入数组，形成链表 <ul><li>JDK8以前：新数组存入数组，老元素挂在新数组下边</li><li>JDK8开始：新元素直接挂在老元素下边</li></ul></li></ul></li></ul></li></ol><blockquote><p>如果集合中存储的是自定义对象，必须重写hashCode和equals方法</p></blockquote><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><ul><li>有序、不重复、无索引</li><li>有序：存储和取出元素的顺序一致</li><li>原理：底层仍然是哈希表，只是每个元素有额外多了一个<strong>双链表</strong>的机制记录存储的顺序</li></ul><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><ul><li>可排序、不重复、无索引</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">1</span>);</span><br><span class="line">        set.add(<span class="number">4</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">5</span>);</span><br><span class="line">        set.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(set); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TreeSet集合默认排序规则"><a href="#TreeSet集合默认排序规则" class="headerlink" title="TreeSet集合默认排序规则"></a>TreeSet集合默认排序规则</h3><ul><li>数值类型（Integer、Double）：默认按照从小到大顺序排序</li><li>字符、字符串类型：默认按照字符在ASCII码表中的顺序升序排序</li></ul><h3 id="TreeSet集合的两种比较方式"><a href="#TreeSet集合的两种比较方式" class="headerlink" title="TreeSet集合的两种比较方式"></a>TreeSet集合的两种比较方式</h3><blockquote><p>【注】：<br>如果使用TreeSet集合存储自定义类型，不需要重写HashCode和equals方法，但是需要在类里边指定排序规则。</p></blockquote><h4 id="方式1：默认排序-自然排序"><a href="#方式1：默认排序-自然排序" class="headerlink" title="方式1：默认排序 &#x2F; 自然排序"></a>方式1：默认排序 &#x2F; 自然排序</h4><p>Javabean<strong>实现Comparable接口</strong>指定比较规则。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Stu&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义排序规则</span></span><br><span class="line"><span class="comment">     * this：表示当前要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 表示已经在红黑树中存在的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 负数-要添加的元素是小的-存左边</span></span><br><span class="line"><span class="comment">     *         正数-要添加的元素是大的-存右边</span></span><br><span class="line"><span class="comment">     *         0-要添加的元素已经存在-舍弃不存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAge() - o.getAge(); <span class="comment">// 升序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo06</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaoshi&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaohan&quot;</span>, <span class="number">19</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaolin&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;03&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式2：比较器排序"><a href="#方式2：比较器排序" class="headerlink" title="方式2：比较器排序"></a>方式2：比较器排序</h4><p>创建TreeSet对象时，传递比较器Compartor指定规则</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span><span class="comment">/**</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o1 当前要添加的元素</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> o2 已经在红黑树中存在的元素</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">             */</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compare(String o1, String o2) &#123;</span></span><br><span class="line"><span class="comment">                // 按照长度排序，如果长度一样，按照首字母排序</span></span><br><span class="line"><span class="comment">                return o1.length() == o2.length() ? o1.compareTo(o2) : o1.length() - o2.length();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((o1, o2) -&gt; o1.length() == o2.length() ? o1.compareTo(o2) : o1.length() - o2.length());</span><br><span class="line">        set.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;df&quot;</span>);</span><br><span class="line">        set.add(<span class="string">&quot;quer&quot;</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种比较规则的使用场景"><a href="#两种比较规则的使用场景" class="headerlink" title="两种比较规则的使用场景"></a>两种比较规则的使用场景</h4><p>默认使用第一种，如果第一种不能满足规则，就使用第二种。</p><h1 id="List、Set的使用场景"><a href="#List、Set的使用场景" class="headerlink" title="List、Set的使用场景"></a>List、Set的使用场景</h1><ol><li>如果想要集合中的元素可重复：<strong>ArrayList</strong>、基于数组</li><li>如果想要集合中的元素可重复，且增删操作多余查询：LinkedList、基于链表</li><li>如果想对集合中的元素去重：<strong>HashSet</strong>、基于哈希表</li><li>如果想对集合中的元素去重，且保证存储顺序：LinkedHashSet、基于哈希表和双链表，效率低于HashSet</li><li>如果想对集合中的元素进行排序：TreeSet、基于红黑树</li></ol><h1 id="双列集合Map"><a href="#双列集合Map" class="headerlink" title="双列集合Map"></a>双列集合Map</h1><ul><li>一次需要存一对数据（键-值）</li><li>键不能重复，值可以重复</li><li>键值是一一对应的，每个键只能找到对应的值</li><li>键 + 值 称为“键值对”，在java中叫做“Entry对象”</li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p><img src="/assets/6a6e69213a3f4aff87d018d374245b9a.png" alt="6a6e69213a3f4aff87d018d374245b9a.png"></p><h2 id="常见的API"><a href="#常见的API" class="headerlink" title="常见的API"></a>常见的API</h2><p>Map是双列集合的顶层接口，他的功能是全部双列集合都可以继承使用的。<br><img src="/assets/9d96c5d979ea4613ba1398638ebe771d.png" alt="9d96c5d979ea4613ba1398638ebe771d.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加 / 覆盖：</span></span><br><span class="line"><span class="comment">         * 如果键不存在：直接添加，返回null</span></span><br><span class="line"><span class="comment">         * 如果键存在：会把原有的键值对覆盖，返回这个键原来对应的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        map.put(<span class="string">&quot;杨过&quot;</span>, <span class="string">&quot;小龙女&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰1&quot;</span>);</span><br><span class="line">        res = map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断是否存在【键/值】</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">keyResult</span> <span class="operator">=</span> map.containsKey(<span class="string">&quot;工藤新一&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">valueResult</span> <span class="operator">=</span> map.containsValue(<span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断集合是否为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> map.isEmpty();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取集合的长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> map.size();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 删除：</span></span><br><span class="line"><span class="comment">         * 返回删除的键对应的值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">removeValue</span> <span class="operator">=</span> map.remove(<span class="string">&quot;杨过&quot;</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 清空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历方式-1"><a href="#遍历方式-1" class="headerlink" title="遍历方式"></a>遍历方式</h2><h3 id="键找值"><a href="#键找值" class="headerlink" title="键找值"></a>键找值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;怪盗基德&quot;</span>, <span class="string">&quot;中森青子&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取所有的键，把这些键放到一个单列集合中</span></span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="comment">// 遍历单列集合，得到每一个键</span></span><br><span class="line">        keys.forEach(k -&gt; System.out.println(k + <span class="string">&quot;-&quot;</span> + map.get(k)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;怪盗基德&quot;</span>, <span class="string">&quot;中森青子&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过一个方法获取所有的Entry对象</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;-&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;怪盗基德&quot;</span>, <span class="string">&quot;中森青子&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;工藤新一&quot;</span>, <span class="string">&quot;毛利兰&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;服部平次&quot;</span>, <span class="string">&quot;远山荷叶&quot;</span>);</span><br><span class="line">        map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;-&quot;</span> + v));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap中的方法 &#x3D; Map中的方法</p><h3 id="底层原理-2"><a href="#底层原理-2" class="headerlink" title="底层原理"></a>底层原理</h3><p>同HashSet，就是在计算hash值的时候调用的是键的hashCode()方法</p><ul><li>底层也是哈希表结构</li><li>依赖hashCode()和equals()方法保证键的唯一</li><li>如果<strong>键存储</strong>的是<strong>自定义对象</strong>，需要重写hashCode()和equals()方法</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p><strong>有序</strong>、不重复、无索引<br>原理：底层数据结构仍是哈希表，只是每一个键值对元素又额外多了一个双链表机制记录存储的顺序。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>底层同TreeSet，都是红黑树结构。</li><li>由键决定特性：不重复、无索引、可排序（对键排序）</li><li>默认按照键从小到大排序，也可以自己规定键的排序规则。</li></ul><h4 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h4><h5 id="方法1：默认排序-自定义排序"><a href="#方法1：默认排序-自定义排序" class="headerlink" title="方法1：默认排序&#x2F;自定义排序"></a>方法1：默认排序&#x2F;自定义排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Stu&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Stu o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.age != o.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(o.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo08</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Stu, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">23</span>), <span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">24</span>), <span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;wangwu&quot;</span>, <span class="number">25</span>), <span class="string">&quot;江苏&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法2：比较器排序"><a href="#方法2：比较器排序" class="headerlink" title="方法2：比较器排序"></a>方法2：比较器排序</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// Integer、Double...默认是升序</span></span><br><span class="line">    <span class="comment">// String默认按照字母在ASCII码表中对应的数字升序排列</span></span><br><span class="line">        TreeMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((k1, k2) -&gt; k2 - k1);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">        System.out.println(map); <span class="comment">// 降序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map的使用场景"><a href="#Map的使用场景" class="headerlink" title="Map的使用场景"></a>Map的使用场景</h2><p>HashMap：默认（效率最高）<br>LinkedHashMap：保证存取有序<br>TreeMap：保证排序</p><h1 id="Collections：集合的工具类"><a href="#Collections：集合的工具类" class="headerlink" title="Collections：集合的工具类"></a>Collections：集合的工具类</h1><p><img src="/assets/58c138358244477d9ab1add8f380094e.png" alt="58c138358244477d9ab1add8f380094e.png"></p>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java中的可变参数</title>
      <link href="/post/c1521b0d.html"/>
      <url>/post/c1521b0d.html</url>
      
        <content type="html"><![CDATA[<p>可变参数：方法形参的个数可以发生变化</p><blockquote><p>格式：<br>属性类型…名字</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> ...args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> arg : args) &#123;</span><br><span class="line">            sum += arg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getSum());</span><br><span class="line">        System.out.println(getSum(<span class="number">1</span>));</span><br><span class="line">        System.out.println(getSum(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(getSum(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数的底层就是一个数组，就是不需要我们再创建了，java会帮我们创建好</p><blockquote><p>【注】：</p><ol><li>在方法的形参中最多<strong>只能写一个可变参数</strong>。</li><li>如果方法中有多个形参，可变参数要<strong>写在最后</strong>。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 函数传参 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javase-类和对象</title>
      <link href="/post/d27aeb5c.html"/>
      <url>/post/d27aeb5c.html</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>类：对象共同特征的描述<br>对象：真实存在的东西</p><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>一个java文件中可以定义多个类，但是只能一个类是public修饰，public修饰的类名必须是Java代码的文件名。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 &#123;</span><br><span class="line"><span class="number">1.</span>成员变量</span><br><span class="line"><span class="number">2.</span>成员方法</span><br><span class="line"><span class="number">3.</span>构造器</span><br><span class="line"><span class="number">4.</span>代码块</span><br><span class="line"><span class="number">5.</span>内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h2><p>在JavaBea类中不写main方法，用来描述一类事物<br><strong>标准的JavaBean</strong>：</p><ul><li>类名见名知意</li><li>成员变量使用private修饰</li><li>至少提供两个构造方法（无参、带全部参数）</li><li>提供每一个成员变量对应的get和set方法</li></ul><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>创建javaBean类的对象并复制调用，带main方法</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为。<br>例：<strong>人</strong> 画 <strong>圆</strong>：画圆这个方法应该是定义在圆类里边。【人调用了<strong>圆类</strong>中<strong>画圆</strong>的方法】</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在创建对象的时候<strong>给成员变量进行初始化</strong>的。<br>执行时机：创建对象的时候由虚拟机调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">修饰符 类名(参数) &#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>方法名和类名相同</li><li>没有返回值（不能有return待会结果数据）</li><li>如果没有写构造方法，虚拟机会默认给一个空参的构造方法。</li><li>如果已经定义了构造方法，虚拟机就不会给空参的构造方法。</li><li><strong>推荐：</strong>无论是否使用，把无参构造和带全部参数的构造都写上。</li></ol></blockquote><h1 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h1><p><img src="/assets/86ce0a77e3a242f493d740b3a7bc615e.png" alt="86ce0a77e3a242f493d740b3a7bc615e.png"></p><h2 id="虚拟机创建一个对象的过程"><a href="#虚拟机创建一个对象的过程" class="headerlink" title="虚拟机创建一个对象的过程"></a>虚拟机创建一个对象的过程</h2><p><code>Student s = new Student()</code></p><ol><li>加载class文件</li><li>申明局部变量</li><li>在堆内存中开辟空间</li><li>默认初始化</li><li>显式初始化</li><li>构造方法初始化</li><li>将堆内存中的地址值赋值给左边的局部变量</li></ol><h2 id="一个对象的内存图"><a href="#一个对象的内存图" class="headerlink" title="一个对象的内存图"></a>一个对象的内存图</h2><p><img src="/assets/be6f6e0058b14d0eaced342c6160c8ac.png" alt="be6f6e0058b14d0eaced342c6160c8ac.png"></p><h2 id="两个对象的内存图"><a href="#两个对象的内存图" class="headerlink" title="两个对象的内存图"></a>两个对象的内存图</h2><p><img src="/assets/e0c5fb89dfd84977a33ba998567a74f7.png" alt="e0c5fb89dfd84977a33ba998567a74f7.png"></p><h2 id="两个引用指向同一个对象"><a href="#两个引用指向同一个对象" class="headerlink" title="两个引用指向同一个对象"></a>两个引用指向同一个对象</h2><p><img src="/assets/75ccadc7eac740b0a2dfec05731a4136.png" alt="75ccadc7eac740b0a2dfec05731a4136.png"></p><h1 id="基本数据类型和引用数据类型"><a href="#基本数据类型和引用数据类型" class="headerlink" title="基本数据类型和引用数据类型"></a>基本数据类型和引用数据类型</h1><ul><li><strong>基本数据类型</strong>：数据值存在自己的空间，赋值给其他变量，也是赋的真实的值<br><img src="/assets/fe985ab6ad1b49668ecde4ac68f34ce7.png" alt="fe985ab6ad1b49668ecde4ac68f34ce7.png"></li><li><strong>引用数据类型</strong>：数据值存储在其他空间，自己的空间存储的是其他空间的地址值。<br><img src="/assets/7d44413b38b94fe98df341556698d3c7.png" alt="7d44413b38b94fe98df341556698d3c7.png"></li></ul><h1 id="this的内存原理"><a href="#this的内存原理" class="headerlink" title="this的内存原理"></a>this的内存原理</h1><p>this：区分局部变量和成员变量。<br>本质：所在方法调用者的地址值。<br><img src="/assets/185030e49e7d43409502a8c48db5b469.png" alt="185030e49e7d43409502a8c48db5b469.png"></p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="修饰成员变量（静态变量）"><a href="#修饰成员变量（静态变量）" class="headerlink" title="修饰成员变量（静态变量）"></a>修饰成员变量（静态变量）</h2><p>特点：该类被所有对象共享<br>调用方式：<strong>类名调用</strong>、对象名调用</p><blockquote><p>静态变量是随着类的加载而加载，属于类，不属于对象。</p></blockquote><h2 id="修饰成员方法（静态方法）"><a href="#修饰成员方法（静态方法）" class="headerlink" title="修饰成员方法（静态方法）"></a>修饰成员方法（静态方法）</h2><p>特点：多用于测试类和工具类中，javaBean中很少用<br>调用方式：<strong>类名调用</strong>、对象调用</p><blockquote><p>静态方法只能访问静态变量和静态方法<br>非静态方法可以访问所有的变量和方法（静态、非静态）<br>静态方法中没有this关键字【非静态方法虚拟机会分配一个this对象，表示当前方法调用者的地址，这个this不需要我们来赋值】</p></blockquote><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li>需要私有化构造方法（工具类的对象没有实际意义，可以通过类名直接调用工具类里的方法）</li><li>方法定义为静态的</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h2><ul><li>java只支持单继承，不支持多继承，但支持多层继承</li><li>所有的类都直接或间接继承于Object类</li></ul><h2 id="子类能继承父类的东西"><a href="#子类能继承父类的东西" class="headerlink" title="子类能继承父类的东西"></a>子类能继承父类的东西</h2><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p>父类的构造方法不能被子类继承</p><h4 id="构造方法的访问特点"><a href="#构造方法的访问特点" class="headerlink" title="构造方法的访问特点"></a>构造方法的访问特点</h4><ol><li>父类中构造方法不会被子类继承</li><li>子类中所有的构造方法都先默认访问父类中的无参构造，再执行自己。</li><li>子类构造方法的<strong>第一行</strong>默认都是：**super()**，不写虚拟机也会自动加上。</li></ol><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>私有和非私有的都可以直接继承，但是私有的成员变量不能被直接使用。<br><img src="/assets/1c0a9b60a73f4b40a655257f72e188b6.png" alt="1c0a9b60a73f4b40a655257f72e188b6.png"></p><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><p>只有父类中的<strong>虚方法</strong>才能被子类继承</p><h4 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h4><p>非private、非static、非final<br><img src="/assets/25c8751bd3024b3ca43d05051e22735c.png" alt="25c8751bd3024b3ca43d05051e22735c.png"></p><blockquote><p>作用：提高程序的性能、</p></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><ol><li>重写方法、形参列表和父类一致</li><li>方法的访问权限子类访问权限必须大于等于父类</li><li>方法的返回值类型子类必须小于等于父类</li><li>只有被<strong>添加到虚方法表</strong>中的方法才能被重写</li></ol><h2 id="this、super使用总结"><a href="#this、super使用总结" class="headerlink" title="this、super使用总结"></a>this、super使用总结</h2><p>this：一个变量，表示当前方法调用者的地址（并不是每个对象里都有this）<br>super：表示父类存储空间<br><img src="/assets/c6dab1985c4b44fbacb3ac92514492b7.png" alt="c6dab1985c4b44fbacb3ac92514492b7.png"></p><blockquote><p>注意：如果使用this(…)访问本类其他构造，虚拟机就不会再添加super()了，因为this(…)访问的构造方法里就会自动加上super()</p></blockquote><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：对象的多种表现形态</p><ul><li>变量调用：编译看左边，运行看左边。</li><li>方法调用：编译看左边，运行看右边。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员变量：编译看左边，运行看左边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看左边：java运行时，实际获取的就是左边父类中成员变量的值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(a.name); <span class="comment">// 动物</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用成员方法：编译看左边，运行看右边</span></span><br><span class="line"><span class="comment">         * 编译看左边：javac编译时，会看左边的父类中有没有这个变量，如果有，编译成功；没有，编译报错。</span></span><br><span class="line"><span class="comment">         * 运行看右边：java运行代码时，实际上运行的事子类中的方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        a.show();<span class="comment">// dog show()...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理解：<br>Animal a &#x3D; new Dog();<br>a是Animal类的，所以默认都会从Animal这个类中找。<br>成员变量：在子类对象中，会把父类中的成员变量也继承下来。<br>成员方法：如果子类重写方法，在虚方法表中会把父类中的方法进行覆盖。<br><img src="/assets/4d93bc3624974d43951035b7b828d5c5.png" alt="4d93bc3624974d43951035b7b828d5c5.png"></p></blockquote><h2 id="多态的优势"><a href="#多态的优势" class="headerlink" title="多态的优势"></a>多态的优势</h2><ol><li>右边可以实现解耦合</li><li>定义方法时，使用父类作为参数，可以接受所有的子类对象。</li></ol><h2 id="多态的弊端"><a href="#多态的弊端" class="headerlink" title="多态的弊端"></a>多态的弊端</h2><p>不能调用子类特有的方法【通过强转成子类来调用子类特有的方法】</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包就是文件夹，管理不同功能的Java类。<br>类的全类名 &#x3D; 包名 + 类名</p><h2 id="使用其他类的规则"><a href="#使用其他类的规则" class="headerlink" title="使用其他类的规则"></a>使用其他类的规则</h2><ol><li>使用同一个包中的类，不需要导包</li><li>使用java.lang包中的类，不需要导包</li><li>其他情况都需要导包</li><li>如果使用两个包中同名的类，需要导包</li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>可以修饰方法、类、变量</p><ol><li>修饰方法：表明当前方法是最终方法，不能被重写【当前的方法是一种规则， 不希望别人去改变】</li><li>修饰类：表明当前方法是最终类，不能被继承</li><li>修饰变量：被修饰的变量叫做常量，只能被赋值一次</li></ol><blockquote><p>final修饰的变量是基本类型：变量存储的数据值不能发生改变。<br>final修饰的变量是引用类型：变量存储的地址值不能发生改变，对象的内部可以改变。</p></blockquote><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>控制一个成员可以被访问的范围，可以修饰方法、变量、构造方法、内部类<br><code>private &lt; 缺省 &lt; protected &lt; public</code><br><img src="/assets/1403ed11ca8f49c0907b34d62a592c96.png" alt="1403ed11ca8f49c0907b34d62a592c96.png"></p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><ol><li>局部代码块（淘汰）</li><li>构造代码块：写在成员位置的代码，优先于构造方法执行，可以把多个构造方法中重复的代码写在构造代码块中（淘汰）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">&#123;<span class="comment">// 构造代码块，先于构造方法执行</span></span><br><span class="line">System.out.print(<span class="string">&quot;开始创建对象了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用：<br><img src="/assets/1873509cc7b04927868a9fb188b42fd6.png" alt="1873509cc7b04927868a9fb188b42fd6.png"><br><strong>3. 静态代码块</strong><br>需要通过static关键字修饰，随着类的加载而加载，自动触发，只执行一次。<br><strong>格式</strong>：static{}<br>使用场景：在类加载的时候，做一些<strong>数据初始化</strong>的时候使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">stu2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>将共性的方法抽象到父类之后，在父类中不确定具体的方法体，该方法就可以定义为<strong>抽象方法</strong>。</p><ul><li>抽象类不能创建对象</li><li>抽象类可以有构造方法</li><li>抽象类不一定有抽象方法，有抽象方法的类一定是抽象类</li><li>抽象类的子类要么重写抽象类中所有的抽象方法，要么子类也得是抽象类。</li></ul><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一种规则。<br>抽象类表示一类事务，接口表示一种行为。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口不能实例化</li><li>接口和类之间是实现关系</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>接口的子类：要么重写接口中所有的抽象方法，要么是抽象类。</li></ul><blockquote><p>注意：</p><ol><li>接口和类的实现关系可以是单实现，也可以是多实现。</li><li>实现类可以在继承一个类的同时实现多个接口。<br> <code>public class 类名 extends 父类 implements 接口名1, 接口名2 &#123;&#125;</code></li></ol></blockquote><h2 id="接口中成员的特点"><a href="#接口中成员的特点" class="headerlink" title="接口中成员的特点"></a>接口中成员的特点</h2><ol><li>成员变量：只能是常量，默认修饰符：<code>public static final</code></li><li>构造方法：没有</li><li>成员方法：抽象方法 或 有方法体的方法，默认修饰符：<code>public abstract</code></li></ol><h2 id="接口和类之间的关系"><a href="#接口和类之间的关系" class="headerlink" title="接口和类之间的关系"></a>接口和类之间的关系</h2><ol><li>类和类的关系<br>继承关系，只能单继承，不能多继承，可以多层继承。</li><li>类和接口的关系<br>实现关系，可以单实现，也可以多实现，还可以再继承一个类的同时实现多个接口。</li><li>接口和接口的关系<br>继承关系，可以单继承，也可以多继承。</li></ol><h2 id="JDK8接口新增的方法"><a href="#JDK8接口新增的方法" class="headerlink" title="JDK8接口新增的方法"></a>JDK8接口新增的方法</h2><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>JDK8以后：接口可以定义有方法体的方法，允许在接口中定义默认方法，需要用关键字<strong>default</strong>修饰<br>格式：<code>public default 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>默认方法不是抽象方法，不强制重写，如果被重写，重写的时候需要去掉default关键字。</li><li>public可以省略，default不能省略。</li><li>如果实现了多个接口，多个接口存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ol></blockquote><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>允许在接口中定义静态方法，需要用<strong>static</strong>修饰。<br>格式：<code>public static 返回值类型 方法名(参数列表) &#123;&#125;</code></p><blockquote><ol><li>静态方法只能通过接口名调用，不能通过实现类 或 对象名调用。</li><li>public可以省略，static不能省略。</li></ol></blockquote><h2 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h2><ol><li>接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口。</li><li>接口多态：当一个方法的参数是接口时，可以传递接口<strong>所有实现类的对象</strong>。</li></ol><h2 id="适配器模式：解决接口与接口实现类之间的矛盾问题"><a href="#适配器模式：解决接口与接口实现类之间的矛盾问题" class="headerlink" title="适配器模式：解决接口与接口实现类之间的矛盾问题"></a>适配器模式：解决接口与接口实现类之间的矛盾问题</h2><p>场景：假设一个接口有多个抽象方法，想让某个继承这个接口的类只实现其中一个方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间写一个适配器，空实现Inter接口的所有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123; <span class="comment">// 使用abstract是为了防止InterAdapter创建对象，因为没有意义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果只想要实现Inter接口的第三个抽象方法(如果还想要继承其他类，也可以让中间的适配器类去继承其他的类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 需要用到哪个方法，就重写哪个方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>在一个类的里面，再定义一个类。<br><img src="/assets/5be5b756eaa847b095f13d98145cab10.png" alt="5be5b756eaa847b095f13d98145cab10.png"></p><blockquote><p>内部类表示的事物是外部类的一部分，单独出现没有任何意义。<br>内部类可以访问外部类的成员，包括私有。<br>外部类要访问内部类的成员，必须创建对象。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String carName;</span><br><span class="line">    <span class="type">int</span> carAge;</span><br><span class="line">    String carColor;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 外部类要访问内部类的成员，必须创建对象</span></span><br><span class="line">        System.out.println(carName);</span><br><span class="line">        <span class="comment">// System.out.println(engineName); // 代码报错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Engine</span> &#123;</span><br><span class="line">        String engineName;</span><br><span class="line">        <span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123; <span class="comment">// 内部类可以直接访问外部类的成员，包括私有。</span></span><br><span class="line">            System.out.println(engineName + carName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>写在成员位置，属于外部类的成员。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.a); <span class="comment">// Inner</span></span><br><span class="line">            System.out.println(Outer.<span class="built_in">this</span>.a); <span class="comment">// Outer【Outer.this：获取外部类对象的地址值】</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成员内部类的对象</span></span><br><span class="line">        <span class="comment">// 方法1：直接创建（内部类被非私有修饰）</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="comment">// 方法2：通过get方法（内部类使用private修饰）</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">oi2</span> <span class="operator">=</span> o.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>只能访问外部类中静态变量和静态方法，如果访问非静态的需要创建对象。<br><img src="/assets/15c3fe4b606a4f1b9a023d9b7f64a144.png" alt="15c3fe4b606a4f1b9a023d9b7f64a144.png"><br>创建静态内部类对象的格式：<code>外部类名.内部类名 对象名 = new 外部类名.内部类名()</code><br>调用非静态方法的格式：<code>先创建对象，用对象调用</code><br>调用静态方法的格式：<code>外部类名.内部类名.方法名()</code></p><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><ol><li>将内部类定义在方法里就叫局部内部类，类似于方法里的局部变量。</li><li>外界无法直接使用，需要在方法内部创建对象并使用。</li><li>可以直接访问外部类的成员，也可以访问方法里的局部变量。</li></ol><h2 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h2><p>匿名内部类的本质就是隐藏了名字的内部类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名或接口名() &#123;</span><br><span class="line">重写方法;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Swim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo05</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Swim</span> <span class="variable">swim</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;swim...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个类只使用一次，可以考虑定义成匿名内部类</span></span><br><span class="line">        method(<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用场景，如果定义的类或接口只使用一次，可以使用匿名内部类简化代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> javase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> javase </tag>
            
            <tag> 类 </tag>
            
            <tag> 对象 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
