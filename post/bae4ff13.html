<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | 欢迎来到小林的博客</title><meta name="author" content="小林"><meta name="copyright" content="小林"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis主从搭建主从集群单节点Redis的并发能力有上限（上万），要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。  主节点会把数据同步给从节点，让每个从节点的数据和主节点一样。   启动多个Redis实例 建立集群  在从节点通过命令配置主从关系：slaveof &lt;masterip&gt; &lt;masterport&gt; info replication：查看节点">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/post/bae4ff13.html">
<meta property="og:site_name" content="欢迎来到小林的博客">
<meta property="og:description" content="Redis主从搭建主从集群单节点Redis的并发能力有上限（上万），要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。  主节点会把数据同步给从节点，让每个从节点的数据和主节点一样。   启动多个Redis实例 建立集群  在从节点通过命令配置主从关系：slaveof &lt;masterip&gt; &lt;masterport&gt; info replication：查看节点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/default_cover20.jpg">
<meta property="article:published_time" content="2025-02-23T12:33:32.000Z">
<meta property="article:modified_time" content="2025-02-23T12:46:01.438Z">
<meta property="article:author" content="小林">
<meta property="article:tag" content="后端">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="springcloud">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default_cover20.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis",
  "url": "http://example.com/post/bae4ff13.html",
  "image": "http://example.com/img/default_cover20.jpg",
  "datePublished": "2025-02-23T12:33:32.000Z",
  "dateModified": "2025-02-23T12:46:01.438Z",
  "author": [
    {
      "@type": "Person",
      "name": "小林",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="http://example.com/post/bae4ff13.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":303,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">99</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post type-微服务" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">欢迎来到小林的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-23T12:33:32.000Z" title="发表于 2025-02-23 20:33:32">2025-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-23T12:46:01.438Z" title="更新于 2025-02-23 20:46:01">2025-02-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/post/bae4ff13.html#post-comment"><span id="twikoo-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div><article class="container post-content" id="article-container"><h1 id="Redis主从"><a href="#Redis主从" class="headerlink" title="Redis主从"></a>Redis主从</h1><h2 id="搭建主从集群"><a href="#搭建主从集群" class="headerlink" title="搭建主从集群"></a>搭建主从集群</h2><p>单节点Redis的并发能力有上限（上万），要进一步提高Redis的并发能力，就要搭建主从集群，实现读写分离。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\66db656fc83f44cea5de7851231046a4.png" alt="66db656fc83f44cea5de7851231046a4.png"></p>
<blockquote>
<p>主节点会把数据同步给从节点，让每个从节点的数据和主节点一样。</p>
</blockquote>
<ol>
<li>启动多个Redis实例</li>
<li>建立集群</li>
</ol>
<p>在<code>从节点</code>通过命令配置主从关系：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
<p><img src="D:\project\kaiFa\Blog\source_posts\assets\111ed55062314e94a05125c86b72e65c.png" alt="111ed55062314e94a05125c86b72e65c.png"><br><code>info replication</code>：查看节点状态</p>
<ul>
<li>临时：在控制台输入slaveof命令</li>
<li>永久：在redis.conf文件中利用slaveof命令指定master节点</li>
</ul>
<p>成功后，进入主节点，输入<code>info replication</code>可以看到两个slave，并且在主节点写入后，在从节点可以读取到。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3106dcadee9a4ac8a182dd40e0c64e50.png" alt="3106dcadee9a4ac8a182dd40e0c64e50.png"></p>
<h2 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h2><p>当主从第一次同步连接或断开重连时，从节点都会发送psync请求，尝试数据同步<br>【全量同步】：执行bgsave命令，将完整的内存数据生成RDB文件，把RDB文件写到磁盘中，再通过网络传送到slave（效率超级低）<br>【增量同步】：通过repl_backlog缓冲区，对比主从节点之间的命令差异，发送slave未同步的命令给slave<br><img src="D:\project\kaiFa\Blog\source_posts\assets\fbc7ac70555b4452a114ae2134ae7bb4.png" alt="fbc7ac70555b4452a114ae2134ae7bb4.png"></p>
<ul>
<li>replicationID：每个master节点都有自己唯一的id，主从节点建立连接后，主从节点的replid都保持一致，从节点请主节点时会携带replid，如果replid和主节点的replid一致，说明从节点<code>不是第一次来同步</code>；否则replid就是<code>第一次来同步</code>。</li>
<li>offset：repl_backlog中写入过的数据长度，写操作越多，offset值越大，主从的offset一致代表数据一致。</li>
</ul>
<blockquote>
<p>【问题】repl_backlog是一个缓冲区，用来记录slave和master建立连接后，master中的写命令，但是这个缓冲区的大小默认只有1M。<br>【解决】repl_backlog是一个环形数组，但是如果slave宕机了很长时间，缓冲区slave还没同步的数据又被master覆盖了，此时slave只能做全量同步（效率低）。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\5ca365d39a8e4b8d965887c1b5f4147f.png" alt="5ca365d39a8e4b8d965887c1b5f4147f.png"></p>
</blockquote>
<p>【执行全量同步的时机】：slave节点第一次连接master节点；slave节点断开时间太久，repl_backlog中的offset已经被覆盖。<br>【执行增量同步的时机】：slave节点断开又恢复，并在repl_backlog中能找到offset时。</p>
<h3 id="全量同步效率低的解决"><a href="#全量同步效率低的解决" class="headerlink" title="全量同步效率低的解决"></a>全量同步效率低的解决</h3><ol>
<li>在master中配置<code>repl-diskless-sync: yes</code>启动无磁盘复制，避免全量同步时的磁盘IO。</li>
<li>redis单节点上的<code>内存占用</code>不要太大，减少RDB导致的过多磁盘IO。</li>
<li>适当<code>提高repl_backlog的大小</code>，发现slave宕机时尽快实现故障恢复，尽量避免全量同步。</li>
<li>限制一个master上的slave节点数量，如果实在太多slave，可以采用<code>主-从-从链式结构</code>，减少master压力。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2a10c30b0cb84feca850e86e3fd4bf0b.png" alt="2a10c30b0cb84feca850e86e3fd4bf0b.png"></li>
</ol>
<h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><h2 id="哨兵原理"><a href="#哨兵原理" class="headerlink" title="哨兵原理"></a>哨兵原理</h2><p>哨兵Sentinel机制来实现主从集群的自动故障恢复。哨兵的作用：</p>
<ol>
<li>监控：Sentinel会不断检查master和slave是否按预期工作。</li>
<li>自动故障恢复：如果master故障，sentinel会将一个slave提升为master。当故障恢复后也以新的master为主。</li>
<li>通知：当集群发生故障转移时，sentinel会将最新节点角色信息推送给新的redis客户端。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\f2d2d164338b4706ae56e12e1881fe3f.png" alt="f2d2d164338b4706ae56e12e1881fe3f.png"></li>
</ol>
<h3 id="1-服务状态监控"><a href="#1-服务状态监控" class="headerlink" title="1. 服务状态监控"></a>1. 服务状态监控</h3><p>sentinel基于心跳机制检测服务状态，每隔1s向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某个sentinel节点发现某实例未在规定时间响应，则认为该实例主观下线。</li>
<li>客观下线：如果超过指定数量（quorum）的sentinel都认为该实例主管下线，则该实例客观下线。quorum的值最好超过sentinel实力数量的一半。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\7fae77907e384b33b0c15820bec927d0.png" alt="7fae77907e384b33b0c15820bec927d0.png"></li>
</ul>
<h3 id="2-选举新的master"><a href="#2-选举新的master" class="headerlink" title="2. 选举新的master"></a>2. 选举新的master</h3><p>一旦发现master故障，sentinel需要在slave中选择一个作为新的mater，选择依据：</p>
<ol>
<li>首先判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点。</li>
<li>然后判断slave节点的slave-priority值，值越小优先级越高。（如果是0则用不参与选举，默认是0）</li>
<li>如果slave-priority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高。</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高。</li>
</ol>
<h3 id="3-故障转移"><a href="#3-故障转移" class="headerlink" title="3. 故障转移"></a>3. 故障转移</h3><p>当选中其中一个slave为新的master后，故障转移的步骤：</p>
<ol>
<li>sentinel给备选的slave节点发送<code>slaveof no one</code>命令，让该节点成为master。</li>
<li>sentinel给所有其他slave发送<code>slaveof 192.168.140.101 7002</code>命令，让这些slave成为新的master的从节点，开始从新的master上同步数据。</li>
<li>最后sentinel将故障节点标记为slave（修改故障节点的配置文件redis.conf），当故障节点恢复后，会自动成为新的master的slave节点。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\80663f3b72124173890fba2b64eed1de.png" alt="80663f3b72124173890fba2b64eed1de.png"></li>
</ol>
<h2 id="搭建哨兵集群"><a href="#搭建哨兵集群" class="headerlink" title="搭建哨兵集群"></a>搭建哨兵集群</h2><p>哨兵的配置文件sentinel.conf：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel announce-ip &quot;192.168.140.101&quot;</span><br><span class="line">sentinel monitor hmaster 192.168.140.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds hmaster 5000</span><br><span class="line">sentinel failover-timeout hmaster 60000</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sentinel announce-ip</code>：当前sentinel的ip</li>
<li><code>sentinel monitor hmaster 192.168.140.101 7001 2</code>：sentinel monitor 主节点名 主节点ip 主节点端口 认定master下线的quorum值（sentinel监控配置）</li>
<li><code>sentinel down-after-milliseconds hmaster 5000</code>：哨兵ping节点，超过5s就算超时</li>
<li><code>sentinel failover-timeout hmaster 60000</code>：哨兵监测到主节点宕机后做故障恢复，如果故障恢复又失败了， 再过60s再次做故障恢复。</li>
</ul>
<h1 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h1><h2 id="搭建分片集群"><a href="#搭建分片集群" class="headerlink" title="搭建分片集群"></a>搭建分片集群</h2><p>【问题】主从和哨兵可以解决高可用、高并发度的问题，但是还存在两个问题：海量数据存储问题；高并发写的问题。</p>
<p>【解决】使用分片集群可以解决，分片集群的特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据；</li>
<li>每个master可以有多个slave节点；</li>
<li>master之间可以通过ping检测彼此健康状态<br><img src="D:\project\kaiFa\Blog\source_posts\assets\2cf7e7f9866548598f10533a0d970172.png" alt="2cf7e7f9866548598f10533a0d970172.png"></li>
</ul>
<blockquote>
<p>分片集群可以理解成有多个主从集群组合成的，且不需要哨兵节点，master之间可以通过ping来判断是否下线。</p>
</blockquote>
<ol>
<li>使用docker-compose部署，新建docker-compose.yaml文件：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">r1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7001&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r2</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7002&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r3</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7003&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r4:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r4</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7004&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r5:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r5</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7005&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br><span class="line">  <span class="attr">r6:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">r6</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">entrypoint:</span> [<span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;--port&quot;</span>, <span class="string">&quot;7006&quot;</span>, <span class="string">&quot;--cluster-enabled&quot;</span>, <span class="string">&quot;yes&quot;</span>, <span class="string">&quot;--cluster-config-file&quot;</span>, <span class="string">&quot;node.conf&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>输入<code>docker compose up -d</code>启动redis集群</p>
<ol start="2">
<li>使用命令创建集群：</li>
</ol>
<p>进入任意节点容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it r1 bash</span><br></pre></td></tr></table></figure>

<p>执行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 \</span><br><span class="line">192.168.140.101:7001 192.168.140.101:7002 192.168.140.101:7003 \</span><br><span class="line">192.168.140.101:7004 192.168.140.101:7005 192.168.140.101:7006</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>1</code>：表示副本数量，一个主、一个从<br>redis会默认前三个是主节点，后三个是从节点<br><img src="D:\project\kaiFa\Blog\source_posts\assets\edb3f8133b594b16a50abca9476e7e34.png" alt="edb3f8133b594b16a50abca9476e7e34.png"></p>
</blockquote>
<h2 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h2><p>在redis集群中，共有16384个hash slots，集群中每个redis节点都会分配一定数量的hash slots：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\709832dae3e84408b91b43c99283a092.png" alt="709832dae3e84408b91b43c99283a092.png"></p>
<blockquote>
<p>redis数据不是与节点绑定，而是与插槽slot绑定。当读写数据时，Redis基于CRC16算法对key做hash运算，将得到的结果与16384取余，就计算出这个key的slot值。</p>
</blockquote>
<p>redis在计算key的hash值又分成两种情况：</p>
<ol>
<li>key中包含{}，根据{}之间的字符串计算hash slot</li>
<li>key中不包含{}，根据整个key字符串计算hash slot<br><img src="D:\project\kaiFa\Blog\source_posts\assets\9a753d16a60d428189bd6c3742460235.png" alt="9a753d16a60d428189bd6c3742460235.png"></li>
</ol>
<blockquote>
<p>user这个key计算出的hash值时5474，如果按照之前的方式建立连接，那么在集群1（范围：0-5460）中插入hash值为5474的key，会报错。<br>解决办法：集群模式下建立连接时，应该加上-c参数：<code> redis-cli -c -p 7001</code><br><img src="D:\project\kaiFa\Blog\source_posts\assets\808278ba1e104af9855f6744bed3d14a.png" alt="808278ba1e104af9855f6744bed3d14a.png"></p>
</blockquote>
<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>redis中任意数据类型的键和值都会被封装成一个RedisObject，也叫Redis对象<br><img src="D:\project\kaiFa\Blog\source_posts\assets\19fdf51eda244686b6b0537c512d54d6.png" alt="19fdf51eda244686b6b0537c512d54d6.png"><br>type：数据类型（string、hash、list、set、zset）<br>encoding：数据在内存中的存储方式<br>lru：对象最近一次被访问的时间（太久没被访问的key会在内存不足时淘汰）<br>refcount：当前对象如果被别人引用了，这个值就会+1，如果为0也会被回收<br>*ptr：指向实际存放数据的内存地址</p>
<h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>跳表，首先是链表，与传统链表的差异：</p>
<ul>
<li>元素按照升序排列</li>
<li>节点可以包含多个指针，指针跨度不同<br><img src="D:\project\kaiFa\Blog\source_posts\assets\3a0d6da1191a414e86bad97082b9328d.png" alt="3a0d6da1191a414e86bad97082b9328d.png"></li>
</ul>
<blockquote>
<p>跳表是一个有序的双向链表，每个节点可以包含多层指针（最多允许32层），层级越高，跨度越大，增删改查效率和红黑树基本一致，实现更简单，但是空间复杂度更高</p>
</blockquote>
<h2 id="SortedSet（zset）"><a href="#SortedSet（zset）" class="headerlink" title="SortedSet（zset）"></a>SortedSet（zset）</h2><p><img src="D:\project\kaiFa\Blog\source_posts\assets\068249c114bb4b4bbc1f0864bfee4316.png" alt="068249c114bb4b4bbc1f0864bfee4316.png"><br>特点：</p>
<ul>
<li>每组数据都包含score和member</li>
<li>member唯一</li>
<li>可根据score排序</li>
</ul>
<p><img src="D:\project\kaiFa\Blog\source_posts\assets\c84b6f4e18434842b8d8e65e7391a1e9.png" alt="c84b6f4e18434842b8d8e65e7391a1e9.png"><br>dict：hashtable（存储score、member；member为键，score为值。可以满足member唯一性）<br>zsl：skiplist（存储score、member，在排序时根据score排序）</p>
<p>根据member得到score：去查hash表<br>直到某个元素的score排名：去hashtable里，根据member查到score，再去skiplist里根据score得到排名</p>
<h1 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h1><h2 id="内存过期处理"><a href="#内存过期处理" class="headerlink" title="内存过期处理"></a>内存过期处理</h2><p>redis提供了expire命令，可以给key设置TTL（存活时间）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\8902e444d8be4a5aae2f8105fc804404.png" alt="8902e444d8be4a5aae2f8105fc804404.png"></p>
<h3 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h3><p>redis的本质还是键值型数据库，所有的数据都存储在redisDB的结构中，其中包含<code>两个哈希表</code>：</p>
<ul>
<li>dict：保存redis中所有键值对</li>
<li>expires：保存redis中所有设置了过期时间的key，以及到期时间（写入时间+TTL）<br><img src="D:\project\kaiFa\Blog\source_posts\assets\d919a1dbee3848f4a6362f5f9ae1d0bd.png" alt="d919a1dbee3848f4a6362f5f9ae1d0bd.png"></li>
</ul>
<blockquote>
<p>redis不会实时检测key的过期时间，它不会在key过期后立刻删除。而是采用两种延迟删除的策略：</p>
<ol>
<li><strong>惰性删除</strong>：当有命令需要一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</li>
<li><strong>周期删除</strong>：通过一个定时任务，周期性的抽样部分有TTL的key，如果过期则执行删除。</li>
</ol>
</blockquote>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>内存淘汰：当Redis内存达到设置的阈值时，Redis就会主动挑选部分key删除以释放更多的内存。</p>
<p>Redis在每次处理客户端命令时，都会对内存使用情况判断，如果必要，则执行内存淘汰。内存淘汰的策略有：<br><img src="D:\project\kaiFa\Blog\source_posts\assets\d4b471ece59342e191080ce6c6a29842.png" alt="d4b471ece59342e191080ce6c6a29842.png"></p>
<ol>
<li>前缀：<ul>
<li>allkeys：对所有的key进行淘汰，从dict的哈希表中挑选</li>
<li>volatile：只对设置了TTL的key进行淘汰，从expires的哈希表中挑选</li>
</ul>
</li>
<li>后缀：<ul>
<li>ttl：淘汰ttl小的</li>
<li>random：随机挑选</li>
<li>lru：基于LRU算法</li>
<li>lfu：基于LFU算法</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>LRU（最近最少使用）</strong>：用当前时间 - 最后一次访问时间，值越大越先被淘汰（越久没被访问到的越先淘汰）<br><strong>LFU（最少频率使用）</strong>：统计每个key的访问频率，值越小越先被淘汰</p>
</blockquote>
<p>那么redis怎么直到最近一次访问时间（LRU）或 访问次数（LFU）呢？<br><img src="D:\project\kaiFa\Blog\source_posts\assets\684cd1388ccd4ed9abb7b1f2bd3cbfec.png" alt="684cd1388ccd4ed9abb7b1f2bd3cbfec.png"><br>在redisObject这个数据结构里：</p>
<ul>
<li>当使用LRU策略时，lru这个变量存储的是以<strong>秒</strong>为单位的最近一次访问时间。</li>
<li>当使用LFU策略时，lru这个变量：<ul>
<li>高16位以<strong>分钟</strong>为单位的最近一次访问时间。</li>
<li>低8位记录<code>逻辑访问次数</code>。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\6158b8696e0c4833b44698d044c712f3.png" alt="6158b8696e0c4833b44698d044c712f3.png"></li>
</ul>
</li>
</ul>
<h1 id="Redis缓存问题"><a href="#Redis缓存问题" class="headerlink" title="Redis缓存问题"></a>Redis缓存问题</h1><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><p>保证缓存一致性主要有三种模式：</p>
<ul>
<li><code>Cache Aside Pattern</code>（常用）</li>
<li>Read &#x2F; Write Through Pattern</li>
<li>Write Behind Caching Pattern</li>
</ul>
<h3 id="Cache-Aside模式"><a href="#Cache-Aside模式" class="headerlink" title="Cache Aside模式"></a>Cache Aside模式</h3><p>由<strong>业务的开发者</strong>在更新数据库的同时更新缓存。有一定的业务侵入，但是一致性更好<br><img src="D:\project\kaiFa\Blog\source_posts\assets\1c529edfa8d24a589fce4615753e0dc7.png" alt="1c529edfa8d24a589fce4615753e0dc7.png"></p>
<blockquote>
<p>【注1】：<strong>如何保证redis与数据库的一致性？</strong><br>从数据库中<code>查</code>一条数据，可以直接把这条数据存到redis缓存中；<br>但是如果需要做<code>增删改</code>操作时，redis中可以直接删除，没必要对redis中的数据也做同样的增删改操作。<br>【注2】：<strong>在做增删改操作时，应该先删除redis再改数据库，还是先改数据库再删redis？</strong><br>如果先删redis，再改数据库：当有一个线程A需要删除数据时，它先将redis中的数据删除，来到数据库，此时又有一个线程B来查询同一条数据，先去查询redis未命中，也来到数据库中，此时如果是线程B先执行了查询操作，线程B将查询后的结果又存入redis中，线程A后把这条数据删除。但是redis中却存在线程B的数据，就出现了数据的不一致性，所以需要先删除数据库再改redis。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\af64533d4bd94a308465efed673d092c.png" alt="af64533d4bd94a308465efed673d092c.png"></p>
</blockquote>
<h3 id="Read-Write-Through模式"><a href="#Read-Write-Through模式" class="headerlink" title="Read &#x2F; Write Through模式"></a>Read &#x2F; Write Through模式</h3><p><strong>缓存与数据库整合为一个服务</strong>（没有现成的哈哈哈哈哈），由服务来维护一致性。业务开发者直接调用该服务接口，无需关心一致性问题。</p>
<h3 id="Write-Behind-Caching模式"><a href="#Write-Behind-Caching模式" class="headerlink" title="Write Behind Caching模式"></a>Write Behind Caching模式</h3><p>增删改查业务直接基于缓存，由<strong>其他线程异步调用</strong>的将缓存数据持久化到数据库，保证最终一致性。（高性能，弱 &#x2F; 最终一致性）</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透：客户请求的数据在数据库中不存在，就不会写入缓存，这将导致每次查询这个该数据都会去访问数据库，可能导致数据库挂掉。</p>
<blockquote>
<p>只要用户请求的是不存在的数据，那么每次请求都会发到数据库中</p>
</blockquote>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>实现简单，维护方便，但是会有额外的内存消耗。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ad33c54f8ce74687944135f1d0e62c56.png" alt="ad33c54f8ce74687944135f1d0e62c56.png"></p>
<h3 id="布隆过滤"><a href="#布隆过滤" class="headerlink" title="布隆过滤"></a>布隆过滤</h3><p>请求过来会先经过布隆过滤器，布隆过滤器先判断数据库中是否存在这条数据，如果不存在，就会拒绝这个请求。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\0315493ba18b4ce2ab9d011a2923baf4.png" alt="0315493ba18b4ce2ab9d011a2923baf4.png"><br><img src="D:\project\kaiFa\Blog\source_posts\assets\998c53e9816049ae86b5aa1b3e7dac8c.png" alt="998c53e9816049ae86b5aa1b3e7dac8c.png"></p>
<blockquote>
<p>注意，布隆过滤器判断一个元素不存在时，它绝对不存在；但是如果它判断一个元素存在，这个元素可能会不存在。</p>
</blockquote>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩：在同一时段，<strong>大量的缓存key同时失效</strong>，或<strong>redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\58f67820c2344ef9b48cbc50f05c4d14.png" alt="58f67820c2344ef9b48cbc50f05c4d14.png"><br>解决：</p>
<ol>
<li>给不同的key的TTL添加随机值（避免大量的缓存key同时失效）</li>
<li>利用redis集群提高服务的可用性（避免服务宕机）</li>
<li>给缓存业务添加降级限流策略（防止大量的请求过来）</li>
<li>给业务添加多级缓存（建立nginx缓存、JVM本地缓存…）</li>
</ol>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿（热点Key问题）：<strong>一个被高并发访问</strong>并<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\ed0ff38605e5432ebb34f785fab4ba41.png" alt="ed0ff38605e5432ebb34f785fab4ba41.png"><br>解决方案：</p>
<ol>
<li><p>互斥锁：一个线程查询数据库的时候加锁，此时其他线程都无法访问。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\d2cf3b7587014dc59423214cf6876b35.png" alt="d2cf3b7587014dc59423214cf6876b35.png"></p>
</li>
<li><p>逻辑过期：线程1第一次来查询这个数据，发现数据过期，就先获取互斥锁，（此时会开启一个新的线程，线程1暂时返回过期数据）。<br>开启的新线程（线程2）就重新查询数据，写入缓存，最后释放锁。<br>在新线程（线程2）写入缓存这一过程中，如果还有别的线程（线程3、4）要访问，它先去获取互斥锁，发现互斥锁之前已经被别的线程获取了，此时它也直接返回过期的数据。直到数据被更新为止。<br><img src="D:\project\kaiFa\Blog\source_posts\assets\c83e886175ad41618751575aed38d436.png" alt="c83e886175ad41618751575aed38d436.png"></p>
</li>
</ol>
<p><img src="D:\project\kaiFa\Blog\source_posts\assets\2c4b0d118e284dd8838876d48a0256d6.png" alt="2c4b0d118e284dd8838876d48a0256d6.png"></p>
<blockquote>
<p>穿透就是毫无攻击性直达数据库，因为是不存在的缓存，雪崩就是同时过期或宕机，击穿就是有攻击性因为是存在的缓存跟它战斗然后击穿。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">小林</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/post/bae4ff13.html">http://example.com/post/bae4ff13.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">欢迎来到小林的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/springcloud/">springcloud</a><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post-share"><div class="social-share" data-image="/img/default_cover20.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/post/20601890.html" title="redis实现延迟任务"><img class="cover" src="/img/default_cover6.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-23</div><div class="info-item-2">redis实现延迟任务</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/post/16ac59c1.html" title="【热点文章-实时计算】kafkaStream"><img class="cover" src="/img/default_cover13.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-23</div><div class="info-item-2">【热点文章-实时计算】kafkaStream</div></div><div class="info-2"><div class="info-item-1">实时计算与定时计算  定时计算是争对首页推荐文章更新实时计算是争对点赞、收藏数的  流式计算应用场景 日志分析：网站的用户访问日志进行实时的分析，计算访问量、用户画像、留存率等。实时的进行数据分析。 大屏看板统计：实时的查看网站注册数量，订单数量，购买数量，金额等。 公交的实时数据：可以随时更新公交车方位，计算多久到达站牌。 实时文章热度计算：头条类文章的分值计算，通过用户的行为实时更新文章的分值，分值越高的就越被推荐。  Kafka Stream源处理器（Source Processor）：消息的生产者（可以有多个），发送消息给Stream流式处理，Stream汇总数据后往下游发送给当前某个topic。 案例. 统计单词个数  引入依赖  &lt;dependency&gt;   &lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;   &lt;artifactId&gt;kafka-streams&lt;/artifactId&gt;&lt;/dependency&gt;   编写流式处理代码  /** * 流式处理...</div></div></div></a><a class="pagination-related" href="/post/fa1dd5d9.html" title="【热点文章-定时计算】分布式任务调度框架xxl-job"><img class="cover" src="/img/default_cover17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-23</div><div class="info-item-2">【热点文章-定时计算】分布式任务调度框架xxl-job</div></div><div class="info-2"><div class="info-item-1">分布式任务调度在分布式架构下，一个服务会部署多个实例来运行业务；如果在这种分布式系统环境下运行任务调度，称为分布式任务调度。分布式任务调度框架：xxl-job xxl-job环境搭建本机仓库源码：xxl-job  初始化调度数据库 修改数据库连接信息   此时启动xxl-job-admin项目，在浏览器输入http://localhost:8080/xxl-job-admin即可看到调度中心页面  dockerdocker安装xxl-job docker run -d \-e PARAMS=&quot;--spring.datasource.url=jdbc:mysql://192.168.140.102:3306/xxl_job?Unicode=true&amp;characterEncoding=UTF-8 \--spring.datasource.username=root \--spring.datasource.password=123&quot; \-p 8888:8080 -v /tmp:/data/applogs \--name xxl-job-admin...</div></div></div></a><a class="pagination-related" href="/post/dbbefa8a.html" title="【项目】黑马头条 - 自媒体端"><img class="cover" src="/img/default_cover11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-23</div><div class="info-item-2">【项目】黑马头条 - 自媒体端</div></div><div class="info-2"><div class="info-item-1">图片上传   前端发请求后到达网关，网关会解析用户token后可以得到用户信息，把用户信息放入请求头中继续向自媒体微服务发请求，在自媒体用户微服务的拦截器中就可以获得用户信息。 在自媒体微服务会把图片存储到minio中，并在数据库中存储图片的路径    网关传递userId给自媒体微服务：  @Component@Slf4jpublic class AuthorizeFilter implements Ordered, GlobalFilter &#123;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        //1.获取request和response对象        ServerHttpRequest request = exchange.getRequest();        ServerHttpResponse response = exchange.getResponse();      ...</div></div></div></a><a class="pagination-related" href="/post/e8b36ae1.html" title="微服务架构"><img class="cover" src="/img/default_cover11.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-25</div><div class="info-item-2">微服务架构</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/post/c47d8526.html" title="安装Jenkins"><img class="cover" src="/img/default_cover1.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-23</div><div class="info-item-2">安装Jenkins</div></div><div class="info-2"><div class="info-item-1">Linux中安装jenkins 采用RPM安装包方式：Jenkins安装包下载地址  wget https://pkg.jenkins.io/redhat-stable/jenkins-2.190.1-1.1.noarch.rpm   执行安装  rpm -ivh jenkins-2.190.1-1.1.noarch.rpm   修改配置文件：  vi /etc/sysconfig/jenkins  修改内容： # 修改为对应的目标用户$JENKINS_USER=&quot;root&quot;# 服务监听端口JENKINS_PORT=&quot;16060&quot;   修改目录权限：  chown -R root:root /var/lib/jenkinschown -R root:root /var/cache/jenkinschown -R root:root /var/log/jenkins   重启Jenkins：  systemctl restart jenkins   重启时出现报错不要慌，先查看一下jenkins日志：cat...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">小林</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">99</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xiaolin0333" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_57882997" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="mailto:1160014051@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是小林的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E"><span class="toc-number">1.</span> <span class="toc-text">Redis主从</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-number">1.1.</span> <span class="toc-text">搭建主从集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">主从同步原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E6%95%88%E7%8E%87%E4%BD%8E%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">1.2.1.</span> <span class="toc-text">全量同步效率低的解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%93%A8%E5%85%B5"><span class="toc-number">2.</span> <span class="toc-text">Redis哨兵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">哨兵原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="toc-number">2.1.1.</span> <span class="toc-text">1. 服务状态监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master"><span class="toc-number">2.1.2.</span> <span class="toc-text">2. 选举新的master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">3. 故障转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="toc-number">2.2.</span> <span class="toc-text">搭建哨兵集群</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.</span> <span class="toc-text">Redis分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">3.1.</span> <span class="toc-text">搭建分片集群</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="toc-number">3.2.</span> <span class="toc-text">散列插槽</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RedisObject"><span class="toc-number">4.1.</span> <span class="toc-text">RedisObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SkipList"><span class="toc-number">4.2.</span> <span class="toc-text">SkipList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SortedSet%EF%BC%88zset%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">SortedSet（zset）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">5.</span> <span class="toc-text">Redis内存回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">内存过期处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9Fkey%E5%A4%84%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">过期key处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.</span> <span class="toc-text">内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">Redis缓存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">缓存一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Aside%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">Cache Aside模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Write-Through%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">Read &#x2F; Write Through模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Write-Behind-Caching%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">Write Behind Caching模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">6.2.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.1.</span> <span class="toc-text">缓存空对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4"><span class="toc-number">6.2.2.</span> <span class="toc-text">布隆过滤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">6.3.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">6.4.</span> <span class="toc-text">缓存击穿</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/920afe3c.html" title="把本地搭建的hexo博客部署到自己的服务器上"><img src="/img/default_cover17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="把本地搭建的hexo博客部署到自己的服务器上"/></a><div class="content"><a class="title" href="/post/920afe3c.html" title="把本地搭建的hexo博客部署到自己的服务器上">把本地搭建的hexo博客部署到自己的服务器上</a><time datetime="2025-02-23T12:36:50.000Z" title="发表于 2025-02-23 20:36:50">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/c47d8526.html" title="安装Jenkins"><img src="/img/default_cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安装Jenkins"/></a><div class="content"><a class="title" href="/post/c47d8526.html" title="安装Jenkins">安装Jenkins</a><time datetime="2025-02-23T12:36:39.000Z" title="发表于 2025-02-23 20:36:39">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/45d365e2.html" title="二分查找！！！！"><img src="/img/default_cover4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="二分查找！！！！"/></a><div class="content"><a class="title" href="/post/45d365e2.html" title="二分查找！！！！">二分查找！！！！</a><time datetime="2025-02-23T12:36:27.000Z" title="发表于 2025-02-23 20:36:27">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/84848620.html" title="【搜索文章】：搜索（es）+ 搜索记录（mongodb）+ 搜索联想词"><img src="/img/default_cover5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【搜索文章】：搜索（es）+ 搜索记录（mongodb）+ 搜索联想词"/></a><div class="content"><a class="title" href="/post/84848620.html" title="【搜索文章】：搜索（es）+ 搜索记录（mongodb）+ 搜索联想词">【搜索文章】：搜索（es）+ 搜索记录（mongodb）+ 搜索联想词</a><time datetime="2025-02-23T12:35:17.000Z" title="发表于 2025-02-23 20:35:17">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/fa1dd5d9.html" title="【热点文章-定时计算】分布式任务调度框架xxl-job"><img src="/img/default_cover17.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【热点文章-定时计算】分布式任务调度框架xxl-job"/></a><div class="content"><a class="title" href="/post/fa1dd5d9.html" title="【热点文章-定时计算】分布式任务调度框架xxl-job">【热点文章-定时计算】分布式任务调度框架xxl-job</a><time datetime="2025-02-23T12:35:03.000Z" title="发表于 2025-02-23 20:35:03">2025-02-23</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">&copy;2025 By 小林</div><div class="footer_custom_text">Hi, welcome to my blog</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-api-orcin-kappa.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-api-orcin-kappa.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="162024453" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>